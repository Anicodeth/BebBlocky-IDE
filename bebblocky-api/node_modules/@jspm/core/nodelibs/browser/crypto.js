import { b as buffer, d as dew$2R } from './chunk-44e51b61.js';
import { p as process } from './chunk-2eac56ff.js';
import { d as dew$2Q } from './chunk-c3d025d9.js';
import { y as y$o } from './chunk-4bd36a8f.js';
import { e as e$1$1$1, a as e$1$2, u as u$q } from './chunk-4ccc3a29.js';
import { p as promisify } from './chunk-ce0fbc82.js';
import { X as X$5, t as t$2$2 } from './chunk-b4205b57.js';
import { T as T$9 } from './chunk-5decc758.js';

var exports$2Q = {},
    _dewExec$2P = false;
function dew$2P() {
  if (_dewExec$2P) return exports$2Q;
  _dewExec$2P = true;

  /* eslint-disable node/no-deprecated-api */
  var buffer$1 = buffer;
  var Buffer = buffer$1.Buffer; // alternative to using Object.keys for old browsers

  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }

  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    exports$2Q = buffer$1;
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer$1, exports$2Q);
    exports$2Q.Buffer = SafeBuffer;
  }

  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
  } // Copy static methods from Buffer


  copyProps(Buffer, SafeBuffer);

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }

    return Buffer(arg, encodingOrOffset, length);
  };

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    var buf = Buffer(size);

    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }

    return buf;
  };

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    return Buffer(size);
  };

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    return buffer$1.SlowBuffer(size);
  };

  return exports$2Q;
}

var exports$2P = {},
    _dewExec$2O = false;

var _global$U = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2O() {
  if (_dewExec$2O) return exports$2P;
  _dewExec$2O = true;
  var process$1 = process;
  // limit of Crypto.getRandomValues()
  // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
  var MAX_BYTES = 65536; // Node supports requesting up to this number of bytes
  // https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48

  var MAX_UINT32 = 4294967295;

  function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
  }

  var Buffer = dew$2P().Buffer;

  var crypto = _global$U.crypto || _global$U.msCrypto;

  if (crypto && crypto.getRandomValues) {
    exports$2P = randomBytes;
  } else {
    exports$2P = oldBrowser;
  }

  function randomBytes(size, cb) {
    // phantomjs needs to throw
    if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
    var bytes = Buffer.allocUnsafe(size);

    if (size > 0) {
      // getRandomValues fails on IE if size == 0
      if (size > MAX_BYTES) {
        // this is the max bytes crypto.getRandomValues
        // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
        for (var generated = 0; generated < size; generated += MAX_BYTES) {
          // buffer.slice automatically checks if the end is past the end of
          // the buffer so we don't have to here
          crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
        }
      } else {
        crypto.getRandomValues(bytes);
      }
    }

    if (typeof cb === "function") {
      return process$1.nextTick(function () {
        cb(null, bytes);
      });
    }

    return bytes;
  }

  return exports$2P;
}

var exports$2O = {},
    _dewExec$2N = false;
function dew$2N() {
  if (_dewExec$2N) return exports$2O;
  _dewExec$2N = true;

  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

  /* eslint-disable node/no-deprecated-api */
  var buffer$1 = buffer;
  var Buffer = buffer$1.Buffer; // alternative to using Object.keys for old browsers

  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }

  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    exports$2O = buffer$1;
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer$1, exports$2O);
    exports$2O.Buffer = SafeBuffer;
  }

  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
  }

  SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

  copyProps(Buffer, SafeBuffer);

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }

    return Buffer(arg, encodingOrOffset, length);
  };

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    var buf = Buffer(size);

    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }

    return buf;
  };

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    return Buffer(size);
  };

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    return buffer$1.SlowBuffer(size);
  };

  return exports$2O;
}

var exports$2N = {},
    _dewExec$2M = false;
function dew$2M() {
  if (_dewExec$2M) return exports$2N;
  _dewExec$2M = true;

  var Buffer = dew$2N().Buffer;

  var Transform = dew$2Q().Transform;

  var inherits = dew$2R();

  function throwIfNotStringOrBuffer(val, prefix) {
    if (!Buffer.isBuffer(val) && typeof val !== "string") {
      throw new TypeError(prefix + " must be a string or a buffer");
    }
  }

  function HashBase(blockSize) {
    Transform.call(this);
    this._block = Buffer.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._finalized = false;
  }

  inherits(HashBase, Transform);

  HashBase.prototype._transform = function (chunk, encoding, callback) {
    var error = null;

    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }

    callback(error);
  };

  HashBase.prototype._flush = function (callback) {
    var error = null;

    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }

    callback(error);
  };

  HashBase.prototype.update = function (data, encoding) {
    throwIfNotStringOrBuffer(data, "Data");
    if (this._finalized) throw new Error("Digest already called");
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding); // consume data

    var block = this._block;
    var offset = 0;

    while (this._blockOffset + data.length - offset >= this._blockSize) {
      for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];

      this._update();

      this._blockOffset = 0;
    }

    while (offset < data.length) block[this._blockOffset++] = data[offset++]; // update length


    for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
      this._length[j] += carry;
      carry = this._length[j] / 4294967296 | 0;
      if (carry > 0) this._length[j] -= 4294967296 * carry;
    }

    return this;
  };

  HashBase.prototype._update = function () {
    throw new Error("_update is not implemented");
  };

  HashBase.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = true;

    var digest = this._digest();

    if (encoding !== undefined) digest = digest.toString(encoding); // reset state

    this._block.fill(0);

    this._blockOffset = 0;

    for (var i = 0; i < 4; ++i) this._length[i] = 0;

    return digest;
  };

  HashBase.prototype._digest = function () {
    throw new Error("_digest is not implemented");
  };

  exports$2N = HashBase;
  return exports$2N;
}

var exports$2M = {},
    _dewExec$2L = false;
function dew$2L() {
  if (_dewExec$2L) return exports$2M;
  _dewExec$2L = true;

  var inherits = dew$2R();

  var HashBase = dew$2M();

  var Buffer = dew$2P().Buffer;

  var ARRAY16 = new Array(16);

  function MD5() {
    HashBase.call(this, 64); // state

    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
  }

  inherits(MD5, HashBase);

  MD5.prototype._update = function () {
    var M = ARRAY16;

    for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

    var a = this._a;
    var b = this._b;
    var c = this._c;
    var d = this._d;
    a = fnF(a, b, c, d, M[0], 3614090360, 7);
    d = fnF(d, a, b, c, M[1], 3905402710, 12);
    c = fnF(c, d, a, b, M[2], 606105819, 17);
    b = fnF(b, c, d, a, M[3], 3250441966, 22);
    a = fnF(a, b, c, d, M[4], 4118548399, 7);
    d = fnF(d, a, b, c, M[5], 1200080426, 12);
    c = fnF(c, d, a, b, M[6], 2821735955, 17);
    b = fnF(b, c, d, a, M[7], 4249261313, 22);
    a = fnF(a, b, c, d, M[8], 1770035416, 7);
    d = fnF(d, a, b, c, M[9], 2336552879, 12);
    c = fnF(c, d, a, b, M[10], 4294925233, 17);
    b = fnF(b, c, d, a, M[11], 2304563134, 22);
    a = fnF(a, b, c, d, M[12], 1804603682, 7);
    d = fnF(d, a, b, c, M[13], 4254626195, 12);
    c = fnF(c, d, a, b, M[14], 2792965006, 17);
    b = fnF(b, c, d, a, M[15], 1236535329, 22);
    a = fnG(a, b, c, d, M[1], 4129170786, 5);
    d = fnG(d, a, b, c, M[6], 3225465664, 9);
    c = fnG(c, d, a, b, M[11], 643717713, 14);
    b = fnG(b, c, d, a, M[0], 3921069994, 20);
    a = fnG(a, b, c, d, M[5], 3593408605, 5);
    d = fnG(d, a, b, c, M[10], 38016083, 9);
    c = fnG(c, d, a, b, M[15], 3634488961, 14);
    b = fnG(b, c, d, a, M[4], 3889429448, 20);
    a = fnG(a, b, c, d, M[9], 568446438, 5);
    d = fnG(d, a, b, c, M[14], 3275163606, 9);
    c = fnG(c, d, a, b, M[3], 4107603335, 14);
    b = fnG(b, c, d, a, M[8], 1163531501, 20);
    a = fnG(a, b, c, d, M[13], 2850285829, 5);
    d = fnG(d, a, b, c, M[2], 4243563512, 9);
    c = fnG(c, d, a, b, M[7], 1735328473, 14);
    b = fnG(b, c, d, a, M[12], 2368359562, 20);
    a = fnH(a, b, c, d, M[5], 4294588738, 4);
    d = fnH(d, a, b, c, M[8], 2272392833, 11);
    c = fnH(c, d, a, b, M[11], 1839030562, 16);
    b = fnH(b, c, d, a, M[14], 4259657740, 23);
    a = fnH(a, b, c, d, M[1], 2763975236, 4);
    d = fnH(d, a, b, c, M[4], 1272893353, 11);
    c = fnH(c, d, a, b, M[7], 4139469664, 16);
    b = fnH(b, c, d, a, M[10], 3200236656, 23);
    a = fnH(a, b, c, d, M[13], 681279174, 4);
    d = fnH(d, a, b, c, M[0], 3936430074, 11);
    c = fnH(c, d, a, b, M[3], 3572445317, 16);
    b = fnH(b, c, d, a, M[6], 76029189, 23);
    a = fnH(a, b, c, d, M[9], 3654602809, 4);
    d = fnH(d, a, b, c, M[12], 3873151461, 11);
    c = fnH(c, d, a, b, M[15], 530742520, 16);
    b = fnH(b, c, d, a, M[2], 3299628645, 23);
    a = fnI(a, b, c, d, M[0], 4096336452, 6);
    d = fnI(d, a, b, c, M[7], 1126891415, 10);
    c = fnI(c, d, a, b, M[14], 2878612391, 15);
    b = fnI(b, c, d, a, M[5], 4237533241, 21);
    a = fnI(a, b, c, d, M[12], 1700485571, 6);
    d = fnI(d, a, b, c, M[3], 2399980690, 10);
    c = fnI(c, d, a, b, M[10], 4293915773, 15);
    b = fnI(b, c, d, a, M[1], 2240044497, 21);
    a = fnI(a, b, c, d, M[8], 1873313359, 6);
    d = fnI(d, a, b, c, M[15], 4264355552, 10);
    c = fnI(c, d, a, b, M[6], 2734768916, 15);
    b = fnI(b, c, d, a, M[13], 1309151649, 21);
    a = fnI(a, b, c, d, M[4], 4149444226, 6);
    d = fnI(d, a, b, c, M[11], 3174756917, 10);
    c = fnI(c, d, a, b, M[2], 718787259, 15);
    b = fnI(b, c, d, a, M[9], 3951481745, 21);
    this._a = this._a + a | 0;
    this._b = this._b + b | 0;
    this._c = this._c + c | 0;
    this._d = this._d + d | 0;
  };

  MD5.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 128;

    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);

      this._update();

      this._blockOffset = 0;
    }

    this._block.fill(0, this._blockOffset, 56);

    this._block.writeUInt32LE(this._length[0], 56);

    this._block.writeUInt32LE(this._length[1], 60);

    this._update(); // produce result


    var buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    return buffer;
  };

  function rotl(x, n) {
    return x << n | x >>> 32 - n;
  }

  function fnF(a, b, c, d, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
  }

  function fnG(a, b, c, d, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
  }

  function fnH(a, b, c, d, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
  }

  function fnI(a, b, c, d, m, k, s) {
    return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
  }

  exports$2M = MD5;
  return exports$2M;
}

var exports$2L = {},
    _dewExec$2K = false;
function dew$2K() {
  if (_dewExec$2K) return exports$2L;
  _dewExec$2K = true;
  var Buffer = buffer.Buffer;

  var inherits = dew$2R();

  var HashBase = dew$2M();

  var ARRAY16 = new Array(16);
  var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
  var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];

  function RIPEMD160() {
    HashBase.call(this, 64); // state

    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
  }

  inherits(RIPEMD160, HashBase);

  RIPEMD160.prototype._update = function () {
    var words = ARRAY16;

    for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el = this._e | 0;
    var ar = this._a | 0;
    var br = this._b | 0;
    var cr = this._c | 0;
    var dr = this._d | 0;
    var er = this._e | 0; // computation

    for (var i = 0; i < 80; i += 1) {
      var tl;
      var tr;

      if (i < 16) {
        tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
        tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
      } else if (i < 32) {
        tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
        tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
      } else if (i < 48) {
        tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
        tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
      } else if (i < 64) {
        tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
        tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
      } else {
        // if (i<80) {
        tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
        tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
      }

      al = el;
      el = dl;
      dl = rotl(cl, 10);
      cl = bl;
      bl = tl;
      ar = er;
      er = dr;
      dr = rotl(cr, 10);
      cr = br;
      br = tr;
    } // update state


    var t = this._b + cl + dr | 0;
    this._b = this._c + dl + er | 0;
    this._c = this._d + el + ar | 0;
    this._d = this._e + al + br | 0;
    this._e = this._a + bl + cr | 0;
    this._a = t;
  };

  RIPEMD160.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 128;

    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);

      this._update();

      this._blockOffset = 0;
    }

    this._block.fill(0, this._blockOffset, 56);

    this._block.writeUInt32LE(this._length[0], 56);

    this._block.writeUInt32LE(this._length[1], 60);

    this._update(); // produce result


    var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    buffer.writeInt32LE(this._e, 16);
    return buffer;
  };

  function rotl(x, n) {
    return x << n | x >>> 32 - n;
  }

  function fn1(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
  }

  function fn2(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
  }

  function fn3(a, b, c, d, e, m, k, s) {
    return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
  }

  function fn4(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
  }

  function fn5(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
  }

  exports$2L = RIPEMD160;
  return exports$2L;
}

var exports$2K = {},
    _dewExec$2J = false;

var _global$T = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2J() {
  if (_dewExec$2J) return exports$2K;
  _dewExec$2J = true;

  var Buffer = dew$2P().Buffer; // prototype class for hash functions


  function Hash(blockSize, finalSize) {
    (this || _global$T)._block = Buffer.alloc(blockSize);
    (this || _global$T)._finalSize = finalSize;
    (this || _global$T)._blockSize = blockSize;
    (this || _global$T)._len = 0;
  }

  Hash.prototype.update = function (data, enc) {
    if (typeof data === "string") {
      enc = enc || "utf8";
      data = Buffer.from(data, enc);
    }

    var block = (this || _global$T)._block;
    var blockSize = (this || _global$T)._blockSize;
    var length = data.length;
    var accum = (this || _global$T)._len;

    for (var offset = 0; offset < length;) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);

      for (var i = 0; i < remainder; i++) {
        block[assigned + i] = data[offset + i];
      }

      accum += remainder;
      offset += remainder;

      if (accum % blockSize === 0) {
        this._update(block);
      }
    }

    (this || _global$T)._len += length;
    return this || _global$T;
  };

  Hash.prototype.digest = function (enc) {
    var rem = (this || _global$T)._len % (this || _global$T)._blockSize;
    (this || _global$T)._block[rem] = 128; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
    // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

    (this || _global$T)._block.fill(0, rem + 1);

    if (rem >= (this || _global$T)._finalSize) {
      this._update((this || _global$T)._block);

      (this || _global$T)._block.fill(0);
    }

    var bits = (this || _global$T)._len * 8; // uint32

    if (bits <= 4294967295) {
      (this || _global$T)._block.writeUInt32BE(bits, (this || _global$T)._blockSize - 4); // uint64

    } else {
      var lowBits = (bits & 4294967295) >>> 0;
      var highBits = (bits - lowBits) / 4294967296;

      (this || _global$T)._block.writeUInt32BE(highBits, (this || _global$T)._blockSize - 8);

      (this || _global$T)._block.writeUInt32BE(lowBits, (this || _global$T)._blockSize - 4);
    }

    this._update((this || _global$T)._block);

    var hash = this._hash();

    return enc ? hash.toString(enc) : hash;
  };

  Hash.prototype._update = function () {
    throw new Error("_update must be implemented by subclass");
  };

  exports$2K = Hash;
  return exports$2K;
}

var exports$2J = {},
    _dewExec$2I = false;

var _global$S = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2I() {
  if (_dewExec$2I) return exports$2J;
  _dewExec$2I = true;

  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
   * in FIPS PUB 180-1
   * This source code is derived from sha1.js of the same repository.
   * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
   * operation was added.
   */
  var inherits = dew$2R();

  var Hash = dew$2J();

  var Buffer = dew$2P().Buffer;

  var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
  var W = new Array(80);

  function Sha() {
    this.init();
    (this || _global$S)._w = W;
    Hash.call(this || _global$S, 64, 56);
  }

  inherits(Sha, Hash);

  Sha.prototype.init = function () {
    (this || _global$S)._a = 1732584193;
    (this || _global$S)._b = 4023233417;
    (this || _global$S)._c = 2562383102;
    (this || _global$S)._d = 271733878;
    (this || _global$S)._e = 3285377520;
    return this || _global$S;
  };

  function rotl5(num) {
    return num << 5 | num >>> 27;
  }

  function rotl30(num) {
    return num << 30 | num >>> 2;
  }

  function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }

  Sha.prototype._update = function (M) {
    var W = (this || _global$S)._w;
    var a = (this || _global$S)._a | 0;
    var b = (this || _global$S)._b | 0;
    var c = (this || _global$S)._c | 0;
    var d = (this || _global$S)._d | 0;
    var e = (this || _global$S)._e | 0;

    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

    for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }

    (this || _global$S)._a = a + (this || _global$S)._a | 0;
    (this || _global$S)._b = b + (this || _global$S)._b | 0;
    (this || _global$S)._c = c + (this || _global$S)._c | 0;
    (this || _global$S)._d = d + (this || _global$S)._d | 0;
    (this || _global$S)._e = e + (this || _global$S)._e | 0;
  };

  Sha.prototype._hash = function () {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE((this || _global$S)._a | 0, 0);
    H.writeInt32BE((this || _global$S)._b | 0, 4);
    H.writeInt32BE((this || _global$S)._c | 0, 8);
    H.writeInt32BE((this || _global$S)._d | 0, 12);
    H.writeInt32BE((this || _global$S)._e | 0, 16);
    return H;
  };

  exports$2J = Sha;
  return exports$2J;
}

var exports$2I = {},
    _dewExec$2H = false;

var _global$R = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2H() {
  if (_dewExec$2H) return exports$2I;
  _dewExec$2H = true;

  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
   * in FIPS PUB 180-1
   * Version 2.1a Copyright Paul Johnston 2000 - 2002.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   * Distributed under the BSD License
   * See http://pajhome.org.uk/crypt/md5 for details.
   */
  var inherits = dew$2R();

  var Hash = dew$2J();

  var Buffer = dew$2P().Buffer;

  var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
  var W = new Array(80);

  function Sha1() {
    this.init();
    (this || _global$R)._w = W;
    Hash.call(this || _global$R, 64, 56);
  }

  inherits(Sha1, Hash);

  Sha1.prototype.init = function () {
    (this || _global$R)._a = 1732584193;
    (this || _global$R)._b = 4023233417;
    (this || _global$R)._c = 2562383102;
    (this || _global$R)._d = 271733878;
    (this || _global$R)._e = 3285377520;
    return this || _global$R;
  };

  function rotl1(num) {
    return num << 1 | num >>> 31;
  }

  function rotl5(num) {
    return num << 5 | num >>> 27;
  }

  function rotl30(num) {
    return num << 30 | num >>> 2;
  }

  function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }

  Sha1.prototype._update = function (M) {
    var W = (this || _global$R)._w;
    var a = (this || _global$R)._a | 0;
    var b = (this || _global$R)._b | 0;
    var c = (this || _global$R)._c | 0;
    var d = (this || _global$R)._d | 0;
    var e = (this || _global$R)._e | 0;

    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

    for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }

    (this || _global$R)._a = a + (this || _global$R)._a | 0;
    (this || _global$R)._b = b + (this || _global$R)._b | 0;
    (this || _global$R)._c = c + (this || _global$R)._c | 0;
    (this || _global$R)._d = d + (this || _global$R)._d | 0;
    (this || _global$R)._e = e + (this || _global$R)._e | 0;
  };

  Sha1.prototype._hash = function () {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE((this || _global$R)._a | 0, 0);
    H.writeInt32BE((this || _global$R)._b | 0, 4);
    H.writeInt32BE((this || _global$R)._c | 0, 8);
    H.writeInt32BE((this || _global$R)._d | 0, 12);
    H.writeInt32BE((this || _global$R)._e | 0, 16);
    return H;
  };

  exports$2I = Sha1;
  return exports$2I;
}

var exports$2H = {},
    _dewExec$2G = false;

var _global$Q = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2G() {
  if (_dewExec$2G) return exports$2H;
  _dewExec$2G = true;

  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */
  var inherits = dew$2R();

  var Hash = dew$2J();

  var Buffer = dew$2P().Buffer;

  var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  var W = new Array(64);

  function Sha256() {
    this.init();
    (this || _global$Q)._w = W; // new Array(64)

    Hash.call(this || _global$Q, 64, 56);
  }

  inherits(Sha256, Hash);

  Sha256.prototype.init = function () {
    (this || _global$Q)._a = 1779033703;
    (this || _global$Q)._b = 3144134277;
    (this || _global$Q)._c = 1013904242;
    (this || _global$Q)._d = 2773480762;
    (this || _global$Q)._e = 1359893119;
    (this || _global$Q)._f = 2600822924;
    (this || _global$Q)._g = 528734635;
    (this || _global$Q)._h = 1541459225;
    return this || _global$Q;
  };

  function ch(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function maj(x, y, z) {
    return x & y | z & (x | y);
  }

  function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }

  function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }

  function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }

  function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }

  Sha256.prototype._update = function (M) {
    var W = (this || _global$Q)._w;
    var a = (this || _global$Q)._a | 0;
    var b = (this || _global$Q)._b | 0;
    var c = (this || _global$Q)._c | 0;
    var d = (this || _global$Q)._d | 0;
    var e = (this || _global$Q)._e | 0;
    var f = (this || _global$Q)._f | 0;
    var g = (this || _global$Q)._g | 0;
    var h = (this || _global$Q)._h | 0;

    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

    for (; i < 64; ++i) W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;

    for (var j = 0; j < 64; ++j) {
      var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
      var T2 = sigma0(a) + maj(a, b, c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + T1 | 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 | 0;
    }

    (this || _global$Q)._a = a + (this || _global$Q)._a | 0;
    (this || _global$Q)._b = b + (this || _global$Q)._b | 0;
    (this || _global$Q)._c = c + (this || _global$Q)._c | 0;
    (this || _global$Q)._d = d + (this || _global$Q)._d | 0;
    (this || _global$Q)._e = e + (this || _global$Q)._e | 0;
    (this || _global$Q)._f = f + (this || _global$Q)._f | 0;
    (this || _global$Q)._g = g + (this || _global$Q)._g | 0;
    (this || _global$Q)._h = h + (this || _global$Q)._h | 0;
  };

  Sha256.prototype._hash = function () {
    var H = Buffer.allocUnsafe(32);
    H.writeInt32BE((this || _global$Q)._a, 0);
    H.writeInt32BE((this || _global$Q)._b, 4);
    H.writeInt32BE((this || _global$Q)._c, 8);
    H.writeInt32BE((this || _global$Q)._d, 12);
    H.writeInt32BE((this || _global$Q)._e, 16);
    H.writeInt32BE((this || _global$Q)._f, 20);
    H.writeInt32BE((this || _global$Q)._g, 24);
    H.writeInt32BE((this || _global$Q)._h, 28);
    return H;
  };

  exports$2H = Sha256;
  return exports$2H;
}

var exports$2G = {},
    _dewExec$2F = false;

var _global$P = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2F() {
  if (_dewExec$2F) return exports$2G;
  _dewExec$2F = true;

  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */
  var inherits = dew$2R();

  var Sha256 = dew$2G();

  var Hash = dew$2J();

  var Buffer = dew$2P().Buffer;

  var W = new Array(64);

  function Sha224() {
    this.init();
    (this || _global$P)._w = W; // new Array(64)

    Hash.call(this || _global$P, 64, 56);
  }

  inherits(Sha224, Sha256);

  Sha224.prototype.init = function () {
    (this || _global$P)._a = 3238371032;
    (this || _global$P)._b = 914150663;
    (this || _global$P)._c = 812702999;
    (this || _global$P)._d = 4144912697;
    (this || _global$P)._e = 4290775857;
    (this || _global$P)._f = 1750603025;
    (this || _global$P)._g = 1694076839;
    (this || _global$P)._h = 3204075428;
    return this || _global$P;
  };

  Sha224.prototype._hash = function () {
    var H = Buffer.allocUnsafe(28);
    H.writeInt32BE((this || _global$P)._a, 0);
    H.writeInt32BE((this || _global$P)._b, 4);
    H.writeInt32BE((this || _global$P)._c, 8);
    H.writeInt32BE((this || _global$P)._d, 12);
    H.writeInt32BE((this || _global$P)._e, 16);
    H.writeInt32BE((this || _global$P)._f, 20);
    H.writeInt32BE((this || _global$P)._g, 24);
    return H;
  };

  exports$2G = Sha224;
  return exports$2G;
}

var exports$2F = {},
    _dewExec$2E = false;

var _global$O = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2E() {
  if (_dewExec$2E) return exports$2F;
  _dewExec$2E = true;

  var inherits = dew$2R();

  var Hash = dew$2J();

  var Buffer = dew$2P().Buffer;

  var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  var W = new Array(160);

  function Sha512() {
    this.init();
    (this || _global$O)._w = W;
    Hash.call(this || _global$O, 128, 112);
  }

  inherits(Sha512, Hash);

  Sha512.prototype.init = function () {
    (this || _global$O)._ah = 1779033703;
    (this || _global$O)._bh = 3144134277;
    (this || _global$O)._ch = 1013904242;
    (this || _global$O)._dh = 2773480762;
    (this || _global$O)._eh = 1359893119;
    (this || _global$O)._fh = 2600822924;
    (this || _global$O)._gh = 528734635;
    (this || _global$O)._hh = 1541459225;
    (this || _global$O)._al = 4089235720;
    (this || _global$O)._bl = 2227873595;
    (this || _global$O)._cl = 4271175723;
    (this || _global$O)._dl = 1595750129;
    (this || _global$O)._el = 2917565137;
    (this || _global$O)._fl = 725511199;
    (this || _global$O)._gl = 4215389547;
    (this || _global$O)._hl = 327033209;
    return this || _global$O;
  };

  function Ch(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function maj(x, y, z) {
    return x & y | z & (x | y);
  }

  function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
  }

  function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
  }

  function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
  }

  function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
  }

  function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
  }

  function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
  }

  function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
  }

  Sha512.prototype._update = function (M) {
    var W = (this || _global$O)._w;
    var ah = (this || _global$O)._ah | 0;
    var bh = (this || _global$O)._bh | 0;
    var ch = (this || _global$O)._ch | 0;
    var dh = (this || _global$O)._dh | 0;
    var eh = (this || _global$O)._eh | 0;
    var fh = (this || _global$O)._fh | 0;
    var gh = (this || _global$O)._gh | 0;
    var hh = (this || _global$O)._hh | 0;
    var al = (this || _global$O)._al | 0;
    var bl = (this || _global$O)._bl | 0;
    var cl = (this || _global$O)._cl | 0;
    var dl = (this || _global$O)._dl | 0;
    var el = (this || _global$O)._el | 0;
    var fl = (this || _global$O)._fl | 0;
    var gl = (this || _global$O)._gl | 0;
    var hl = (this || _global$O)._hl | 0;

    for (var i = 0; i < 32; i += 2) {
      W[i] = M.readInt32BE(i * 4);
      W[i + 1] = M.readInt32BE(i * 4 + 4);
    }

    for (; i < 160; i += 2) {
      var xh = W[i - 15 * 2];
      var xl = W[i - 15 * 2 + 1];
      var gamma0 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = W[i - 2 * 2];
      xl = W[i - 2 * 2 + 1];
      var gamma1 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

      var Wi7h = W[i - 7 * 2];
      var Wi7l = W[i - 7 * 2 + 1];
      var Wi16h = W[i - 16 * 2];
      var Wi16l = W[i - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      W[i] = Wih;
      W[i + 1] = Wil;
    }

    for (var j = 0; j < 160; j += 2) {
      Wih = W[j];
      Wil = W[j + 1];
      var majh = maj(ah, bh, ch);
      var majl = maj(al, bl, cl);
      var sigma0h = sigma0(ah, al);
      var sigma0l = sigma0(al, ah);
      var sigma1h = sigma1(eh, el);
      var sigma1l = sigma1(el, eh); // t1 = h + sigma1 + ch + K[j] + W[j]

      var Kih = K[j];
      var Kil = K[j + 1];
      var chh = Ch(eh, fh, gh);
      var chl = Ch(el, fl, gl);
      var t1l = hl + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0; // t2 = sigma0 + maj

      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = dl + t1l | 0;
      eh = dh + t1h + getCarry(el, dl) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + getCarry(al, t1l) | 0;
    }

    (this || _global$O)._al = (this || _global$O)._al + al | 0;
    (this || _global$O)._bl = (this || _global$O)._bl + bl | 0;
    (this || _global$O)._cl = (this || _global$O)._cl + cl | 0;
    (this || _global$O)._dl = (this || _global$O)._dl + dl | 0;
    (this || _global$O)._el = (this || _global$O)._el + el | 0;
    (this || _global$O)._fl = (this || _global$O)._fl + fl | 0;
    (this || _global$O)._gl = (this || _global$O)._gl + gl | 0;
    (this || _global$O)._hl = (this || _global$O)._hl + hl | 0;
    (this || _global$O)._ah = (this || _global$O)._ah + ah + getCarry((this || _global$O)._al, al) | 0;
    (this || _global$O)._bh = (this || _global$O)._bh + bh + getCarry((this || _global$O)._bl, bl) | 0;
    (this || _global$O)._ch = (this || _global$O)._ch + ch + getCarry((this || _global$O)._cl, cl) | 0;
    (this || _global$O)._dh = (this || _global$O)._dh + dh + getCarry((this || _global$O)._dl, dl) | 0;
    (this || _global$O)._eh = (this || _global$O)._eh + eh + getCarry((this || _global$O)._el, el) | 0;
    (this || _global$O)._fh = (this || _global$O)._fh + fh + getCarry((this || _global$O)._fl, fl) | 0;
    (this || _global$O)._gh = (this || _global$O)._gh + gh + getCarry((this || _global$O)._gl, gl) | 0;
    (this || _global$O)._hh = (this || _global$O)._hh + hh + getCarry((this || _global$O)._hl, hl) | 0;
  };

  Sha512.prototype._hash = function () {
    var H = Buffer.allocUnsafe(64);

    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }

    writeInt64BE((this || _global$O)._ah, (this || _global$O)._al, 0);
    writeInt64BE((this || _global$O)._bh, (this || _global$O)._bl, 8);
    writeInt64BE((this || _global$O)._ch, (this || _global$O)._cl, 16);
    writeInt64BE((this || _global$O)._dh, (this || _global$O)._dl, 24);
    writeInt64BE((this || _global$O)._eh, (this || _global$O)._el, 32);
    writeInt64BE((this || _global$O)._fh, (this || _global$O)._fl, 40);
    writeInt64BE((this || _global$O)._gh, (this || _global$O)._gl, 48);
    writeInt64BE((this || _global$O)._hh, (this || _global$O)._hl, 56);
    return H;
  };

  exports$2F = Sha512;
  return exports$2F;
}

var exports$2E = {},
    _dewExec$2D = false;

var _global$N = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2D() {
  if (_dewExec$2D) return exports$2E;
  _dewExec$2D = true;

  var inherits = dew$2R();

  var SHA512 = dew$2E();

  var Hash = dew$2J();

  var Buffer = dew$2P().Buffer;

  var W = new Array(160);

  function Sha384() {
    this.init();
    (this || _global$N)._w = W;
    Hash.call(this || _global$N, 128, 112);
  }

  inherits(Sha384, SHA512);

  Sha384.prototype.init = function () {
    (this || _global$N)._ah = 3418070365;
    (this || _global$N)._bh = 1654270250;
    (this || _global$N)._ch = 2438529370;
    (this || _global$N)._dh = 355462360;
    (this || _global$N)._eh = 1731405415;
    (this || _global$N)._fh = 2394180231;
    (this || _global$N)._gh = 3675008525;
    (this || _global$N)._hh = 1203062813;
    (this || _global$N)._al = 3238371032;
    (this || _global$N)._bl = 914150663;
    (this || _global$N)._cl = 812702999;
    (this || _global$N)._dl = 4144912697;
    (this || _global$N)._el = 4290775857;
    (this || _global$N)._fl = 1750603025;
    (this || _global$N)._gl = 1694076839;
    (this || _global$N)._hl = 3204075428;
    return this || _global$N;
  };

  Sha384.prototype._hash = function () {
    var H = Buffer.allocUnsafe(48);

    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }

    writeInt64BE((this || _global$N)._ah, (this || _global$N)._al, 0);
    writeInt64BE((this || _global$N)._bh, (this || _global$N)._bl, 8);
    writeInt64BE((this || _global$N)._ch, (this || _global$N)._cl, 16);
    writeInt64BE((this || _global$N)._dh, (this || _global$N)._dl, 24);
    writeInt64BE((this || _global$N)._eh, (this || _global$N)._el, 32);
    writeInt64BE((this || _global$N)._fh, (this || _global$N)._fl, 40);
    return H;
  };

  exports$2E = Sha384;
  return exports$2E;
}

var exports$2D = {},
    _dewExec$2C = false;
var module$b = {
  exports: exports$2D
};
function dew$2C() {
  if (_dewExec$2C) return module$b.exports;
  _dewExec$2C = true;

  var exports = module$b.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
    return new Algorithm();
  };

  exports.sha = dew$2I();
  exports.sha1 = dew$2H();
  exports.sha224 = dew$2F();
  exports.sha256 = dew$2G();
  exports.sha384 = dew$2D();
  exports.sha512 = dew$2E();
  return module$b.exports;
}

var exports$f$2 = {},
    _dewExec$f$2 = false;
function dew$f$2() {
  if (_dewExec$f$2) return exports$f$2;
  _dewExec$f$2 = true;

  if (typeof Object.create === "function") {
    // implementation from standard node.js 'util' module
    exports$f$2 = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    exports$f$2 = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function () {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }

  return exports$f$2;
}

var exports$e$2 = {},
    _dewExec$e$2 = false;
function dew$e$2() {
  if (_dewExec$e$2) return exports$e$2;
  _dewExec$e$2 = true;
  exports$e$2 = y$o.EventEmitter;
  return exports$e$2;
}

var exports$d$2 = {},
    _dewExec$d$2 = false;
function dew$d$2() {
  if (_dewExec$d$2) return exports$d$2;
  _dewExec$d$2 = true;

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(Object(source), true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var _require = e$1$1$1,
      Buffer = _require.Buffer;
  var _require2 = X$5,
      inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";

  function copyBuffer(src, target, offset) {
    Buffer.prototype.copy.call(src, target, offset);
  }

  exports$d$2 = /*#__PURE__*/function () {
    function BufferList() {
      _classCallCheck(this, BufferList);

      this.head = null;
      this.tail = null;
      this.length = 0;
    }

    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;

        while (p = p.next) {
          ret += s + p.data;
        }

        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer.alloc(0);
        var ret = Buffer.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;

        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }

        return ret;
      } // Consumes a specified amount of bytes or characters from the buffered data.

    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;

        if (n < this.head.data.length) {
          // `slice` is the same for buffers and strings.
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          // First chunk is a perfect match.
          ret = this.shift();
        } else {
          // Result spans more than one buffer.
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }

        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      } // Consumes a specified amount of characters from the buffered data.

    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;

        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;else ret += str.slice(0, n);
          n -= nb;

          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }

            break;
          }

          ++c;
        }

        this.length -= c;
        return ret;
      } // Consumes a specified amount of bytes from the buffered data.

    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;

        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;

          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }

            break;
          }

          ++c;
        }

        this.length -= c;
        return ret;
      } // Make sure the linked list only shows the minimal necessary information.

    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);

    return BufferList;
  }();

  return exports$d$2;
}

var exports$c$2 = {},
    _dewExec$c$2 = false;
function dew$c$2() {
  if (_dewExec$c$2) return exports$c$2;
  _dewExec$c$2 = true;
  var process = T$9;

  // undocumented cb() API, needed for core, not for public API
  function destroy(err, cb) {
    var _this = this;

    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;

    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }

      return this;
    } // we set destroyed to true before firing error callbacks in order
    // to make it re-entrance safe in case destroy() is called within callbacks


    if (this._readableState) {
      this._readableState.destroyed = true;
    } // if this is a duplex stream mark the writable part as destroyed as well


    if (this._writableState) {
      this._writableState.destroyed = true;
    }

    this._destroy(err || null, function (err) {
      if (!cb && err) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });

    return this;
  }

  function emitErrorAndCloseNT(self, err) {
    emitErrorNT(self, err);
    emitCloseNT(self);
  }

  function emitCloseNT(self) {
    if (self._writableState && !self._writableState.emitClose) return;
    if (self._readableState && !self._readableState.emitClose) return;
    self.emit("close");
  }

  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }

    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }

  function emitErrorNT(self, err) {
    self.emit("error", err);
  }

  function errorOrDestroy(stream, err) {
    // We have tests that rely on errors being emitted
    // in the same tick, so changing this is semver major.
    // For now when you opt-in to autoDestroy we allow
    // the error to be emitted nextTick. In a future
    // semver major update we should change the default to this.
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit("error", err);
  }

  exports$c$2 = {
    destroy: destroy,
    undestroy: undestroy,
    errorOrDestroy: errorOrDestroy
  };
  return exports$c$2;
}

var exports$b$2 = {},
    _dewExec$b$2 = false;
function dew$b$2() {
  if (_dewExec$b$2) return exports$b$2;
  _dewExec$b$2 = true;
  const codes = {};

  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }

    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }

    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }

    }

    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map(i => String(i));

      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


  function endsWith(str, search, this_len) {
    if (this_len === undefined || this_len > str.length) {
      this_len = str.length;
    }

    return str.substring(this_len - search.length, this_len) === search;
  } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }

    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }

  createErrorType("ERR_INVALID_OPT_VALUE", function (name, value) {
    return "The value \"" + value + "\" is invalid for option \"" + name + "\"";
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function (name, expected, actual) {
    // determiner: 'must be' or 'must not be'
    let determiner;

    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }

    let msg;

    if (endsWith(name, " argument")) {
      // For cases like 'first argument'
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }

    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function (name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function (name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function (arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports$b$2.codes = codes;
  return exports$b$2;
}

var exports$a$2 = {},
    _dewExec$a$2 = false;
function dew$a$2() {
  if (_dewExec$a$2) return exports$a$2;
  _dewExec$a$2 = true;

  var ERR_INVALID_OPT_VALUE = dew$b$2().codes.ERR_INVALID_OPT_VALUE;

  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }

  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }

      return Math.floor(hwm);
    } // Default value


    return state.objectMode ? 16 : 16 * 1024;
  }

  exports$a$2 = {
    getHighWaterMark: getHighWaterMark
  };
  return exports$a$2;
}

var exports$9$2 = {},
    _dewExec$9$2 = false;

var _global$2$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$9$2() {
  if (_dewExec$9$2) return exports$9$2;
  _dewExec$9$2 = true;

  /**
   * Module exports.
   */
  exports$9$2 = deprecate;
  /**
   * Mark that a method should not be used.
   * Returns a modified function which warns once by default.
   *
   * If `localStorage.noDeprecation = true` is set, then it is a no-op.
   *
   * If `localStorage.throwDeprecation = true` is set, then deprecated functions
   * will throw an Error when invoked.
   *
   * If `localStorage.traceDeprecation = true` is set, then deprecated functions
   * will invoke `console.trace()` instead of `console.error()`.
   *
   * @param {Function} fn - the function to deprecate
   * @param {String} msg - the string to print to the console when `fn` is invoked
   * @returns {Function} a new "deprecated" version of `fn`
   * @api public
   */

  function deprecate(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }

    var warned = false;

    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }

        warned = true;
      }

      return fn.apply(this || _global$2$2, arguments);
    }

    return deprecated;
  }
  /**
   * Checks `localStorage` for boolean values for the given `name`.
   *
   * @param {String} name
   * @returns {Boolean}
   * @api private
   */


  function config(name) {
    // accessing global.localStorage can trigger a DOMException in sandboxed iframes
    try {
      if (!_global$2$2.localStorage) return false;
    } catch (_) {
      return false;
    }

    var val = _global$2$2.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }

  return exports$9$2;
}

var exports$8$2 = {},
    _dewExec$8$2 = false;

var _global$1$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$8$2() {
  if (_dewExec$8$2) return exports$8$2;
  _dewExec$8$2 = true;
  var process = T$9;
  exports$8$2 = Writable;
  // there will be only 2 of these for each stream


  function CorkedRequest(state) {
    var _this = this;

    this.next = null;
    this.entry = null;

    this.finish = function () {
      onCorkedFinish(_this, state);
    };
  }
  /* </replacement> */

  /*<replacement>*/


  var Duplex;
  /*</replacement>*/

  Writable.WritableState = WritableState;
  /*<replacement>*/

  var internalUtil = {
    deprecate: dew$9$2()
  };
  /*</replacement>*/

  /*<replacement>*/

  var Stream = dew$e$2();
  /*</replacement>*/


  var Buffer = e$1$1$1.Buffer;

  var OurUint8Array = _global$1$2.Uint8Array || function () {};

  function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
  }

  function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  }

  var destroyImpl = dew$c$2();

  var _require = dew$a$2(),
      getHighWaterMark = _require.getHighWaterMark;

  var _require$codes = dew$b$2().codes,
      ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
      ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
      ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
      ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
      ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
      ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
      ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

  var errorOrDestroy = destroyImpl.errorOrDestroy;

  dew$f$2()(Writable, Stream);

  function nop() {}

  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || dew$7$2();
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream,
    // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
    // contains buffers or objects.

    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
    // Note: 0 is a valid value, means that we always return false if
    // the entire buffer is not flushed immediately on write()

    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex); // if _final has been called

    this.finalCalled = false; // drain event flag.

    this.needDrain = false; // at the start of calling end()

    this.ending = false; // when end() has been called, and returned

    this.ended = false; // when 'finish' is emitted

    this.finished = false; // has it been destroyed

    this.destroyed = false; // should we decode strings into buffers before passing to _write?
    // this is here so that some node-core streams can optimize string
    // handling at a lower level.

    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || "utf8"; // not an actual buffer we keep track of, but a measurement
    // of how much we're waiting to get pushed to some underlying
    // socket or file.

    this.length = 0; // a flag to see when we're in the middle of a write.

    this.writing = false; // when true all writes will be buffered until .uncork() call

    this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
    // or on a later tick.  We set this to true at first, because any
    // actions that shouldn't happen until "later" should generally also
    // not happen before the first write call.

    this.sync = true; // a flag to know if we're processing previously buffered items, which
    // may call the _write() callback in the same tick, so that we don't
    // end up in an overlapped onwrite situation.

    this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

    this.onwrite = function (er) {
      onwrite(stream, er);
    }; // the callback that the user supplies to write(chunk,encoding,cb)


    this.writecb = null; // the amount that is being written when _write is called.

    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
    // this must be 0 before 'finish' can be emitted

    this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
    // This is relevant for synchronous Transform streams

    this.prefinished = false; // True if the error was already emitted and should not be thrown again

    this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

    this.autoDestroy = !!options.autoDestroy; // count buffered requests

    this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
    // one allocated and free to use, and we maintain at most two

    this.corkedRequestsFree = new CorkedRequest(this);
  }

  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];

    while (current) {
      out.push(current);
      current = current.next;
    }

    return out;
  };

  (function () {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer " + "instead.", "DEP0003")
      });
    } catch (_) {}
  })(); // Test _writableState for inheritance to account for Duplex streams,
  // whose prototype chain only points to Readable.


  var realHasInstance;

  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance(object) {
      return object instanceof this;
    };
  }

  function Writable(options) {
    Duplex = Duplex || dew$7$2(); // Writable ctor is applied to Duplexes, too.
    // `realHasInstance` is necessary because using plain `instanceof`
    // would return false, as no `_writableState` property is attached.
    // Trying to use the custom `instanceof` for Writable here will also break the
    // Node.js LazyTransform implementation, which has a non-trivial getter for
    // `_writableState` that would lead to infinite recursion.
    // Checking for a Stream.Duplex instance is faster here instead of inside
    // the WritableState constructor, at least with V8 6.5

    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex); // legacy.

    this.writable = true;

    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }

    Stream.call(this);
  } // Otherwise people can pipe Writable streams, which is just wrong.


  Writable.prototype.pipe = function () {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };

  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  } // Checks that a user-supplied chunk is valid, especially for the particular
  // mode the stream is in. Currently this means that `null` is never accepted
  // and undefined/non-string values are only allowed in object mode.


  function validChunk(stream, state, chunk, cb) {
    var er;

    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }

    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }

    return true;
  }

  Writable.prototype.write = function (chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;

    var isBuf = !state.objectMode && _isUint8Array(chunk);

    if (isBuf && !Buffer.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }

    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }

    if (isBuf) encoding = "buffer";else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };

  Writable.prototype.cork = function () {
    this._writableState.corked++;
  };

  Writable.prototype.uncork = function () {
    var state = this._writableState;

    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };

  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    // node::ParseEncoding() requires lower case.
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };

  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });

  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer.from(chunk, encoding);
    }

    return chunk;
  }

  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  }); // if we're already writing something, then just put this
  // in the queue, and wait our turn.  Otherwise, call _write
  // If we return false, then we need a drain event, so set that flag.

  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);

      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }

    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

    if (!ret) state.needDrain = true;

    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk: chunk,
        encoding: encoding,
        isBuf: isBuf,
        callback: cb,
        next: null
      };

      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }

      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }

    return ret;
  }

  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }

  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;

    if (sync) {
      // defer the callback if we are being called synchronously
      // to avoid piling up things on the stack
      process.nextTick(cb, er); // this can emit finish, and it will always happen
      // after error

      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      // the caller expect this to happen before if
      // it is async
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er); // this can emit finish, but finish must
      // always follow error

      finishMaybe(stream, state);
    }
  }

  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }

  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);else {
      // Check if we're actually ready to finish, but don't emit yet
      var finished = needFinish(state) || stream.destroyed;

      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }

      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }

  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  } // Must force callback to be called on nextTick, so that we don't
  // emit 'drain' before the write() consumer gets the 'false' return
  // value, and has a chance to attach a 'drain' listener.


  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  } // if there's something in the buffer waiting, then process it


  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;

    if (stream._writev && entry && entry.next) {
      // Fast case, write everything using _writev()
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;

      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }

      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish); // doWrite is almost always async, defer these to save a bit of time
      // as the hot path ends with doWrite

      state.pendingcb++;
      state.lastBufferedRequest = null;

      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }

      state.bufferedRequestCount = 0;
    } else {
      // Slow case, write chunks one-by-one
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
        // it means that we need to wait until it does.
        // also, that means that the chunk and cb are currently
        // being processed, so move the buffer counter past them.

        if (state.writing) {
          break;
        }
      }

      if (entry === null) state.lastBufferedRequest = null;
    }

    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }

  Writable.prototype._write = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };

  Writable.prototype._writev = null;

  Writable.prototype.end = function (chunk, encoding, cb) {
    var state = this._writableState;

    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }

    if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

    if (state.corked) {
      state.corked = 1;
      this.uncork();
    } // ignore unnecessary end() calls.


    if (!state.ending) endWritable(this, state, cb);
    return this;
  };

  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });

  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }

  function callFinal(stream, state) {
    stream._final(function (err) {
      state.pendingcb--;

      if (err) {
        errorOrDestroy(stream, err);
      }

      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }

  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }

  function finishMaybe(stream, state) {
    var need = needFinish(state);

    if (need) {
      prefinish(stream, state);

      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");

        if (state.autoDestroy) {
          // In case of duplex streams we need a way to detect
          // if the readable side is ready for autoDestroy as well
          var rState = stream._readableState;

          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }

    return need;
  }

  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);

    if (cb) {
      if (state.finished) process.nextTick(cb);else stream.once("finish", cb);
    }

    state.ended = true;
    stream.writable = false;
  }

  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;

    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    } // reuse the free corkReq.


    state.corkedRequestsFree.next = corkReq;
  }

  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === undefined) {
        return false;
      }

      return this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._writableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;

  Writable.prototype._destroy = function (err, cb) {
    cb(err);
  };

  return exports$8$2;
}

var exports$7$2 = {},
    _dewExec$7$2 = false;
function dew$7$2() {
  if (_dewExec$7$2) return exports$7$2;
  _dewExec$7$2 = true;
  var process = T$9;

  /*<replacement>*/
  var objectKeys = Object.keys || function (obj) {
    var keys = [];

    for (var key in obj) {
      keys.push(key);
    }

    return keys;
  };
  /*</replacement>*/


  exports$7$2 = Duplex;

  var Readable = dew$3$2();

  var Writable = dew$8$2();

  dew$f$2()(Duplex, Readable);

  {
    // Allow the keys array to be GC'ed.
    var keys = objectKeys(Writable.prototype);

    for (var v = 0; v < keys.length; v++) {
      var method = keys[v];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }

  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;

    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;

      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }

  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  }); // the no-half-open enforcer

  function onend() {
    // If the writable side ended, then we're ok.
    if (this._writableState.ended) return; // no more data can be written.
    // But allow more writes to happen in this tick.

    process.nextTick(onEndNT, this);
  }

  function onEndNT(self) {
    self.end();
  }

  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined || this._writableState === undefined) {
        return false;
      }

      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (this._readableState === undefined || this._writableState === undefined) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$7$2;
}

var exports$6$2 = {},
    _dewExec$6$2 = false;
function dew$6$2() {
  if (_dewExec$6$2) return exports$6$2;
  _dewExec$6$2 = true;

  var ERR_STREAM_PREMATURE_CLOSE = dew$b$2().codes.ERR_STREAM_PREMATURE_CLOSE;

  function once(callback) {
    var called = false;
    return function () {
      if (called) return;
      called = true;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      callback.apply(this, args);
    };
  }

  function noop() {}

  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }

  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;

    var onlegacyfinish = function onlegacyfinish() {
      if (!stream.writable) onfinish();
    };

    var writableEnded = stream._writableState && stream._writableState.finished;

    var onfinish = function onfinish() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };

    var readableEnded = stream._readableState && stream._readableState.endEmitted;

    var onend = function onend() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };

    var onerror = function onerror(err) {
      callback.call(stream, err);
    };

    var onclose = function onclose() {
      var err;

      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }

      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };

    var onrequest = function onrequest() {
      stream.req.on("finish", onfinish);
    };

    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      // legacy streams
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }

    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function () {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }

  exports$6$2 = eos;
  return exports$6$2;
}

var exports$5$2 = {},
    _dewExec$5$2 = false;
function dew$5$2() {
  if (_dewExec$5$2) return exports$5$2;
  _dewExec$5$2 = true;
  var process = T$9;

  var _Object$setPrototypeO;

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var finished = dew$6$2();

  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");

  function createIterResult(value, done) {
    return {
      value: value,
      done: done
    };
  }

  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];

    if (resolve !== null) {
      var data = iter[kStream].read(); // we defer if data is null
      // we can be expecting either 'end' or
      // 'error'

      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }

  function onReadable(iter) {
    // we wait for the next tick, because it might
    // emit an error with process.nextTick
    process.nextTick(readAndResolve, iter);
  }

  function wrapForNext(lastPromise, iter) {
    return function (resolve, reject) {
      lastPromise.then(function () {
        if (iter[kEnded]) {
          resolve(createIterResult(undefined, true));
          return;
        }

        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }

  var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },

    next: function next() {
      var _this = this; // if we have detected an error in the meanwhile
      // reject straight away


      var error = this[kError];

      if (error !== null) {
        return Promise.reject(error);
      }

      if (this[kEnded]) {
        return Promise.resolve(createIterResult(undefined, true));
      }

      if (this[kStream].destroyed) {
        // We need to defer via nextTick because if .destroy(err) is
        // called, the error will be emitted via nextTick, and
        // we cannot guarantee that there is no error lingering around
        // waiting to be emitted.
        return new Promise(function (resolve, reject) {
          process.nextTick(function () {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(undefined, true));
            }
          });
        });
      } // if we have multiple next() calls
      // we will wait for the previous Promise to finish
      // this logic is optimized to support for await loops,
      // where next() is only called once at a time


      var lastPromise = this[kLastPromise];
      var promise;

      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        // fast path needed to support multiple this.push()
        // without triggering the next() queue
        var data = this[kStream].read();

        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }

        promise = new Promise(this[kHandlePromise]);
      }

      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this; // destroy(err, cb) is a private API
    // we can guarantee we have that here, because we control the
    // Readable class this is attached to


    return new Promise(function (resolve, reject) {
      _this2[kStream].destroy(null, function (err) {
        if (err) {
          reject(err);
          return;
        }

        resolve(createIterResult(undefined, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);

  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
    var _Object$create;

    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();

        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function (err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
        // returned by next() and store the error

        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }

        iterator[kError] = err;
        return;
      }

      var resolve = iterator[kLastResolve];

      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(undefined, true));
      }

      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };

  exports$5$2 = createReadableStreamAsyncIterator;
  return exports$5$2;
}

var exports$4$2 = {},
    _dewExec$4$2 = false;
function dew$4$2() {
  if (_dewExec$4$2) return exports$4$2;
  _dewExec$4$2 = true;

  exports$4$2 = function () {
    throw new Error("Readable.from is not available in the browser");
  };

  return exports$4$2;
}

var exports$3$2 = {},
    _dewExec$3$2 = false;

var _global$M = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$3$2() {
  if (_dewExec$3$2) return exports$3$2;
  _dewExec$3$2 = true;
  var process = T$9;
  exports$3$2 = Readable;
  /*<replacement>*/

  var Duplex;
  /*</replacement>*/

  Readable.ReadableState = ReadableState;
  /*<replacement>*/

  y$o.EventEmitter;

  var EElistenerCount = function EElistenerCount(emitter, type) {
    return emitter.listeners(type).length;
  };
  /*</replacement>*/

  /*<replacement>*/


  var Stream = dew$e$2();
  /*</replacement>*/


  var Buffer = e$1$1$1.Buffer;

  var OurUint8Array = _global$M.Uint8Array || function () {};

  function _uint8ArrayToBuffer(chunk) {
    return Buffer.from(chunk);
  }

  function _isUint8Array(obj) {
    return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  /*<replacement>*/


  var debugUtil = X$5;
  var debug;

  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug() {};
  }
  /*</replacement>*/


  var BufferList = dew$d$2();

  var destroyImpl = dew$c$2();

  var _require = dew$a$2(),
      getHighWaterMark = _require.getHighWaterMark;

  var _require$codes = dew$b$2().codes,
      ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
      ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
      ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;

  dew$f$2()(Readable, Stream);

  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];

  function prependListener(emitter, event, fn) {
    // Sadly this is not cacheable as some libraries bundle their own
    // event emitter implementation with them.
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.

    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }

  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || dew$7$2();
    options = options || {}; // Duplex streams are both readable and writable, but share
    // the same options object.
    // However, some cases require setting options to different
    // values for the readable and the writable sides of the duplex stream.
    // These options can be provided separately as readableXXX and writableXXX.

    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
    // make all the buffer merging and length checks go away

    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
    // Note: 0 is a valid value, means "don't call _read preemptively ever"

    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex); // A linked list is used to store data chunks instead of an array because the
    // linked list can remove elements from the beginning faster than
    // array.shift()

    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
    // immediately, or on a later tick.  We set this to true at first, because
    // any actions that shouldn't happen until "later" should generally also
    // not happen before the first read call.

    this.sync = true; // whenever we return null, then we set a flag to say
    // that we're awaiting a 'readable' event emission.

    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true; // Should close be emitted on destroy. Defaults to true.

    this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

    this.autoDestroy = !!options.autoDestroy; // has it been destroyed

    this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
    // encoding is 'binary' so we have to make this configurable.
    // Everything else in the universe uses 'utf8', though.

    this.defaultEncoding = options.defaultEncoding || "utf8"; // the number of writers that are awaiting a drain event in .pipe()s

    this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;

    if (options.encoding) {
      if (!StringDecoder) StringDecoder = e$1$2.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }

  function Readable(options) {
    Duplex = Duplex || dew$7$2();
    if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
    // the ReadableState constructor, at least with V8 6.5

    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex); // legacy

    this.readable = true;

    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }

    Stream.call(this);
  }

  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === undefined) {
        return false;
      }

      return this._readableState.destroyed;
    },
    set: function set(value) {
      // we ignore the value if the stream
      // has not been initialized yet
      if (!this._readableState) {
        return;
      } // backward compatibility, the user is explicitly
      // managing destroyed


      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;

  Readable.prototype._destroy = function (err, cb) {
    cb(err);
  }; // Manually shove something into the read() buffer.
  // This returns true if the highWaterMark has not been hit yet,
  // similar to how Writable.write() returns true if you should
  // write() some more.


  Readable.prototype.push = function (chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;

    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;

        if (encoding !== state.encoding) {
          chunk = Buffer.from(chunk, encoding);
          encoding = "";
        }

        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }

    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  }; // Unshift should *always* be something directly out of read()


  Readable.prototype.unshift = function (chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };

  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;

    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state, chunk);

      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }

        if (addToFront) {
          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;

          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    } // We can push more data if we are below the highWaterMark.
    // Also, if we have no data yet, we can stand some more bytes.
    // This is to work around cases where hwm=0, such as the repl.


    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }

  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
      if (state.needReadable) emitReadable(stream);
    }

    maybeReadMore(stream, state);
  }

  function chunkInvalid(state, chunk) {
    var er;

    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== undefined && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }

    return er;
  }

  Readable.prototype.isPaused = function () {
    return this._readableState.flowing === false;
  }; // backwards compatibility.


  Readable.prototype.setEncoding = function (enc) {
    if (!StringDecoder) StringDecoder = e$1$2.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

    this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

    var p = this._readableState.buffer.head;
    var content = "";

    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }

    this._readableState.buffer.clear();

    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  }; // Don't raise the hwm > 1GB


  var MAX_HWM = 1073741824;

  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
      n = MAX_HWM;
    } else {
      // Get the next highest power of 2 to prevent increasing hwm excessively in
      // tiny amounts
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }

    return n;
  } // This function is designed to be inlinable, so please take care when making
  // changes to the function body.


  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;

    if (n !== n) {
      // Only flow one buffer at a time
      if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
    } // If we're asking for more than the current hwm, then raise the hwm.


    if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length) return n; // Don't have enough

    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }

    return state.length;
  } // you can override either this method, or the async _read(n) below.


  Readable.prototype.read = function (n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
    // already have a bunch of data in the buffer, then just trigger
    // the 'readable' event and move on.

    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
      return null;
    }

    n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

    if (n === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    } // All the actual chunk generation logic needs to be
    // *below* the call to _read.  The reason is that in certain
    // synthetic stream cases, such as passthrough streams, _read
    // may be a completely synchronous operation which may change
    // the state of the read buffer, providing enough data when
    // before there was *not* enough.
    //
    // So, the steps are:
    // 1. Figure out what the state of things will be after we do
    // a read from the buffer.
    //
    // 2. If that resulting state will trigger a _read, then call _read.
    // Note that this may be asynchronous, or synchronous.  Yes, it is
    // deeply ugly to write APIs this way, but that still doesn't mean
    // that the Readable class should behave improperly, as streams are
    // designed to be sync/async agnostic.
    // Take note if the _read call is sync or async (ie, if the read call
    // has returned yet), so that we know whether or not it's safe to emit
    // 'readable' etc.
    //
    // 3. Actually pull the requested chunks out of the buffer and return.
    // if we need a readable event, then we need to do some reading.


    var doRead = state.needReadable;
    debug("need readable", doRead); // if we currently have less than the highWaterMark, then also read some

    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    } // however, if we've ended, then there's no point, and if we're already
    // reading, then it's unnecessary.


    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true; // if the length is currently zero, then we *need* a readable event.

      if (state.length === 0) state.needReadable = true; // call internal read method

      this._read(state.highWaterMark);

      state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
      // and we need to re-evaluate how much data we can return to the user.

      if (!state.reading) n = howMuchToRead(nOrig, state);
    }

    var ret;
    if (n > 0) ret = fromList(n, state);else ret = null;

    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }

    if (state.length === 0) {
      // If we have nothing in the buffer, then we want to know
      // as soon as we *do* get something into the buffer.
      if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

      if (nOrig !== n && state.ended) endReadable(this);
    }

    if (ret !== null) this.emit("data", ret);
    return ret;
  };

  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;

    if (state.decoder) {
      var chunk = state.decoder.end();

      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }

    state.ended = true;

    if (state.sync) {
      // if we are sync, wait until next tick to emit the data.
      // Otherwise we risk emitting data in the flow()
      // the readable code triggers during a read() call
      emitReadable(stream);
    } else {
      // emit 'readable' now to make sure it gets picked up.
      state.needReadable = false;

      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  } // Don't emit readable right away in sync mode, because this can trigger
  // another read() call => stack overflow.  This way, it might trigger
  // a nextTick recursion warning, but that's not so bad.


  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;

    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }

  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);

    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    } // The stream needs another readable event if
    // 1. It is not flowing, as the flow mechanism will take
    //    care of it.
    // 2. It is not ended.
    // 3. It is below the highWaterMark, so we can schedule
    //    another readable later.


    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  } // at this point, the user has presumably seen the 'readable' event,
  // and called read() to consume some data.  that may have triggered
  // in turn another _read(n) call, in which case reading = true if
  // it's in progress.
  // However, if we're not ended, or reading, and the length < hwm,
  // then go ahead and try to read some more preemptively.


  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }

  function maybeReadMore_(stream, state) {
    // Attempt to read more data if we should.
    //
    // The conditions for reading more data are (one of):
    // - Not enough data buffered (state.length < state.highWaterMark). The loop
    //   is responsible for filling the buffer with enough data if such data
    //   is available. If highWaterMark is 0 and we are not in the flowing mode
    //   we should _not_ attempt to buffer any extra data. We'll get more data
    //   when the stream consumer calls read() instead.
    // - No data in the buffer, and the stream is in flowing mode. In this mode
    //   the loop below is responsible for ensuring read() is called. Failing to
    //   call read here would abort the flow and there's no other mechanism for
    //   continuing the flow if the stream consumer has just subscribed to the
    //   'data' event.
    //
    // In addition to the above conditions to keep reading data, the following
    // conditions prevent the data from being read:
    // - The stream has ended (state.ended).
    // - There is already a pending 'read' operation (state.reading). This is a
    //   case where the the stream has called the implementation defined _read()
    //   method, but they are processing the call asynchronously and have _not_
    //   called push() with new data. In this case we skip performing more
    //   read()s. The execution ends in this method again after the _read() ends
    //   up calling push() with more data.
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length) // didn't get any data, stop spinning.
        break;
    }

    state.readingMore = false;
  } // abstract method.  to be overridden in specific implementation classes.
  // call cb(er, data) where data is <= n in length.
  // for virtual (non-string, non-buffer) streams, "length" is somewhat
  // arbitrary, and perhaps not very meaningful.


  Readable.prototype._read = function (n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };

  Readable.prototype.pipe = function (dest, pipeOpts) {
    var src = this;
    var state = this._readableState;

    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;

      case 1:
        state.pipes = [state.pipes, dest];
        break;

      default:
        state.pipes.push(dest);
        break;
    }

    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process.nextTick(endFn);else src.once("end", endFn);
    dest.on("unpipe", onunpipe);

    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");

      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }

    function onend() {
      debug("onend");
      dest.end();
    } // when the dest drains, it reduces the awaitDrain counter
    // on the source.  This would be more elegant with a .once()
    // handler in flow(), but adding and removing repeatedly is
    // too slow.


    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;

    function cleanup() {
      debug("cleanup"); // cleanup event handlers once the pipe is broken

      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true; // if the reader is waiting for a drain event from this
      // specific writer, then it would cause it to never start
      // flowing again.
      // So, if this is awaiting a drain, then we just call it now.
      // If we don't know, then assume that we are waiting for one.

      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }

    src.on("data", ondata);

    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);

      if (ret === false) {
        // If the user unpiped during `dest.write()`, it is possible
        // to get stuck in a permanently paused state if that write
        // also returned false.
        // => Check whether `dest` is still a piping destination.
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }

        src.pause();
      }
    } // if the dest has an error, then stop piping into it.
    // however, don't suppress the throwing behavior for this.


    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    } // Make sure our error handler is attached before userland ones.


    prependListener(dest, "error", onerror); // Both close and finish should trigger unpipe, but only once.

    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }

    dest.once("close", onclose);

    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }

    dest.once("finish", onfinish);

    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    } // tell the dest that it's being piped to


    dest.emit("pipe", src); // start the flow if it hasn't been started already.

    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }

    return dest;
  };

  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;

      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }

  Readable.prototype.unpipe = function (dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    }; // if we're not piping anywhere, then do nothing.

    if (state.pipesCount === 0) return this; // just one destination.  most common case.

    if (state.pipesCount === 1) {
      // passed in one, but it's not the right one.
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes; // got a match.

      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    } // slow case. multiple pipe destinations.


    if (!dest) {
      // remove all.
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;

      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      }

      return this;
    } // try to find the right one.


    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  }; // set up data events if they are asked for
  // Ensure readable listeners eventually get something


  Readable.prototype.on = function (ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;

    if (ev === "data") {
      // update readableListening so that resume() may be a no-op
      // a few lines down. This is needed to support once('readable').
      state.readableListening = this.listenerCount("readable") > 0; // Try start flowing on next tick if stream isn't explicitly paused

      if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);

        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }

    return res;
  };

  Readable.prototype.addListener = Readable.prototype.on;

  Readable.prototype.removeListener = function (ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);

    if (ev === "readable") {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      process.nextTick(updateReadableListening, this);
    }

    return res;
  };

  Readable.prototype.removeAllListeners = function (ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);

    if (ev === "readable" || ev === undefined) {
      // We need to check if there is someone still listening to
      // readable and reset the state. However this needs to happen
      // after readable has been emitted but before I/O (nextTick) to
      // support once('readable', fn) cycles. This means that calling
      // resume within the same tick will have no
      // effect.
      process.nextTick(updateReadableListening, this);
    }

    return res;
  };

  function updateReadableListening(self) {
    var state = self._readableState;
    state.readableListening = self.listenerCount("readable") > 0;

    if (state.resumeScheduled && !state.paused) {
      // flowing needs to be set to true now, otherwise
      // the upcoming resume will not flow.
      state.flowing = true; // crude way to check if we should resume
    } else if (self.listenerCount("data") > 0) {
      self.resume();
    }
  }

  function nReadingNextTick(self) {
    debug("readable nexttick read 0");
    self.read(0);
  } // pause() and resume() are remnants of the legacy readable stream API
  // If the user uses them, then switch into old mode.


  Readable.prototype.resume = function () {
    var state = this._readableState;

    if (!state.flowing) {
      debug("resume"); // we flow only if there is no one listening
      // for readable, but we still have to call
      // resume()

      state.flowing = !state.readableListening;
      resume(this, state);
    }

    state.paused = false;
    return this;
  };

  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }

  function resume_(stream, state) {
    debug("resume", state.reading);

    if (!state.reading) {
      stream.read(0);
    }

    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }

  Readable.prototype.pause = function () {
    debug("call pause flowing=%j", this._readableState.flowing);

    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }

    this._readableState.paused = true;
    return this;
  };

  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);

    while (state.flowing && stream.read() !== null) {
    }
  } // wrap an old-style stream as the async data source.
  // This is *not* part of the readable stream interface.
  // It is an ugly unfortunate mess of history.


  Readable.prototype.wrap = function (stream) {
    var _this = this;

    var state = this._readableState;
    var paused = false;
    stream.on("end", function () {
      debug("wrapped end");

      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }

      _this.push(null);
    });
    stream.on("data", function (chunk) {
      debug("wrapped data");
      if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

      if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

      var ret = _this.push(chunk);

      if (!ret) {
        paused = true;
        stream.pause();
      }
    }); // proxy all the other methods.
    // important when wrapping filters and duplexes.

    for (var i in stream) {
      if (this[i] === undefined && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    } // proxy certain important events.


    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    } // when we try to consume some more bytes, simply unpause the
    // underlying stream.


    this._read = function (n) {
      debug("wrapped _read", n);

      if (paused) {
        paused = false;
        stream.resume();
      }
    };

    return this;
  };

  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function () {
      if (createReadableStreamAsyncIterator === undefined) {
        createReadableStreamAsyncIterator = dew$5$2();
      }

      return createReadableStreamAsyncIterator(this);
    };
  }

  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  }); // exposed for testing purposes only.

  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  }); // Pluck off n bytes from an array of buffers.
  // Length is the combined lengths of all the buffers in the list.
  // This function is designed to be inlinable, so please take care when making
  // changes to the function body.

  function fromList(n, state) {
    // nothing buffered
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
      // read it all, truncate the list
      if (state.decoder) ret = state.buffer.join("");else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      // read part of list
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }

  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);

    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }

  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length); // Check that we didn't get one last unshift.

    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the writable side is ready for autoDestroy as well
        var wState = stream._writableState;

        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }

  if (typeof Symbol === "function") {
    Readable.from = function (iterable, opts) {
      if (from === undefined) {
        from = dew$4$2();
      }

      return from(Readable, iterable, opts);
    };
  }

  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }

    return -1;
  }

  return exports$3$2;
}

var exports$2$2 = {},
    _dewExec$2$2 = false;
function dew$2$2() {
  if (_dewExec$2$2) return exports$2$2;
  _dewExec$2$2 = true;
  exports$2$2 = Transform;

  var _require$codes = dew$b$2().codes,
      ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
      ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
      ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
      ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

  var Duplex = dew$7$2();

  dew$f$2()(Transform, Duplex);

  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;

    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }

    ts.writechunk = null;
    ts.writecb = null;
    if (data != null) // single equals check for both `null` and `undefined`
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;

    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }

  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }; // start out asking for a readable event once data is transformed.

    this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
    // that Readable wants before the first _read call, so unset the
    // sync guard flag.

    this._readableState.sync = false;

    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    } // When the writable side finishes, then flush out anything remaining.


    this.on("prefinish", prefinish);
  }

  function prefinish() {
    var _this = this;

    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function (er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }

  Transform.prototype.push = function (chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  }; // This is the part where you do stuff!
  // override this function in implementation classes.
  // 'chunk' is an input chunk.
  //
  // Call `push(newChunk)` to pass along transformed output
  // to the readable side.  You may call 'push' zero or more times.
  //
  // Call `cb(err)` when you are done with this chunk.  If you pass
  // an error, then that'll put the hurt on the whole operation.  If you
  // never call cb(), then you'll never get another chunk.


  Transform.prototype._transform = function (chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };

  Transform.prototype._write = function (chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;

    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  }; // Doesn't matter what the args are here.
  // _transform does all the work.
  // That we got here means that the readable side wants more data.


  Transform.prototype._read = function (n) {
    var ts = this._transformState;

    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;

      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      // mark that we need a transform, so that any data that comes in
      // will get processed, now that we've asked for it.
      ts.needTransform = true;
    }
  };

  Transform.prototype._destroy = function (err, cb) {
    Duplex.prototype._destroy.call(this, err, function (err2) {
      cb(err2);
    });
  };

  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null) // single equals check for both `null` and `undefined`
      stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
    // if there's nothing in the write buffer, then that means
    // that nothing more will ever be provided

    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }

  return exports$2$2;
}

var exports$1$2 = {},
    _dewExec$1$2 = false;
function dew$1$2() {
  if (_dewExec$1$2) return exports$1$2;
  _dewExec$1$2 = true;
  exports$1$2 = PassThrough;

  var Transform = dew$2$2();

  dew$f$2()(PassThrough, Transform);

  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }

  PassThrough.prototype._transform = function (chunk, encoding, cb) {
    cb(null, chunk);
  };

  return exports$1$2;
}

var exports$2C = {},
    _dewExec$2B = false;
function dew$2B() {
  if (_dewExec$2B) return exports$2C;
  _dewExec$2B = true;
  var eos;

  function once(callback) {
    var called = false;
    return function () {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }

  var _require$codes = dew$b$2().codes,
      ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
      ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

  function noop(err) {
    // Rethrow the error if it exists to avoid swallowing it
    if (err) throw err;
  }

  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }

  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function () {
      closed = true;
    });
    if (eos === undefined) eos = dew$6$2();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function (err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function (err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true; // request.destroy just do .end - .abort is what we want

      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }

  function call(fn) {
    fn();
  }

  function pipe(from, to) {
    return from.pipe(to);
  }

  function popCallback(streams) {
    if (!streams.length) return noop;
    if (typeof streams[streams.length - 1] !== "function") return noop;
    return streams.pop();
  }

  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }

    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];

    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }

    var error;
    var destroys = streams.map(function (stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function (err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }

  exports$2C = pipeline;
  return exports$2C;
}

var exports$2B = {},
    _dewExec$2A = false;

var _global$L = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2A() {
  if (_dewExec$2A) return exports$2B;
  _dewExec$2A = true;
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  exports$2B = Stream;
  var EE = y$o.EventEmitter;

  var inherits = dew$f$2();

  inherits(Stream, EE);
  Stream.Readable = dew$3$2();
  Stream.Writable = dew$8$2();
  Stream.Duplex = dew$7$2();
  Stream.Transform = dew$2$2();
  Stream.PassThrough = dew$1$2();
  Stream.finished = dew$6$2();
  Stream.pipeline = dew$2B(); // Backwards-compat with node 0.4.x

  Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
  // part of this class) is overridden in the Readable class.

  function Stream() {
    EE.call(this || _global$L);
  }

  Stream.prototype.pipe = function (dest, options) {
    var source = this || _global$L;

    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }

    source.on("data", ondata);

    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }

    dest.on("drain", ondrain); // If the 'end' option is not supplied, dest.end() will be called when
    // source gets the 'end' or 'close' events.  Only dest.end() once.

    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }

    var didOnEnd = false;

    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }

    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    } // don't leave dangling pipes when there are errors.


    function onerror(er) {
      cleanup();

      if (EE.listenerCount(this || _global$L, "error") === 0) {
        throw er; // Unhandled stream error in pipe.
      }
    }

    source.on("error", onerror);
    dest.on("error", onerror); // remove all the event listeners that were added.

    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }

    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source); // Allow for unix-like usage: A.pipe(B).pipe(C)

    return dest;
  };

  return exports$2B;
}

var stream = dew$2A();

stream.Readable;
stream.Writable;
stream.Duplex;
stream.Transform;
stream.PassThrough;
stream.finished;
stream.pipeline;
stream.Stream;

({
  finished: promisify(stream.finished),
  pipeline: promisify(stream.pipeline)
});

var exports$2A = {},
    _dewExec$2z = false;

var _global$K = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2z() {
  if (_dewExec$2z) return exports$2A;
  _dewExec$2z = true;

  var Buffer = dew$2P().Buffer;

  var Transform = stream.Transform;
  var StringDecoder = e$1$2.StringDecoder;

  var inherits = dew$2R();

  function CipherBase(hashMode) {
    Transform.call(this || _global$K);
    (this || _global$K).hashMode = typeof hashMode === "string";

    if ((this || _global$K).hashMode) {
      (this || _global$K)[hashMode] = (this || _global$K)._finalOrDigest;
    } else {
      (this || _global$K).final = (this || _global$K)._finalOrDigest;
    }

    if ((this || _global$K)._final) {
      (this || _global$K).__final = (this || _global$K)._final;
      (this || _global$K)._final = null;
    }

    (this || _global$K)._decoder = null;
    (this || _global$K)._encoding = null;
  }

  inherits(CipherBase, Transform);

  CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
    if (typeof data === "string") {
      data = Buffer.from(data, inputEnc);
    }

    var outData = this._update(data);

    if ((this || _global$K).hashMode) return this || _global$K;

    if (outputEnc) {
      outData = this._toString(outData, outputEnc);
    }

    return outData;
  };

  CipherBase.prototype.setAutoPadding = function () {};

  CipherBase.prototype.getAuthTag = function () {
    throw new Error("trying to get auth tag in unsupported state");
  };

  CipherBase.prototype.setAuthTag = function () {
    throw new Error("trying to set auth tag in unsupported state");
  };

  CipherBase.prototype.setAAD = function () {
    throw new Error("trying to set aad in unsupported state");
  };

  CipherBase.prototype._transform = function (data, _, next) {
    var err;

    try {
      if ((this || _global$K).hashMode) {
        this._update(data);
      } else {
        this.push(this._update(data));
      }
    } catch (e) {
      err = e;
    } finally {
      next(err);
    }
  };

  CipherBase.prototype._flush = function (done) {
    var err;

    try {
      this.push(this.__final());
    } catch (e) {
      err = e;
    }

    done(err);
  };

  CipherBase.prototype._finalOrDigest = function (outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);

    if (outputEnc) {
      outData = this._toString(outData, outputEnc, true);
    }

    return outData;
  };

  CipherBase.prototype._toString = function (value, enc, fin) {
    if (!(this || _global$K)._decoder) {
      (this || _global$K)._decoder = new StringDecoder(enc);
      (this || _global$K)._encoding = enc;
    }

    if ((this || _global$K)._encoding !== enc) throw new Error("can't switch encodings");

    var out = (this || _global$K)._decoder.write(value);

    if (fin) {
      out += (this || _global$K)._decoder.end();
    }

    return out;
  };

  exports$2A = CipherBase;
  return exports$2A;
}

var exports$2z = {},
    _dewExec$2y = false;
function dew$2y() {
  if (_dewExec$2y) return exports$2z;
  _dewExec$2y = true;

  var inherits = dew$2R();

  var MD5 = dew$2L();

  var RIPEMD160 = dew$2K();

  var sha = dew$2C();

  var Base = dew$2z();

  function Hash(hash) {
    Base.call(this, "digest");
    this._hash = hash;
  }

  inherits(Hash, Base);

  Hash.prototype._update = function (data) {
    this._hash.update(data);
  };

  Hash.prototype._final = function () {
    return this._hash.digest();
  };

  exports$2z = function createHash(alg) {
    alg = alg.toLowerCase();
    if (alg === "md5") return new MD5();
    if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD160();
    return new Hash(sha(alg));
  };

  return exports$2z;
}

var exports$2y = {},
    _dewExec$2x = false;
function dew$2x() {
  if (_dewExec$2x) return exports$2y;
  _dewExec$2x = true;

  var inherits = dew$2R();

  var Buffer = dew$2P().Buffer;

  var Base = dew$2z();

  var ZEROS = Buffer.alloc(128);
  var blocksize = 64;

  function Hmac(alg, key) {
    Base.call(this, "digest");

    if (typeof key === "string") {
      key = Buffer.from(key);
    }

    this._alg = alg;
    this._key = key;

    if (key.length > blocksize) {
      key = alg(key);
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize);
    }

    var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
    var opad = this._opad = Buffer.allocUnsafe(blocksize);

    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 54;
      opad[i] = key[i] ^ 92;
    }

    this._hash = [ipad];
  }

  inherits(Hmac, Base);

  Hmac.prototype._update = function (data) {
    this._hash.push(data);
  };

  Hmac.prototype._final = function () {
    var h = this._alg(Buffer.concat(this._hash));

    return this._alg(Buffer.concat([this._opad, h]));
  };

  exports$2y = Hmac;
  return exports$2y;
}

var exports$2x = {},
    _dewExec$2w = false;
function dew$2w() {
  if (_dewExec$2w) return exports$2x;
  _dewExec$2w = true;

  var MD5 = dew$2L();

  exports$2x = function (buffer) {
    return new MD5().update(buffer).digest();
  };

  return exports$2x;
}

var exports$2w = {},
    _dewExec$2v = false;
function dew$2v() {
  if (_dewExec$2v) return exports$2w;
  _dewExec$2v = true;

  var inherits = dew$2R();

  var Legacy = dew$2x();

  var Base = dew$2z();

  var Buffer = dew$2P().Buffer;

  var md5 = dew$2w();

  var RIPEMD160 = dew$2K();

  var sha = dew$2C();

  var ZEROS = Buffer.alloc(128);

  function Hmac(alg, key) {
    Base.call(this, "digest");

    if (typeof key === "string") {
      key = Buffer.from(key);
    }

    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    this._alg = alg;
    this._key = key;

    if (key.length > blocksize) {
      var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
      key = hash.update(key).digest();
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize);
    }

    var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
    var opad = this._opad = Buffer.allocUnsafe(blocksize);

    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 54;
      opad[i] = key[i] ^ 92;
    }

    this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);

    this._hash.update(ipad);
  }

  inherits(Hmac, Base);

  Hmac.prototype._update = function (data) {
    this._hash.update(data);
  };

  Hmac.prototype._final = function () {
    var h = this._hash.digest();

    var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
    return hash.update(this._opad).update(h).digest();
  };

  exports$2w = function createHmac(alg, key) {
    alg = alg.toLowerCase();

    if (alg === "rmd160" || alg === "ripemd160") {
      return new Hmac("rmd160", key);
    }

    if (alg === "md5") {
      return new Legacy(md5, key);
    }

    return new Hmac(alg, key);
  };

  return exports$2w;
}

var _algorithms$1 = {
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
};

var exports$2v = {},
    _dewExec$2u = false;
function dew$2u() {
  if (_dewExec$2u) return exports$2v;
  _dewExec$2u = true;
  exports$2v = _algorithms$1;
  return exports$2v;
}

var exports$2u = {},
    _dewExec$2t = false;
function dew$2t() {
  if (_dewExec$2t) return exports$2u;
  _dewExec$2t = true;
  var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

  exports$2u = function (iterations, keylen) {
    if (typeof iterations !== "number") {
      throw new TypeError("Iterations not a number");
    }

    if (iterations < 0) {
      throw new TypeError("Bad iterations");
    }

    if (typeof keylen !== "number") {
      throw new TypeError("Key length not a number");
    }

    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
      /* eslint no-self-compare: 0 */
      throw new TypeError("Bad key length");
    }
  };

  return exports$2u;
}

var exports$2t = {},
    _dewExec$2s = false;

var _global$J = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2s() {
  if (_dewExec$2s) return exports$2t;
  _dewExec$2s = true;
  var process$1 = process;
  var defaultEncoding;
  /* istanbul ignore next */

  if (_global$J.process && _global$J.process.browser) {
    defaultEncoding = "utf-8";
  } else if (_global$J.process && _global$J.process.version) {
    var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
    defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
  } else {
    defaultEncoding = "utf-8";
  }

  exports$2t = defaultEncoding;
  return exports$2t;
}

var exports$2s = {},
    _dewExec$2r = false;
function dew$2r() {
  if (_dewExec$2r) return exports$2s;
  _dewExec$2r = true;

  var Buffer = dew$2P().Buffer;

  exports$2s = function (thing, encoding, name) {
    if (Buffer.isBuffer(thing)) {
      return thing;
    } else if (typeof thing === "string") {
      return Buffer.from(thing, encoding);
    } else if (ArrayBuffer.isView(thing)) {
      return Buffer.from(thing.buffer);
    } else {
      throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
    }
  };

  return exports$2s;
}

var exports$2r = {},
    _dewExec$2q = false;

var _global$I = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2q() {
  if (_dewExec$2q) return exports$2r;
  _dewExec$2q = true;

  var md5 = dew$2w();

  var RIPEMD160 = dew$2K();

  var sha = dew$2C();

  var Buffer = dew$2P().Buffer;

  var checkParameters = dew$2t();

  var defaultEncoding = dew$2s();

  var toBuffer = dew$2r();

  var ZEROS = Buffer.alloc(128);
  var sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };

  function Hmac(alg, key, saltLen) {
    var hash = getDigest(alg);
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;

    if (key.length > blocksize) {
      key = hash(key);
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize);
    }

    var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
    var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);

    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 54;
      opad[i] = key[i] ^ 92;
    }

    var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    (this || _global$I).ipad1 = ipad1;
    (this || _global$I).ipad2 = ipad;
    (this || _global$I).opad = opad;
    (this || _global$I).alg = alg;
    (this || _global$I).blocksize = blocksize;
    (this || _global$I).hash = hash;
    (this || _global$I).size = sizes[alg];
  }

  Hmac.prototype.run = function (data, ipad) {
    data.copy(ipad, (this || _global$I).blocksize);
    var h = this.hash(ipad);
    h.copy((this || _global$I).opad, (this || _global$I).blocksize);
    return this.hash((this || _global$I).opad);
  };

  function getDigest(alg) {
    function shaFunc(data) {
      return sha(alg).update(data).digest();
    }

    function rmd160Func(data) {
      return new RIPEMD160().update(data).digest();
    }

    if (alg === "rmd160" || alg === "ripemd160") return rmd160Func;
    if (alg === "md5") return md5;
    return shaFunc;
  }

  function pbkdf2(password, salt, iterations, keylen, digest) {
    checkParameters(iterations, keylen);
    password = toBuffer(password, defaultEncoding, "Password");
    salt = toBuffer(salt, defaultEncoding, "Salt");
    digest = digest || "sha1";
    var hmac = new Hmac(digest, password, salt.length);
    var DK = Buffer.allocUnsafe(keylen);
    var block1 = Buffer.allocUnsafe(salt.length + 4);
    salt.copy(block1, 0, 0, salt.length);
    var destPos = 0;
    var hLen = sizes[digest];
    var l = Math.ceil(keylen / hLen);

    for (var i = 1; i <= l; i++) {
      block1.writeUInt32BE(i, salt.length);
      var T = hmac.run(block1, hmac.ipad1);
      var U = T;

      for (var j = 1; j < iterations; j++) {
        U = hmac.run(U, hmac.ipad2);

        for (var k = 0; k < hLen; k++) T[k] ^= U[k];
      }

      T.copy(DK, destPos);
      destPos += hLen;
    }

    return DK;
  }

  exports$2r = pbkdf2;
  return exports$2r;
}

var exports$2q = {},
    _dewExec$2p = false;

var _global$H = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2p() {
  if (_dewExec$2p) return exports$2q;
  _dewExec$2p = true;

  var Buffer = dew$2P().Buffer;

  var checkParameters = dew$2t();

  var defaultEncoding = dew$2s();

  var sync = dew$2q();

  var toBuffer = dew$2r();

  var ZERO_BUF;
  var subtle = _global$H.crypto && _global$H.crypto.subtle;
  var toBrowser = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  };
  var checks = [];

  function checkNative(algo) {
    if (_global$H.process && !_global$H.process.browser) {
      return Promise.resolve(false);
    }

    if (!subtle || !subtle.importKey || !subtle.deriveBits) {
      return Promise.resolve(false);
    }

    if (checks[algo] !== undefined) {
      return checks[algo];
    }

    ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function () {
      return true;
    }).catch(function () {
      return false;
    });
    checks[algo] = prom;
    return prom;
  }

  var nextTick;

  function getNextTick() {
    if (nextTick) {
      return nextTick;
    }

    if (_global$H.process && _global$H.process.nextTick) {
      nextTick = _global$H.process.nextTick;
    } else if (_global$H.queueMicrotask) {
      nextTick = _global$H.queueMicrotask;
    } else if (_global$H.setImmediate) {
      nextTick = _global$H.setImmediate;
    } else {
      nextTick = _global$H.setTimeout;
    }

    return nextTick;
  }

  function browserPbkdf2(password, salt, iterations, length, algo) {
    return subtle.importKey("raw", password, {
      name: "PBKDF2"
    }, false, ["deriveBits"]).then(function (key) {
      return subtle.deriveBits({
        name: "PBKDF2",
        salt: salt,
        iterations: iterations,
        hash: {
          name: algo
        }
      }, key, length << 3);
    }).then(function (res) {
      return Buffer.from(res);
    });
  }

  function resolvePromise(promise, callback) {
    promise.then(function (out) {
      getNextTick()(function () {
        callback(null, out);
      });
    }, function (e) {
      getNextTick()(function () {
        callback(e);
      });
    });
  }

  exports$2q = function (password, salt, iterations, keylen, digest, callback) {
    if (typeof digest === "function") {
      callback = digest;
      digest = undefined;
    }

    digest = digest || "sha1";
    var algo = toBrowser[digest.toLowerCase()];

    if (!algo || typeof _global$H.Promise !== "function") {
      getNextTick()(function () {
        var out;

        try {
          out = sync(password, salt, iterations, keylen, digest);
        } catch (e) {
          return callback(e);
        }

        callback(null, out);
      });
      return;
    }

    checkParameters(iterations, keylen);
    password = toBuffer(password, defaultEncoding, "Password");
    salt = toBuffer(salt, defaultEncoding, "Salt");
    if (typeof callback !== "function") throw new Error("No callback provided to pbkdf2");
    resolvePromise(checkNative(algo).then(function (resp) {
      if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
      return sync(password, salt, iterations, keylen, digest);
    }), callback);
  };

  return exports$2q;
}

var exports$2p = {},
    _dewExec$2o = false;
function dew$2o() {
  if (_dewExec$2o) return exports$2p;
  _dewExec$2o = true;
  exports$2p.pbkdf2 = dew$2p();
  exports$2p.pbkdf2Sync = dew$2q();
  return exports$2p;
}

var exports$2o = {},
    _dewExec$2n = false;
function dew$2n() {
  if (_dewExec$2n) return exports$2o;
  _dewExec$2n = true;

  exports$2o.readUInt32BE = function readUInt32BE(bytes, off) {
    var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
    return res >>> 0;
  };

  exports$2o.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
    bytes[0 + off] = value >>> 24;
    bytes[1 + off] = value >>> 16 & 255;
    bytes[2 + off] = value >>> 8 & 255;
    bytes[3 + off] = value & 255;
  };

  exports$2o.ip = function ip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >>> j + i & 1;
      }

      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inL >>> j + i & 1;
      }
    }

    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= inR >>> j + i & 1;
      }

      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= inL >>> j + i & 1;
      }
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports$2o.rip = function rip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    for (var i = 0; i < 4; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outL <<= 1;
        outL |= inR >>> j + i & 1;
        outL <<= 1;
        outL |= inL >>> j + i & 1;
      }
    }

    for (var i = 4; i < 8; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outR <<= 1;
        outR |= inR >>> j + i & 1;
        outR <<= 1;
        outR |= inL >>> j + i & 1;
      }
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports$2o.pc1 = function pc1(inL, inR, out, off) {
    var outL = 0;
    var outR = 0; // 7, 15, 23, 31, 39, 47, 55, 63
    // 6, 14, 22, 30, 39, 47, 55, 63
    // 5, 13, 21, 29, 39, 47, 55, 63
    // 4, 12, 20, 28

    for (var i = 7; i >= 5; i--) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }

      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inL >> j + i & 1;
      }
    }

    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >> j + i & 1;
    } // 1, 9, 17, 25, 33, 41, 49, 57
    // 2, 10, 18, 26, 34, 42, 50, 58
    // 3, 11, 19, 27, 35, 43, 51, 59
    // 36, 44, 52, 60


    for (var i = 1; i <= 3; i++) {
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inR >> j + i & 1;
      }

      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i & 1;
      }
    }

    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inL >> j + i & 1;
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports$2o.r28shl = function r28shl(num, shift) {
    return num << shift & 268435455 | num >>> 28 - shift;
  };

  var pc2table = [// inL => outL
  14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];

  exports$2o.pc2 = function pc2(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    var len = pc2table.length >>> 1;

    for (var i = 0; i < len; i++) {
      outL <<= 1;
      outL |= inL >>> pc2table[i] & 1;
    }

    for (var i = len; i < pc2table.length; i++) {
      outR <<= 1;
      outR |= inR >>> pc2table[i] & 1;
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports$2o.expand = function expand(r, out, off) {
    var outL = 0;
    var outR = 0;
    outL = (r & 1) << 5 | r >>> 27;

    for (var i = 23; i >= 15; i -= 4) {
      outL <<= 6;
      outL |= r >>> i & 63;
    }

    for (var i = 11; i >= 3; i -= 4) {
      outR |= r >>> i & 63;
      outR <<= 6;
    }

    outR |= (r & 31) << 1 | r >>> 31;
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];

  exports$2o.substitute = function substitute(inL, inR) {
    var out = 0;

    for (var i = 0; i < 4; i++) {
      var b = inL >>> 18 - i * 6 & 63;
      var sb = sTable[i * 64 + b];
      out <<= 4;
      out |= sb;
    }

    for (var i = 0; i < 4; i++) {
      var b = inR >>> 18 - i * 6 & 63;
      var sb = sTable[4 * 64 + i * 64 + b];
      out <<= 4;
      out |= sb;
    }

    return out >>> 0;
  };

  var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];

  exports$2o.permute = function permute(num) {
    var out = 0;

    for (var i = 0; i < permuteTable.length; i++) {
      out <<= 1;
      out |= num >>> permuteTable[i] & 1;
    }

    return out >>> 0;
  };

  exports$2o.padSplit = function padSplit(num, size, group) {
    var str = num.toString(2);

    while (str.length < size) str = "0" + str;

    var out = [];

    for (var i = 0; i < size; i += group) out.push(str.slice(i, i + group));

    return out.join(" ");
  };

  return exports$2o;
}

var exports$2n = {},
    _dewExec$2m = false;
function dew$2m() {
  if (_dewExec$2m) return exports$2n;
  _dewExec$2m = true;
  exports$2n = assert;

  function assert(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
  }

  assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
  };

  return exports$2n;
}

var exports$2m = {},
    _dewExec$2l = false;
function dew$2l() {
  if (_dewExec$2l) return exports$2m;
  _dewExec$2l = true;

  var assert = dew$2m();

  function Cipher(options) {
    this.options = options;
    this.type = this.options.type;
    this.blockSize = 8;

    this._init();

    this.buffer = new Array(this.blockSize);
    this.bufferOff = 0;
  }

  exports$2m = Cipher;

  Cipher.prototype._init = function _init() {// Might be overrided
  };

  Cipher.prototype.update = function update(data) {
    if (data.length === 0) return [];
    if (this.type === "decrypt") return this._updateDecrypt(data);else return this._updateEncrypt(data);
  };

  Cipher.prototype._buffer = function _buffer(data, off) {
    // Append data to buffer
    var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);

    for (var i = 0; i < min; i++) this.buffer[this.bufferOff + i] = data[off + i];

    this.bufferOff += min; // Shift next

    return min;
  };

  Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
    this._update(this.buffer, 0, out, off);

    this.bufferOff = 0;
    return this.blockSize;
  };

  Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
    var inputOff = 0;
    var outputOff = 0;
    var count = (this.bufferOff + data.length) / this.blockSize | 0;
    var out = new Array(count * this.blockSize);

    if (this.bufferOff !== 0) {
      inputOff += this._buffer(data, inputOff);
      if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);
    } // Write blocks


    var max = data.length - (data.length - inputOff) % this.blockSize;

    for (; inputOff < max; inputOff += this.blockSize) {
      this._update(data, inputOff, out, outputOff);

      outputOff += this.blockSize;
    } // Queue rest


    for (; inputOff < data.length; inputOff++, this.bufferOff++) this.buffer[this.bufferOff] = data[inputOff];

    return out;
  };

  Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
    var inputOff = 0;
    var outputOff = 0;
    var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
    var out = new Array(count * this.blockSize); // TODO(indutny): optimize it, this is far from optimal

    for (; count > 0; count--) {
      inputOff += this._buffer(data, inputOff);
      outputOff += this._flushBuffer(out, outputOff);
    } // Buffer rest of the input


    inputOff += this._buffer(data, inputOff);
    return out;
  };

  Cipher.prototype.final = function final(buffer) {
    var first;
    if (buffer) first = this.update(buffer);
    var last;
    if (this.type === "encrypt") last = this._finalEncrypt();else last = this._finalDecrypt();
    if (first) return first.concat(last);else return last;
  };

  Cipher.prototype._pad = function _pad(buffer, off) {
    if (off === 0) return false;

    while (off < buffer.length) buffer[off++] = 0;

    return true;
  };

  Cipher.prototype._finalEncrypt = function _finalEncrypt() {
    if (!this._pad(this.buffer, this.bufferOff)) return [];
    var out = new Array(this.blockSize);

    this._update(this.buffer, 0, out, 0);

    return out;
  };

  Cipher.prototype._unpad = function _unpad(buffer) {
    return buffer;
  };

  Cipher.prototype._finalDecrypt = function _finalDecrypt() {
    assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var out = new Array(this.blockSize);

    this._flushBuffer(out, 0);

    return this._unpad(out);
  };

  return exports$2m;
}

var exports$2l = {},
    _dewExec$2k = false;
function dew$2k() {
  if (_dewExec$2k) return exports$2l;
  _dewExec$2k = true;

  var assert = dew$2m();

  var inherits = dew$2R();

  var utils = dew$2n();

  var Cipher = dew$2l();

  function DESState() {
    this.tmp = new Array(2);
    this.keys = null;
  }

  function DES(options) {
    Cipher.call(this, options);
    var state = new DESState();
    this._desState = state;
    this.deriveKeys(state, options.key);
  }

  inherits(DES, Cipher);
  exports$2l = DES;

  DES.create = function create(options) {
    return new DES(options);
  };

  var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];

  DES.prototype.deriveKeys = function deriveKeys(state, key) {
    state.keys = new Array(16 * 2);
    assert.equal(key.length, this.blockSize, "Invalid key length");
    var kL = utils.readUInt32BE(key, 0);
    var kR = utils.readUInt32BE(key, 4);
    utils.pc1(kL, kR, state.tmp, 0);
    kL = state.tmp[0];
    kR = state.tmp[1];

    for (var i = 0; i < state.keys.length; i += 2) {
      var shift = shiftTable[i >>> 1];
      kL = utils.r28shl(kL, shift);
      kR = utils.r28shl(kR, shift);
      utils.pc2(kL, kR, state.keys, i);
    }
  };

  DES.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._desState;
    var l = utils.readUInt32BE(inp, inOff);
    var r = utils.readUInt32BE(inp, inOff + 4); // Initial Permutation

    utils.ip(l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    if (this.type === "encrypt") this._encrypt(state, l, r, state.tmp, 0);else this._decrypt(state, l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    utils.writeUInt32BE(out, l, outOff);
    utils.writeUInt32BE(out, r, outOff + 4);
  };

  DES.prototype._pad = function _pad(buffer, off) {
    var value = buffer.length - off;

    for (var i = off; i < buffer.length; i++) buffer[i] = value;

    return true;
  };

  DES.prototype._unpad = function _unpad(buffer) {
    var pad = buffer[buffer.length - 1];

    for (var i = buffer.length - pad; i < buffer.length; i++) assert.equal(buffer[i], pad);

    return buffer.slice(0, buffer.length - pad);
  };

  DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
    var l = lStart;
    var r = rStart; // Apply f() x16 times

    for (var i = 0; i < state.keys.length; i += 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1]; // f(r, k)

      utils.expand(r, state.tmp, 0);
      keyL ^= state.tmp[0];
      keyR ^= state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var f = utils.permute(s);
      var t = r;
      r = (l ^ f) >>> 0;
      l = t;
    } // Reverse Initial Permutation


    utils.rip(r, l, out, off);
  };

  DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
    var l = rStart;
    var r = lStart; // Apply f() x16 times

    for (var i = state.keys.length - 2; i >= 0; i -= 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1]; // f(r, k)

      utils.expand(l, state.tmp, 0);
      keyL ^= state.tmp[0];
      keyR ^= state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var f = utils.permute(s);
      var t = l;
      l = (r ^ f) >>> 0;
      r = t;
    } // Reverse Initial Permutation


    utils.rip(l, r, out, off);
  };

  return exports$2l;
}

var exports$2k = {},
    _dewExec$2j = false;
function dew$2j() {
  if (_dewExec$2j) return exports$2k;
  _dewExec$2j = true;

  var assert = dew$2m();

  var inherits = dew$2R();

  var proto = {};

  function CBCState(iv) {
    assert.equal(iv.length, 8, "Invalid IV length");
    this.iv = new Array(8);

    for (var i = 0; i < this.iv.length; i++) this.iv[i] = iv[i];
  }

  function instantiate(Base) {
    function CBC(options) {
      Base.call(this, options);

      this._cbcInit();
    }

    inherits(CBC, Base);
    var keys = Object.keys(proto);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      CBC.prototype[key] = proto[key];
    }

    CBC.create = function create(options) {
      return new CBC(options);
    };

    return CBC;
  }

  exports$2k.instantiate = instantiate;

  proto._cbcInit = function _cbcInit() {
    var state = new CBCState(this.options.iv);
    this._cbcState = state;
  };

  proto._update = function _update(inp, inOff, out, outOff) {
    var state = this._cbcState;
    var superProto = this.constructor.super_.prototype;
    var iv = state.iv;

    if (this.type === "encrypt") {
      for (var i = 0; i < this.blockSize; i++) iv[i] ^= inp[inOff + i];

      superProto._update.call(this, iv, 0, out, outOff);

      for (var i = 0; i < this.blockSize; i++) iv[i] = out[outOff + i];
    } else {
      superProto._update.call(this, inp, inOff, out, outOff);

      for (var i = 0; i < this.blockSize; i++) out[outOff + i] ^= iv[i];

      for (var i = 0; i < this.blockSize; i++) iv[i] = inp[inOff + i];
    }
  };

  return exports$2k;
}

var exports$2j = {},
    _dewExec$2i = false;
function dew$2i() {
  if (_dewExec$2i) return exports$2j;
  _dewExec$2i = true;

  var assert = dew$2m();

  var inherits = dew$2R();

  var Cipher = dew$2l();

  var DES = dew$2k();

  function EDEState(type, key) {
    assert.equal(key.length, 24, "Invalid key length");
    var k1 = key.slice(0, 8);
    var k2 = key.slice(8, 16);
    var k3 = key.slice(16, 24);

    if (type === "encrypt") {
      this.ciphers = [DES.create({
        type: "encrypt",
        key: k1
      }), DES.create({
        type: "decrypt",
        key: k2
      }), DES.create({
        type: "encrypt",
        key: k3
      })];
    } else {
      this.ciphers = [DES.create({
        type: "decrypt",
        key: k3
      }), DES.create({
        type: "encrypt",
        key: k2
      }), DES.create({
        type: "decrypt",
        key: k1
      })];
    }
  }

  function EDE(options) {
    Cipher.call(this, options);
    var state = new EDEState(this.type, this.options.key);
    this._edeState = state;
  }

  inherits(EDE, Cipher);
  exports$2j = EDE;

  EDE.create = function create(options) {
    return new EDE(options);
  };

  EDE.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._edeState;

    state.ciphers[0]._update(inp, inOff, out, outOff);

    state.ciphers[1]._update(out, outOff, out, outOff);

    state.ciphers[2]._update(out, outOff, out, outOff);
  };

  EDE.prototype._pad = DES.prototype._pad;
  EDE.prototype._unpad = DES.prototype._unpad;
  return exports$2j;
}

var exports$2i = {},
    _dewExec$2h = false;
function dew$2h() {
  if (_dewExec$2h) return exports$2i;
  _dewExec$2h = true;
  exports$2i.utils = dew$2n();
  exports$2i.Cipher = dew$2l();
  exports$2i.DES = dew$2k();
  exports$2i.CBC = dew$2j();
  exports$2i.EDE = dew$2i();
  return exports$2i;
}

var exports$2h = {},
    _dewExec$2g = false;

var _global$G = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$2g() {
  if (_dewExec$2g) return exports$2h;
  _dewExec$2g = true;

  var CipherBase = dew$2z();

  var des = dew$2h();

  var inherits = dew$2R();

  var Buffer = dew$2P().Buffer;

  var modes = {
    "des-ede3-cbc": des.CBC.instantiate(des.EDE),
    "des-ede3": des.EDE,
    "des-ede-cbc": des.CBC.instantiate(des.EDE),
    "des-ede": des.EDE,
    "des-cbc": des.CBC.instantiate(des.DES),
    "des-ecb": des.DES
  };
  modes.des = modes["des-cbc"];
  modes.des3 = modes["des-ede3-cbc"];
  exports$2h = DES;
  inherits(DES, CipherBase);

  function DES(opts) {
    CipherBase.call(this || _global$G);
    var modeName = opts.mode.toLowerCase();
    var mode = modes[modeName];
    var type;

    if (opts.decrypt) {
      type = "decrypt";
    } else {
      type = "encrypt";
    }

    var key = opts.key;

    if (!Buffer.isBuffer(key)) {
      key = Buffer.from(key);
    }

    if (modeName === "des-ede" || modeName === "des-ede-cbc") {
      key = Buffer.concat([key, key.slice(0, 8)]);
    }

    var iv = opts.iv;

    if (!Buffer.isBuffer(iv)) {
      iv = Buffer.from(iv);
    }

    (this || _global$G)._des = mode.create({
      key: key,
      iv: iv,
      type: type
    });
  }

  DES.prototype._update = function (data) {
    return Buffer.from((this || _global$G)._des.update(data));
  };

  DES.prototype._final = function () {
    return Buffer.from((this || _global$G)._des.final());
  };

  return exports$2h;
}

var exports$2g = {},
    _dewExec$2f = false;
function dew$2f() {
  if (_dewExec$2f) return exports$2g;
  _dewExec$2f = true;

  exports$2g.encrypt = function (self, block) {
    return self._cipher.encryptBlock(block);
  };

  exports$2g.decrypt = function (self, block) {
    return self._cipher.decryptBlock(block);
  };

  return exports$2g;
}

var exports$2f = {},
    _dewExec$2e = false;
function dew$2e() {
  if (_dewExec$2e) return exports$2f;
  _dewExec$2e = true;
  var Buffer = buffer.Buffer;

  exports$2f = function xor(a, b) {
    var length = Math.min(a.length, b.length);
    var buffer = new Buffer(length);

    for (var i = 0; i < length; ++i) {
      buffer[i] = a[i] ^ b[i];
    }

    return buffer;
  };

  return exports$2f;
}

var exports$2e = {},
    _dewExec$2d = false;
function dew$2d() {
  if (_dewExec$2d) return exports$2e;
  _dewExec$2d = true;

  var xor = dew$2e();

  exports$2e.encrypt = function (self, block) {
    var data = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data);
    return self._prev;
  };

  exports$2e.decrypt = function (self, block) {
    var pad = self._prev;
    self._prev = block;

    var out = self._cipher.decryptBlock(block);

    return xor(out, pad);
  };

  return exports$2e;
}

var exports$2d = {},
    _dewExec$2c = false;
function dew$2c() {
  if (_dewExec$2c) return exports$2d;
  _dewExec$2c = true;

  var Buffer = dew$2P().Buffer;

  var xor = dew$2e();

  function encryptStart(self, data, decrypt) {
    var len = data.length;
    var out = xor(data, self._cache);
    self._cache = self._cache.slice(len);
    self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
    return out;
  }

  exports$2d.encrypt = function (self, data, decrypt) {
    var out = Buffer.allocUnsafe(0);
    var len;

    while (data.length) {
      if (self._cache.length === 0) {
        self._cache = self._cipher.encryptBlock(self._prev);
        self._prev = Buffer.allocUnsafe(0);
      }

      if (self._cache.length <= data.length) {
        len = self._cache.length;
        out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
        data = data.slice(len);
      } else {
        out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
        break;
      }
    }

    return out;
  };

  return exports$2d;
}

var exports$2c = {},
    _dewExec$2b = false;
function dew$2b() {
  if (_dewExec$2b) return exports$2c;
  _dewExec$2b = true;

  var Buffer = dew$2P().Buffer;

  function encryptByte(self, byteParam, decrypt) {
    var pad = self._cipher.encryptBlock(self._prev);

    var out = pad[0] ^ byteParam;
    self._prev = Buffer.concat([self._prev.slice(1), Buffer.from([decrypt ? byteParam : out])]);
    return out;
  }

  exports$2c.encrypt = function (self, chunk, decrypt) {
    var len = chunk.length;
    var out = Buffer.allocUnsafe(len);
    var i = -1;

    while (++i < len) {
      out[i] = encryptByte(self, chunk[i], decrypt);
    }

    return out;
  };

  return exports$2c;
}

var exports$2b = {},
    _dewExec$2a = false;
function dew$2a() {
  if (_dewExec$2a) return exports$2b;
  _dewExec$2a = true;

  var Buffer = dew$2P().Buffer;

  function encryptByte(self, byteParam, decrypt) {
    var pad;
    var i = -1;
    var len = 8;
    var out = 0;
    var bit, value;

    while (++i < len) {
      pad = self._cipher.encryptBlock(self._prev);
      bit = byteParam & 1 << 7 - i ? 128 : 0;
      value = pad[0] ^ bit;
      out += (value & 128) >> i % 8;
      self._prev = shiftIn(self._prev, decrypt ? bit : value);
    }

    return out;
  }

  function shiftIn(buffer, value) {
    var len = buffer.length;
    var i = -1;
    var out = Buffer.allocUnsafe(buffer.length);
    buffer = Buffer.concat([buffer, Buffer.from([value])]);

    while (++i < len) {
      out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
    }

    return out;
  }

  exports$2b.encrypt = function (self, chunk, decrypt) {
    var len = chunk.length;
    var out = Buffer.allocUnsafe(len);
    var i = -1;

    while (++i < len) {
      out[i] = encryptByte(self, chunk[i], decrypt);
    }

    return out;
  };

  return exports$2b;
}

var exports$2a = {},
    _dewExec$29 = false;
function dew$29() {
  if (_dewExec$29) return exports$2a;
  _dewExec$29 = true;
  var Buffer = buffer.Buffer;

  var xor = dew$2e();

  function getBlock(self) {
    self._prev = self._cipher.encryptBlock(self._prev);
    return self._prev;
  }

  exports$2a.encrypt = function (self, chunk) {
    while (self._cache.length < chunk.length) {
      self._cache = Buffer.concat([self._cache, getBlock(self)]);
    }

    var pad = self._cache.slice(0, chunk.length);

    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
  };

  return exports$2a;
}

var exports$29 = {},
    _dewExec$28 = false;
function dew$28() {
  if (_dewExec$28) return exports$29;
  _dewExec$28 = true;

  function incr32(iv) {
    var len = iv.length;
    var item;

    while (len--) {
      item = iv.readUInt8(len);

      if (item === 255) {
        iv.writeUInt8(0, len);
      } else {
        item++;
        iv.writeUInt8(item, len);
        break;
      }
    }
  }

  exports$29 = incr32;
  return exports$29;
}

var exports$28 = {},
    _dewExec$27 = false;
function dew$27() {
  if (_dewExec$27) return exports$28;
  _dewExec$27 = true;

  var xor = dew$2e();

  var Buffer = dew$2P().Buffer;

  var incr32 = dew$28();

  function getBlock(self) {
    var out = self._cipher.encryptBlockRaw(self._prev);

    incr32(self._prev);
    return out;
  }

  var blockSize = 16;

  exports$28.encrypt = function (self, chunk) {
    var chunkNum = Math.ceil(chunk.length / blockSize);
    var start = self._cache.length;
    self._cache = Buffer.concat([self._cache, Buffer.allocUnsafe(chunkNum * blockSize)]);

    for (var i = 0; i < chunkNum; i++) {
      var out = getBlock(self);
      var offset = start + i * blockSize;

      self._cache.writeUInt32BE(out[0], offset + 0);

      self._cache.writeUInt32BE(out[1], offset + 4);

      self._cache.writeUInt32BE(out[2], offset + 8);

      self._cache.writeUInt32BE(out[3], offset + 12);
    }

    var pad = self._cache.slice(0, chunk.length);

    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
  };

  return exports$28;
}

var _list$1 = {
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
};

var exports$27 = {},
    _dewExec$26 = false;
function dew$26() {
  if (_dewExec$26) return exports$27;
  _dewExec$26 = true;
  var modeModules = {
    ECB: dew$2f(),
    CBC: dew$2d(),
    CFB: dew$2c(),
    CFB8: dew$2b(),
    CFB1: dew$2a(),
    OFB: dew$29(),
    CTR: dew$27(),
    GCM: dew$27()
  };
  var modes = _list$1;

  for (var key in modes) {
    modes[key].module = modeModules[modes[key].mode];
  }

  exports$27 = modes;
  return exports$27;
}

var exports$26 = {},
    _dewExec$25 = false;

var _global$F = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$25() {
  if (_dewExec$25) return exports$26;
  _dewExec$25 = true;

  // based on the aes implimentation in triple sec
  // https://github.com/keybase/triplesec
  // which is in turn based on the one from crypto-js
  // https://code.google.com/p/crypto-js/
  var Buffer = dew$2P().Buffer;

  function asUInt32Array(buf) {
    if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);

    for (var i = 0; i < len; i++) {
      out[i] = buf.readUInt32BE(i * 4);
    }

    return out;
  }

  function scrubVec(v) {
    for (var i = 0; i < v.length; v++) {
      v[i] = 0;
    }
  }

  function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;

    for (var round = 1; round < nRounds; round++) {
      t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
      t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
      t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
      t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
      s0 = t0;
      s1 = t1;
      s2 = t2;
      s3 = t3;
    }

    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [t0, t1, t2, t3];
  } // AES constants


  var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];

  var G = function () {
    // Compute double table
    var d = new Array(256);

    for (var j = 0; j < 256; j++) {
      if (j < 128) {
        d[j] = j << 1;
      } else {
        d[j] = j << 1 ^ 283;
      }
    }

    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [[], [], [], []];
    var INV_SUB_MIX = [[], [], [], []]; // Walk GF(2^8)

    var x = 0;
    var xi = 0;

    for (var i = 0; i < 256; ++i) {
      // Compute sbox
      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 255 ^ 99;
      SBOX[x] = sx;
      INV_SBOX[sx] = x; // Compute multiplication

      var x2 = d[x];
      var x4 = d[x2];
      var x8 = d[x4]; // Compute sub bytes, mix columns tables

      var t = d[sx] * 257 ^ sx * 16843008;
      SUB_MIX[0][x] = t << 24 | t >>> 8;
      SUB_MIX[1][x] = t << 16 | t >>> 16;
      SUB_MIX[2][x] = t << 8 | t >>> 24;
      SUB_MIX[3][x] = t; // Compute inv sub bytes, inv mix columns tables

      t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
      INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
      INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
      INV_SUB_MIX[3][sx] = t;

      if (x === 0) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }

    return {
      SBOX: SBOX,
      INV_SBOX: INV_SBOX,
      SUB_MIX: SUB_MIX,
      INV_SUB_MIX: INV_SUB_MIX
    };
  }();

  function AES(key) {
    (this || _global$F)._key = asUInt32Array(key);

    this._reset();
  }

  AES.blockSize = 4 * 4;
  AES.keySize = 256 / 8;
  AES.prototype.blockSize = AES.blockSize;
  AES.prototype.keySize = AES.keySize;

  AES.prototype._reset = function () {
    var keyWords = (this || _global$F)._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];

    for (var k = 0; k < keySize; k++) {
      keySchedule[k] = keyWords[k];
    }

    for (k = keySize; k < ksRows; k++) {
      var t = keySchedule[k - 1];

      if (k % keySize === 0) {
        t = t << 8 | t >>> 24;
        t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
        t ^= RCON[k / keySize | 0] << 24;
      } else if (keySize > 6 && k % keySize === 4) {
        t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
      }

      keySchedule[k] = keySchedule[k - keySize] ^ t;
    }

    var invKeySchedule = [];

    for (var ik = 0; ik < ksRows; ik++) {
      var ksR = ksRows - ik;
      var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];

      if (ik < 4 || ksR <= 4) {
        invKeySchedule[ik] = tt;
      } else {
        invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
      }
    }

    (this || _global$F)._nRounds = nRounds;
    (this || _global$F)._keySchedule = keySchedule;
    (this || _global$F)._invKeySchedule = invKeySchedule;
  };

  AES.prototype.encryptBlockRaw = function (M) {
    M = asUInt32Array(M);
    return cryptBlock(M, (this || _global$F)._keySchedule, G.SUB_MIX, G.SBOX, (this || _global$F)._nRounds);
  };

  AES.prototype.encryptBlock = function (M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
  };

  AES.prototype.decryptBlock = function (M) {
    M = asUInt32Array(M); // swap

    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, (this || _global$F)._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, (this || _global$F)._nRounds);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
  };

  AES.prototype.scrub = function () {
    scrubVec((this || _global$F)._keySchedule);
    scrubVec((this || _global$F)._invKeySchedule);
    scrubVec((this || _global$F)._key);
  };

  exports$26.AES = AES;
  return exports$26;
}

var exports$25 = {},
    _dewExec$24 = false;

var _global$E = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$24() {
  if (_dewExec$24) return exports$25;
  _dewExec$24 = true;

  var Buffer = dew$2P().Buffer;

  var ZEROES = Buffer.alloc(16, 0);

  function toArray(buf) {
    return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
  }

  function fromArray(out) {
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
  }

  function GHASH(key) {
    (this || _global$E).h = key;
    (this || _global$E).state = Buffer.alloc(16, 0);
    (this || _global$E).cache = Buffer.allocUnsafe(0);
  } // from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
  // by Juho Vähä-Herttua


  GHASH.prototype.ghash = function (block) {
    var i = -1;

    while (++i < block.length) {
      (this || _global$E).state[i] ^= block[i];
    }

    this._multiply();
  };

  GHASH.prototype._multiply = function () {
    var Vi = toArray((this || _global$E).h);
    var Zi = [0, 0, 0, 0];
    var j, xi, lsbVi;
    var i = -1;

    while (++i < 128) {
      xi = ((this || _global$E).state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;

      if (xi) {
        // Z_i+1 = Z_i ^ V_i
        Zi[0] ^= Vi[0];
        Zi[1] ^= Vi[1];
        Zi[2] ^= Vi[2];
        Zi[3] ^= Vi[3];
      } // Store the value of LSB(V_i)


      lsbVi = (Vi[3] & 1) !== 0; // V_i+1 = V_i >> 1

      for (j = 3; j > 0; j--) {
        Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
      }

      Vi[0] = Vi[0] >>> 1; // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R

      if (lsbVi) {
        Vi[0] = Vi[0] ^ 225 << 24;
      }
    }

    (this || _global$E).state = fromArray(Zi);
  };

  GHASH.prototype.update = function (buf) {
    (this || _global$E).cache = Buffer.concat([(this || _global$E).cache, buf]);
    var chunk;

    while ((this || _global$E).cache.length >= 16) {
      chunk = (this || _global$E).cache.slice(0, 16);
      (this || _global$E).cache = (this || _global$E).cache.slice(16);
      this.ghash(chunk);
    }
  };

  GHASH.prototype.final = function (abl, bl) {
    if ((this || _global$E).cache.length) {
      this.ghash(Buffer.concat([(this || _global$E).cache, ZEROES], 16));
    }

    this.ghash(fromArray([0, abl, 0, bl]));
    return (this || _global$E).state;
  };

  exports$25 = GHASH;
  return exports$25;
}

var exports$24 = {},
    _dewExec$23 = false;

var _global$D = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$23() {
  if (_dewExec$23) return exports$24;
  _dewExec$23 = true;

  var aes = dew$25();

  var Buffer = dew$2P().Buffer;

  var Transform = dew$2z();

  var inherits = dew$2R();

  var GHASH = dew$24();

  var xor = dew$2e();

  var incr32 = dew$28();

  function xorTest(a, b) {
    var out = 0;
    if (a.length !== b.length) out++;
    var len = Math.min(a.length, b.length);

    for (var i = 0; i < len; ++i) {
      out += a[i] ^ b[i];
    }

    return out;
  }

  function calcIv(self, iv, ck) {
    if (iv.length === 12) {
      self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
      return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
    }

    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);

    if (toPad) {
      toPad = 16 - toPad;
      ghash.update(Buffer.alloc(toPad, 0));
    }

    ghash.update(Buffer.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer.alloc(8);
    tail.writeUIntBE(ivBits, 0, 8);
    ghash.update(tail);
    self._finID = ghash.state;
    var out = Buffer.from(self._finID);
    incr32(out);
    return out;
  }

  function StreamCipher(mode, key, iv, decrypt) {
    Transform.call(this || _global$D);
    var h = Buffer.alloc(4, 0);
    (this || _global$D)._cipher = new aes.AES(key);

    var ck = (this || _global$D)._cipher.encryptBlock(h);

    (this || _global$D)._ghash = new GHASH(ck);
    iv = calcIv(this || _global$D, iv, ck);
    (this || _global$D)._prev = Buffer.from(iv);
    (this || _global$D)._cache = Buffer.allocUnsafe(0);
    (this || _global$D)._secCache = Buffer.allocUnsafe(0);
    (this || _global$D)._decrypt = decrypt;
    (this || _global$D)._alen = 0;
    (this || _global$D)._len = 0;
    (this || _global$D)._mode = mode;
    (this || _global$D)._authTag = null;
    (this || _global$D)._called = false;
  }

  inherits(StreamCipher, Transform);

  StreamCipher.prototype._update = function (chunk) {
    if (!(this || _global$D)._called && (this || _global$D)._alen) {
      var rump = 16 - (this || _global$D)._alen % 16;

      if (rump < 16) {
        rump = Buffer.alloc(rump, 0);

        (this || _global$D)._ghash.update(rump);
      }
    }

    (this || _global$D)._called = true;

    var out = (this || _global$D)._mode.encrypt(this || _global$D, chunk);

    if ((this || _global$D)._decrypt) {
      (this || _global$D)._ghash.update(chunk);
    } else {
      (this || _global$D)._ghash.update(out);
    }

    (this || _global$D)._len += chunk.length;
    return out;
  };

  StreamCipher.prototype._final = function () {
    if ((this || _global$D)._decrypt && !(this || _global$D)._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var tag = xor((this || _global$D)._ghash.final((this || _global$D)._alen * 8, (this || _global$D)._len * 8), (this || _global$D)._cipher.encryptBlock((this || _global$D)._finID));
    if ((this || _global$D)._decrypt && xorTest(tag, (this || _global$D)._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    (this || _global$D)._authTag = tag;

    (this || _global$D)._cipher.scrub();
  };

  StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if ((this || _global$D)._decrypt || !Buffer.isBuffer((this || _global$D)._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return (this || _global$D)._authTag;
  };

  StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!(this || _global$D)._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    (this || _global$D)._authTag = tag;
  };

  StreamCipher.prototype.setAAD = function setAAD(buf) {
    if ((this || _global$D)._called) throw new Error("Attempting to set AAD in unsupported state");

    (this || _global$D)._ghash.update(buf);

    (this || _global$D)._alen += buf.length;
  };

  exports$24 = StreamCipher;
  return exports$24;
}

var exports$23 = {},
    _dewExec$22 = false;

var _global$C = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$22() {
  if (_dewExec$22) return exports$23;
  _dewExec$22 = true;

  var aes = dew$25();

  var Buffer = dew$2P().Buffer;

  var Transform = dew$2z();

  var inherits = dew$2R();

  function StreamCipher(mode, key, iv, decrypt) {
    Transform.call(this || _global$C);
    (this || _global$C)._cipher = new aes.AES(key);
    (this || _global$C)._prev = Buffer.from(iv);
    (this || _global$C)._cache = Buffer.allocUnsafe(0);
    (this || _global$C)._secCache = Buffer.allocUnsafe(0);
    (this || _global$C)._decrypt = decrypt;
    (this || _global$C)._mode = mode;
  }

  inherits(StreamCipher, Transform);

  StreamCipher.prototype._update = function (chunk) {
    return (this || _global$C)._mode.encrypt(this || _global$C, chunk, (this || _global$C)._decrypt);
  };

  StreamCipher.prototype._final = function () {
    (this || _global$C)._cipher.scrub();
  };

  exports$23 = StreamCipher;
  return exports$23;
}

var exports$22 = {},
    _dewExec$21 = false;
function dew$21() {
  if (_dewExec$21) return exports$22;
  _dewExec$21 = true;

  var Buffer = dew$2P().Buffer;

  var MD5 = dew$2L();
  /* eslint-disable camelcase */


  function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer.isBuffer(password)) password = Buffer.from(password, "binary");

    if (salt) {
      if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, "binary");
      if (salt.length !== 8) throw new RangeError("salt should be Buffer with 8 byte length");
    }

    var keyLen = keyBits / 8;
    var key = Buffer.alloc(keyLen);
    var iv = Buffer.alloc(ivLen || 0);
    var tmp = Buffer.alloc(0);

    while (keyLen > 0 || ivLen > 0) {
      var hash = new MD5();
      hash.update(tmp);
      hash.update(password);
      if (salt) hash.update(salt);
      tmp = hash.digest();
      var used = 0;

      if (keyLen > 0) {
        var keyStart = key.length - keyLen;
        used = Math.min(keyLen, tmp.length);
        tmp.copy(key, keyStart, 0, used);
        keyLen -= used;
      }

      if (used < tmp.length && ivLen > 0) {
        var ivStart = iv.length - ivLen;
        var length = Math.min(ivLen, tmp.length - used);
        tmp.copy(iv, ivStart, used, used + length);
        ivLen -= length;
      }
    }

    tmp.fill(0);
    return {
      key: key,
      iv: iv
    };
  }

  exports$22 = EVP_BytesToKey;
  return exports$22;
}

var exports$21 = {},
    _dewExec$20 = false;

var _global$B = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$20() {
  if (_dewExec$20) return exports$21;
  _dewExec$20 = true;

  var MODES = dew$26();

  var AuthCipher = dew$23();

  var Buffer = dew$2P().Buffer;

  var StreamCipher = dew$22();

  var Transform = dew$2z();

  var aes = dew$25();

  var ebtk = dew$21();

  var inherits = dew$2R();

  function Cipher(mode, key, iv) {
    Transform.call(this || _global$B);
    (this || _global$B)._cache = new Splitter();
    (this || _global$B)._cipher = new aes.AES(key);
    (this || _global$B)._prev = Buffer.from(iv);
    (this || _global$B)._mode = mode;
    (this || _global$B)._autopadding = true;
  }

  inherits(Cipher, Transform);

  Cipher.prototype._update = function (data) {
    (this || _global$B)._cache.add(data);

    var chunk;
    var thing;
    var out = [];

    while (chunk = (this || _global$B)._cache.get()) {
      thing = (this || _global$B)._mode.encrypt(this || _global$B, chunk);
      out.push(thing);
    }

    return Buffer.concat(out);
  };

  var PADDING = Buffer.alloc(16, 16);

  Cipher.prototype._final = function () {
    var chunk = (this || _global$B)._cache.flush();

    if ((this || _global$B)._autopadding) {
      chunk = (this || _global$B)._mode.encrypt(this || _global$B, chunk);

      (this || _global$B)._cipher.scrub();

      return chunk;
    }

    if (!chunk.equals(PADDING)) {
      (this || _global$B)._cipher.scrub();

      throw new Error("data not multiple of block length");
    }
  };

  Cipher.prototype.setAutoPadding = function (setTo) {
    (this || _global$B)._autopadding = !!setTo;
    return this || _global$B;
  };

  function Splitter() {
    (this || _global$B).cache = Buffer.allocUnsafe(0);
  }

  Splitter.prototype.add = function (data) {
    (this || _global$B).cache = Buffer.concat([(this || _global$B).cache, data]);
  };

  Splitter.prototype.get = function () {
    if ((this || _global$B).cache.length > 15) {
      var out = (this || _global$B).cache.slice(0, 16);

      (this || _global$B).cache = (this || _global$B).cache.slice(16);
      return out;
    }

    return null;
  };

  Splitter.prototype.flush = function () {
    var len = 16 - (this || _global$B).cache.length;
    var padBuff = Buffer.allocUnsafe(len);
    var i = -1;

    while (++i < len) {
      padBuff.writeUInt8(len, i);
    }

    return Buffer.concat([(this || _global$B).cache, padBuff]);
  };

  function createCipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);

    if (config.type === "stream") {
      return new StreamCipher(config.module, password, iv);
    } else if (config.type === "auth") {
      return new AuthCipher(config.module, password, iv);
    }

    return new Cipher(config.module, password, iv);
  }

  function createCipher(suite, password) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    var keys = ebtk(password, false, config.key, config.iv);
    return createCipheriv(suite, keys.key, keys.iv);
  }

  exports$21.createCipheriv = createCipheriv;
  exports$21.createCipher = createCipher;
  return exports$21;
}

var exports$20 = {},
    _dewExec$1$ = false;

var _global$A = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1$() {
  if (_dewExec$1$) return exports$20;
  _dewExec$1$ = true;

  var AuthCipher = dew$23();

  var Buffer = dew$2P().Buffer;

  var MODES = dew$26();

  var StreamCipher = dew$22();

  var Transform = dew$2z();

  var aes = dew$25();

  var ebtk = dew$21();

  var inherits = dew$2R();

  function Decipher(mode, key, iv) {
    Transform.call(this || _global$A);
    (this || _global$A)._cache = new Splitter();
    (this || _global$A)._last = void 0;
    (this || _global$A)._cipher = new aes.AES(key);
    (this || _global$A)._prev = Buffer.from(iv);
    (this || _global$A)._mode = mode;
    (this || _global$A)._autopadding = true;
  }

  inherits(Decipher, Transform);

  Decipher.prototype._update = function (data) {
    (this || _global$A)._cache.add(data);

    var chunk;
    var thing;
    var out = [];

    while (chunk = (this || _global$A)._cache.get((this || _global$A)._autopadding)) {
      thing = (this || _global$A)._mode.decrypt(this || _global$A, chunk);
      out.push(thing);
    }

    return Buffer.concat(out);
  };

  Decipher.prototype._final = function () {
    var chunk = (this || _global$A)._cache.flush();

    if ((this || _global$A)._autopadding) {
      return unpad((this || _global$A)._mode.decrypt(this || _global$A, chunk));
    } else if (chunk) {
      throw new Error("data not multiple of block length");
    }
  };

  Decipher.prototype.setAutoPadding = function (setTo) {
    (this || _global$A)._autopadding = !!setTo;
    return this || _global$A;
  };

  function Splitter() {
    (this || _global$A).cache = Buffer.allocUnsafe(0);
  }

  Splitter.prototype.add = function (data) {
    (this || _global$A).cache = Buffer.concat([(this || _global$A).cache, data]);
  };

  Splitter.prototype.get = function (autoPadding) {
    var out;

    if (autoPadding) {
      if ((this || _global$A).cache.length > 16) {
        out = (this || _global$A).cache.slice(0, 16);
        (this || _global$A).cache = (this || _global$A).cache.slice(16);
        return out;
      }
    } else {
      if ((this || _global$A).cache.length >= 16) {
        out = (this || _global$A).cache.slice(0, 16);
        (this || _global$A).cache = (this || _global$A).cache.slice(16);
        return out;
      }
    }

    return null;
  };

  Splitter.prototype.flush = function () {
    if ((this || _global$A).cache.length) return (this || _global$A).cache;
  };

  function unpad(last) {
    var padded = last[15];

    if (padded < 1 || padded > 16) {
      throw new Error("unable to decrypt data");
    }

    var i = -1;

    while (++i < padded) {
      if (last[i + (16 - padded)] !== padded) {
        throw new Error("unable to decrypt data");
      }
    }

    if (padded === 16) return;
    return last.slice(0, 16 - padded);
  }

  function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);

    if (config.type === "stream") {
      return new StreamCipher(config.module, password, iv, true);
    } else if (config.type === "auth") {
      return new AuthCipher(config.module, password, iv, true);
    }

    return new Decipher(config.module, password, iv);
  }

  function createDecipher(suite, password) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    var keys = ebtk(password, false, config.key, config.iv);
    return createDecipheriv(suite, keys.key, keys.iv);
  }

  exports$20.createDecipher = createDecipher;
  exports$20.createDecipheriv = createDecipheriv;
  return exports$20;
}

var exports$1$ = {},
    _dewExec$1_ = false;
function dew$1_() {
  if (_dewExec$1_) return exports$1$;
  _dewExec$1_ = true;

  var ciphers = dew$20();

  var deciphers = dew$1$();

  var modes = _list$1;

  function getCiphers() {
    return Object.keys(modes);
  }

  exports$1$.createCipher = exports$1$.Cipher = ciphers.createCipher;
  exports$1$.createCipheriv = exports$1$.Cipheriv = ciphers.createCipheriv;
  exports$1$.createDecipher = exports$1$.Decipher = deciphers.createDecipher;
  exports$1$.createDecipheriv = exports$1$.Decipheriv = deciphers.createDecipheriv;
  exports$1$.listCiphers = exports$1$.getCiphers = getCiphers;
  return exports$1$;
}

var exports$1_ = {},
    _dewExec$1Z = false;
function dew$1Z() {
  if (_dewExec$1Z) return exports$1_;
  _dewExec$1Z = true;
  exports$1_["des-ecb"] = {
    key: 8,
    iv: 0
  };
  exports$1_["des-cbc"] = exports$1_.des = {
    key: 8,
    iv: 8
  };
  exports$1_["des-ede3-cbc"] = exports$1_.des3 = {
    key: 24,
    iv: 8
  };
  exports$1_["des-ede3"] = {
    key: 24,
    iv: 0
  };
  exports$1_["des-ede-cbc"] = {
    key: 16,
    iv: 8
  };
  exports$1_["des-ede"] = {
    key: 16,
    iv: 0
  };
  return exports$1_;
}

var exports$1Z = {},
    _dewExec$1Y = false;
function dew$1Y() {
  if (_dewExec$1Y) return exports$1Z;
  _dewExec$1Y = true;

  var DES = dew$2g();

  var aes = dew$1_();

  var aesModes = dew$26();

  var desModes = dew$1Z();

  var ebtk = dew$21();

  function createCipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;

    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError("invalid suite type");
    }

    var keys = ebtk(password, false, keyLen, ivLen);
    return createCipheriv(suite, keys.key, keys.iv);
  }

  function createDecipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;

    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError("invalid suite type");
    }

    var keys = ebtk(password, false, keyLen, ivLen);
    return createDecipheriv(suite, keys.key, keys.iv);
  }

  function createCipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
    if (desModes[suite]) return new DES({
      key: key,
      iv: iv,
      mode: suite
    });
    throw new TypeError("invalid suite type");
  }

  function createDecipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
    if (desModes[suite]) return new DES({
      key: key,
      iv: iv,
      mode: suite,
      decrypt: true
    });
    throw new TypeError("invalid suite type");
  }

  function getCiphers() {
    return Object.keys(desModes).concat(aes.getCiphers());
  }

  exports$1Z.createCipher = exports$1Z.Cipher = createCipher;
  exports$1Z.createCipheriv = exports$1Z.Cipheriv = createCipheriv;
  exports$1Z.createDecipher = exports$1Z.Decipher = createDecipher;
  exports$1Z.createDecipheriv = exports$1Z.Decipheriv = createDecipheriv;
  exports$1Z.listCiphers = exports$1Z.getCiphers = getCiphers;
  return exports$1Z;
}

var exports$1Y = {},
    _dewExec$1X = false;
var module$a = {
  exports: exports$1Y
};

var _global$z = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1X() {
  if (_dewExec$1X) return module$a.exports;
  _dewExec$1X = true;

  (function (module, exports) {

    function assert(val, msg) {
      if (!val) throw new Error(msg || "Assertion failed");
    } // Could use `inherits` module, but don't want to move from single file
    // architecture yet.


    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    } // BN


    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }

      (this || _global$z).negative = 0;
      (this || _global$z).words = null;
      (this || _global$z).length = 0; // Reduction context

      (this || _global$z).red = null;

      if (number !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }

        this._init(number || 0, base || 10, endian || "be");
      }
    }

    if (typeof module === "object") {
      module.exports = BN;
    } else {
      exports.BN = BN;
    }

    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;

    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer = window.Buffer;
      } else {
        Buffer = buffer.Buffer;
      }
    } catch (e) {}

    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }

      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };

    BN.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };

    BN.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };

    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base, endian);
      }

      if (typeof number === "object") {
        return this._initArray(number, base, endian);
      }

      if (base === "hex") {
        base = 16;
      }

      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;

      if (number[0] === "-") {
        start++;
        (this || _global$z).negative = 1;
      }

      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);

          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };

    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        (this || _global$z).negative = 1;
        number = -number;
      }

      if (number < 67108864) {
        (this || _global$z).words = [number & 67108863];
        (this || _global$z).length = 1;
      } else if (number < 4503599627370496) {
        (this || _global$z).words = [number & 67108863, number / 67108864 & 67108863];
        (this || _global$z).length = 2;
      } else {
        assert(number < 9007199254740992); // 2 ^ 53 (unsafe)

        (this || _global$z).words = [number & 67108863, number / 67108864 & 67108863, 1];
        (this || _global$z).length = 3;
      }

      if (endian !== "le") return; // Reverse the bytes

      this._initArray(this.toArray(), base, endian);
    };

    BN.prototype._initArray = function _initArray(number, base, endian) {
      // Perhaps a Uint8Array
      assert(typeof number.length === "number");

      if (number.length <= 0) {
        (this || _global$z).words = [0];
        (this || _global$z).length = 1;
        return this || _global$z;
      }

      (this || _global$z).length = Math.ceil(number.length / 3);
      (this || _global$z).words = new Array((this || _global$z).length);

      for (var i = 0; i < (this || _global$z).length; i++) {
        (this || _global$z).words[i] = 0;
      }

      var j, w;
      var off = 0;

      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          (this || _global$z).words[j] |= w << off & 67108863;
          (this || _global$z).words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          (this || _global$z).words[j] |= w << off & 67108863;
          (this || _global$z).words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }

      return this.strip();
    };

    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index); // 'A' - 'F'

      if (c >= 65 && c <= 70) {
        return c - 55; // 'a' - 'f'
      } else if (c >= 97 && c <= 102) {
        return c - 87; // '0' - '9'
      } else {
        return c - 48 & 15;
      }
    }

    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);

      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }

      return r;
    }

    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      // Create possibly bigger array to ensure that it fits the number
      (this || _global$z).length = Math.ceil((number.length - start) / 6);
      (this || _global$z).words = new Array((this || _global$z).length);

      for (var i = 0; i < (this || _global$z).length; i++) {
        (this || _global$z).words[i] = 0;
      } // 24-bits chunks


      var off = 0;
      var j = 0;
      var w;

      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          (this || _global$z).words[j] |= w & 67108863;

          if (off >= 18) {
            off -= 18;
            j += 1;
            (this || _global$z).words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;

        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          (this || _global$z).words[j] |= w & 67108863;

          if (off >= 18) {
            off -= 18;
            j += 1;
            (this || _global$z).words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }

      this.strip();
    };

    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);

      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul; // 'a'

        if (c >= 49) {
          r += c - 49 + 10; // 'A'
        } else if (c >= 17) {
          r += c - 17 + 10; // '0' - '9'
        } else {
          r += c;
        }
      }

      return r;
    }

    BN.prototype._parseBase = function _parseBase(number, base, start) {
      // Initialize as zero
      (this || _global$z).words = [0];
      (this || _global$z).length = 1; // Find length of limb in base

      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }

      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;

      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);

        if ((this || _global$z).words[0] + word < 67108864) {
          (this || _global$z).words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);

        for (i = 0; i < mod; i++) {
          pow *= base;
        }

        this.imuln(pow);

        if ((this || _global$z).words[0] + word < 67108864) {
          (this || _global$z).words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      this.strip();
    };

    BN.prototype.copy = function copy(dest) {
      dest.words = new Array((this || _global$z).length);

      for (var i = 0; i < (this || _global$z).length; i++) {
        dest.words[i] = (this || _global$z).words[i];
      }

      dest.length = (this || _global$z).length;
      dest.negative = (this || _global$z).negative;
      dest.red = (this || _global$z).red;
    };

    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };

    BN.prototype._expand = function _expand(size) {
      while ((this || _global$z).length < size) {
        (this || _global$z).words[(this || _global$z).length++] = 0;
      }

      return this || _global$z;
    }; // Remove leading `0` from `this`


    BN.prototype.strip = function strip() {
      while ((this || _global$z).length > 1 && (this || _global$z).words[(this || _global$z).length - 1] === 0) {
        (this || _global$z).length--;
      }

      return this._normSign();
    };

    BN.prototype._normSign = function _normSign() {
      // -0 = 0
      if ((this || _global$z).length === 1 && (this || _global$z).words[0] === 0) {
        (this || _global$z).negative = 0;
      }

      return this || _global$z;
    };

    BN.prototype.inspect = function inspect() {
      return ((this || _global$z).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*
     var zeros = [];
    var groupSizes = [];
    var groupBases = [];
     var s = '';
    var i = -1;
    while (++i < BN.wordSize) {
      zeros[i] = s;
      s += '0';
    }
    groupSizes[0] = 0;
    groupSizes[1] = 0;
    groupBases[0] = 0;
    groupBases[1] = 0;
    var base = 2 - 1;
    while (++base < 36 + 1) {
      var groupSize = 0;
      var groupBase = 1;
      while (groupBase < (1 << BN.wordSize) / base) {
        groupBase *= base;
        groupSize += 1;
      }
      groupSizes[base] = groupSize;
      groupBases[base] = groupBase;
    }
     */


    var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;

      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;

        for (var i = 0; i < (this || _global$z).length; i++) {
          var w = (this || _global$z).words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;

          if (carry !== 0 || i !== (this || _global$z).length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }

          off += 2;

          if (off >= 26) {
            off -= 26;
            i--;
          }
        }

        if (carry !== 0) {
          out = carry.toString(16) + out;
        }

        while (out.length % padding !== 0) {
          out = "0" + out;
        }

        if ((this || _global$z).negative !== 0) {
          out = "-" + out;
        }

        return out;
      }

      if (base === (base | 0) && base >= 2 && base <= 36) {
        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
        var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;

        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);

          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }

        if (this.isZero()) {
          out = "0" + out;
        }

        while (out.length % padding !== 0) {
          out = "0" + out;
        }

        if ((this || _global$z).negative !== 0) {
          out = "-" + out;
        }

        return out;
      }

      assert(false, "Base should be between 2 and 36");
    };

    BN.prototype.toNumber = function toNumber() {
      var ret = (this || _global$z).words[0];

      if ((this || _global$z).length === 2) {
        ret += (this || _global$z).words[1] * 67108864;
      } else if ((this || _global$z).length === 3 && (this || _global$z).words[2] === 1) {
        // NOTE: at this stage it is known that the top bit is set
        ret += 4503599627370496 + (this || _global$z).words[1] * 67108864;
      } else if ((this || _global$z).length > 2) {
        assert(false, "Number can only safely store up to 53 bits");
      }

      return (this || _global$z).negative !== 0 ? -ret : ret;
    };

    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };

    BN.prototype.toBuffer = function toBuffer(endian, length) {
      assert(typeof Buffer !== "undefined");
      return this.toArrayLike(Buffer, endian, length);
    };

    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };

    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, "byte array longer than desired length");
      assert(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b, i;
      var q = this.clone();

      if (!littleEndian) {
        // Assume big-endian
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }

        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[i] = b;
        }

        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }

      return res;
    };

    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;

        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }

        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }

        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }

        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }

        return r + t;
      };
    }

    BN.prototype._zeroBits = function _zeroBits(w) {
      // Short-cut
      if (w === 0) return 26;
      var t = w;
      var r = 0;

      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }

      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }

      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }

      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }

      if ((t & 1) === 0) {
        r++;
      }

      return r;
    }; // Return number of used bits in a BN


    BN.prototype.bitLength = function bitLength() {
      var w = (this || _global$z).words[(this || _global$z).length - 1];

      var hi = this._countBits(w);

      return ((this || _global$z).length - 1) * 26 + hi;
    };

    function toBitArray(num) {
      var w = new Array(num.bitLength());

      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }

      return w;
    } // Number of trailing zero bits


    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r = 0;

      for (var i = 0; i < (this || _global$z).length; i++) {
        var b = this._zeroBits((this || _global$z).words[i]);

        r += b;
        if (b !== 26) break;
      }

      return r;
    };

    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };

    BN.prototype.toTwos = function toTwos(width) {
      if ((this || _global$z).negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }

      return this.clone();
    };

    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }

      return this.clone();
    };

    BN.prototype.isNeg = function isNeg() {
      return (this || _global$z).negative !== 0;
    }; // Return negative clone of `this`


    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };

    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        (this || _global$z).negative ^= 1;
      }

      return this || _global$z;
    }; // Or `num` with `this` in-place


    BN.prototype.iuor = function iuor(num) {
      while ((this || _global$z).length < num.length) {
        (this || _global$z).words[(this || _global$z).length++] = 0;
      }

      for (var i = 0; i < num.length; i++) {
        (this || _global$z).words[i] = (this || _global$z).words[i] | num.words[i];
      }

      return this.strip();
    };

    BN.prototype.ior = function ior(num) {
      assert(((this || _global$z).negative | num.negative) === 0);
      return this.iuor(num);
    }; // Or `num` with `this`


    BN.prototype.or = function or(num) {
      if ((this || _global$z).length > num.length) return this.clone().ior(num);
      return num.clone().ior(this || _global$z);
    };

    BN.prototype.uor = function uor(num) {
      if ((this || _global$z).length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this || _global$z);
    }; // And `num` with `this` in-place


    BN.prototype.iuand = function iuand(num) {
      // b = min-length(num, this)
      var b;

      if ((this || _global$z).length > num.length) {
        b = num;
      } else {
        b = this || _global$z;
      }

      for (var i = 0; i < b.length; i++) {
        (this || _global$z).words[i] = (this || _global$z).words[i] & num.words[i];
      }

      (this || _global$z).length = b.length;
      return this.strip();
    };

    BN.prototype.iand = function iand(num) {
      assert(((this || _global$z).negative | num.negative) === 0);
      return this.iuand(num);
    }; // And `num` with `this`


    BN.prototype.and = function and(num) {
      if ((this || _global$z).length > num.length) return this.clone().iand(num);
      return num.clone().iand(this || _global$z);
    };

    BN.prototype.uand = function uand(num) {
      if ((this || _global$z).length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this || _global$z);
    }; // Xor `num` with `this` in-place


    BN.prototype.iuxor = function iuxor(num) {
      // a.length > b.length
      var a;
      var b;

      if ((this || _global$z).length > num.length) {
        a = this || _global$z;
        b = num;
      } else {
        a = num;
        b = this || _global$z;
      }

      for (var i = 0; i < b.length; i++) {
        (this || _global$z).words[i] = a.words[i] ^ b.words[i];
      }

      if ((this || _global$z) !== a) {
        for (; i < a.length; i++) {
          (this || _global$z).words[i] = a.words[i];
        }
      }

      (this || _global$z).length = a.length;
      return this.strip();
    };

    BN.prototype.ixor = function ixor(num) {
      assert(((this || _global$z).negative | num.negative) === 0);
      return this.iuxor(num);
    }; // Xor `num` with `this`


    BN.prototype.xor = function xor(num) {
      if ((this || _global$z).length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this || _global$z);
    };

    BN.prototype.uxor = function uxor(num) {
      if ((this || _global$z).length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this || _global$z);
    }; // Not ``this`` with ``width`` bitwidth


    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26; // Extend the buffer with leading zeroes

      this._expand(bytesNeeded);

      if (bitsLeft > 0) {
        bytesNeeded--;
      } // Handle complete words


      for (var i = 0; i < bytesNeeded; i++) {
        (this || _global$z).words[i] = ~(this || _global$z).words[i] & 67108863;
      } // Handle the residue


      if (bitsLeft > 0) {
        (this || _global$z).words[i] = ~(this || _global$z).words[i] & 67108863 >> 26 - bitsLeft;
      } // And remove leading zeroes


      return this.strip();
    };

    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    }; // Set `bit` of `this`


    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;

      this._expand(off + 1);

      if (val) {
        (this || _global$z).words[off] = (this || _global$z).words[off] | 1 << wbit;
      } else {
        (this || _global$z).words[off] = (this || _global$z).words[off] & ~(1 << wbit);
      }

      return this.strip();
    }; // Add `num` to `this` in-place


    BN.prototype.iadd = function iadd(num) {
      var r; // negative + positive

      if ((this || _global$z).negative !== 0 && num.negative === 0) {
        (this || _global$z).negative = 0;
        r = this.isub(num);
        (this || _global$z).negative ^= 1;
        return this._normSign(); // positive + negative
      } else if ((this || _global$z).negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      } // a.length > b.length


      var a, b;

      if ((this || _global$z).length > num.length) {
        a = this || _global$z;
        b = num;
      } else {
        a = num;
        b = this || _global$z;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        (this || _global$z).words[i] = r & 67108863;
        carry = r >>> 26;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        (this || _global$z).words[i] = r & 67108863;
        carry = r >>> 26;
      }

      (this || _global$z).length = a.length;

      if (carry !== 0) {
        (this || _global$z).words[(this || _global$z).length] = carry;
        (this || _global$z).length++; // Copy the rest of the words
      } else if (a !== (this || _global$z)) {
        for (; i < a.length; i++) {
          (this || _global$z).words[i] = a.words[i];
        }
      }

      return this || _global$z;
    }; // Add `num` to `this`


    BN.prototype.add = function add(num) {
      var res;

      if (num.negative !== 0 && (this || _global$z).negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && (this || _global$z).negative !== 0) {
        (this || _global$z).negative = 0;
        res = num.sub(this || _global$z);
        (this || _global$z).negative = 1;
        return res;
      }

      if ((this || _global$z).length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this || _global$z);
    }; // Subtract `num` from `this` in-place


    BN.prototype.isub = function isub(num) {
      // this - (-num) = this + num
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign(); // -this - num = -(this + num)
      } else if ((this || _global$z).negative !== 0) {
        (this || _global$z).negative = 0;
        this.iadd(num);
        (this || _global$z).negative = 1;
        return this._normSign();
      } // At this point both numbers are positive


      var cmp = this.cmp(num); // Optimization - zeroify

      if (cmp === 0) {
        (this || _global$z).negative = 0;
        (this || _global$z).length = 1;
        (this || _global$z).words[0] = 0;
        return this || _global$z;
      } // a > b


      var a, b;

      if (cmp > 0) {
        a = this || _global$z;
        b = num;
      } else {
        a = num;
        b = this || _global$z;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        (this || _global$z).words[i] = r & 67108863;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        (this || _global$z).words[i] = r & 67108863;
      } // Copy rest of the words


      if (carry === 0 && i < a.length && a !== (this || _global$z)) {
        for (; i < a.length; i++) {
          (this || _global$z).words[i] = a.words[i];
        }
      }

      (this || _global$z).length = Math.max((this || _global$z).length, i);

      if (a !== (this || _global$z)) {
        (this || _global$z).negative = 1;
      }

      return this.strip();
    }; // Subtract `num` from `this`


    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };

    function smallMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      var len = self.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

      var a = self.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;

      for (var k = 1; k < len; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }

        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }

      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }

      return out.strip();
    } // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).


    var comb10MulTo = function comb10MulTo(self, num, out) {
      var a = self.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self.negative ^ num.negative;
      out.length = 19;
      /* k = 0 */

      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      /* k = 1 */

      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      /* k = 2 */

      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      /* k = 3 */

      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      /* k = 4 */

      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      /* k = 5 */

      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      /* k = 6 */

      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      /* k = 7 */

      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      /* k = 8 */

      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      /* k = 9 */

      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      /* k = 10 */

      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      /* k = 11 */

      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      /* k = 12 */

      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      /* k = 13 */

      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      /* k = 14 */

      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      /* k = 15 */

      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      /* k = 16 */

      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      /* k = 17 */

      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      /* k = 18 */

      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;

      if (c !== 0) {
        o[19] = c;
        out.length++;
      }

      return out;
    }; // Polyfill comb


    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }

    function bigMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      out.length = self.length + num.length;
      var carry = 0;
      var hncarry = 0;

      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }

        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }

      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }

      return out.strip();
    }

    function jumboMulTo(self, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self, num, out);
    }

    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = (this || _global$z).length + num.length;

      if ((this || _global$z).length === 10 && num.length === 10) {
        res = comb10MulTo(this || _global$z, num, out);
      } else if (len < 63) {
        res = smallMulTo(this || _global$z, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this || _global$z, num, out);
      } else {
        res = jumboMulTo(this || _global$z, num, out);
      }

      return res;
    }; // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion


    function FFTM(x, y) {
      (this || _global$z).x = x;
      (this || _global$z).y = y;
    }

    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;

      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }

      return t;
    }; // Returns binary-reversed representation of `x`


    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1) return x;
      var rb = 0;

      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }

      return rb;
    }; // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm


    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };

    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);

      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);

        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;

          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            /* jshint maxdepth : false */

            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };

    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;

      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }

      return 1 << i + 1 + odd;
    };

    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1) return;

      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };

    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;

      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;

        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }

      return ws;
    };

    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;

      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      } // Pad with zeroes


      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }

      assert(carry === 0);
      assert((carry & ~8191) === 0);
    };

    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);

      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }

      return ph;
    };

    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);

      var _ = this.stub(N);

      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);

      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }

      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    }; // Multiply `this` by `num`


    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array((this || _global$z).length + num.length);
      return this.mulTo(num, out);
    }; // Multiply employing FFT


    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array((this || _global$z).length + num.length);
      return jumboMulTo(this || _global$z, num, out);
    }; // In-place Multiplication


    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this || _global$z);
    };

    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === "number");
      assert(num < 67108864); // Carry

      var carry = 0;

      for (var i = 0; i < (this || _global$z).length; i++) {
        var w = ((this || _global$z).words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0; // NOTE: lo is 27bit maximum

        carry += lo >>> 26;
        (this || _global$z).words[i] = lo & 67108863;
      }

      if (carry !== 0) {
        (this || _global$z).words[i] = carry;
        (this || _global$z).length++;
      }

      return this || _global$z;
    };

    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    }; // `this` * `this`


    BN.prototype.sqr = function sqr() {
      return this.mul(this || _global$z);
    }; // `this` * `this` in-place


    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    }; // Math.pow(`this`, `num`)


    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN(1); // Skip leading zeroes

      var res = this || _global$z;

      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }

      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
          res = res.mul(q);
        }
      }

      return res;
    }; // Shift-left in-place


    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;

      if (r !== 0) {
        var carry = 0;

        for (i = 0; i < (this || _global$z).length; i++) {
          var newCarry = (this || _global$z).words[i] & carryMask;
          var c = ((this || _global$z).words[i] | 0) - newCarry << r;
          (this || _global$z).words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }

        if (carry) {
          (this || _global$z).words[i] = carry;
          (this || _global$z).length++;
        }
      }

      if (s !== 0) {
        for (i = (this || _global$z).length - 1; i >= 0; i--) {
          (this || _global$z).words[i + s] = (this || _global$z).words[i];
        }

        for (i = 0; i < s; i++) {
          (this || _global$z).words[i] = 0;
        }

        (this || _global$z).length += s;
      }

      return this.strip();
    };

    BN.prototype.ishln = function ishln(bits) {
      // TODO(indutny): implement me
      assert((this || _global$z).negative === 0);
      return this.iushln(bits);
    }; // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits


    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === "number" && bits >= 0);
      var h;

      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }

      var r = bits % 26;
      var s = Math.min((bits - r) / 26, (this || _global$z).length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h); // Extended mode, copy masked part

      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = (this || _global$z).words[i];
        }

        maskedWords.length = s;
      }

      if (s === 0) ; else if ((this || _global$z).length > s) {
        (this || _global$z).length -= s;

        for (i = 0; i < (this || _global$z).length; i++) {
          (this || _global$z).words[i] = (this || _global$z).words[i + s];
        }
      } else {
        (this || _global$z).words[0] = 0;
        (this || _global$z).length = 1;
      }

      var carry = 0;

      for (i = (this || _global$z).length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = (this || _global$z).words[i] | 0;
        (this || _global$z).words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      } // Push carried bits as a mask


      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }

      if ((this || _global$z).length === 0) {
        (this || _global$z).words[0] = 0;
        (this || _global$z).length = 1;
      }

      return this.strip();
    };

    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      // TODO(indutny): implement me
      assert((this || _global$z).negative === 0);
      return this.iushrn(bits, hint, extended);
    }; // Shift-left


    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };

    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    }; // Shift-right


    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };

    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    }; // Test if n bit is set


    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if ((this || _global$z).length <= s) return false; // Check bit and return

      var w = (this || _global$z).words[s];
      return !!(w & q);
    }; // Return only lowers bits of number (in-place)


    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert((this || _global$z).negative === 0, "imaskn works only with positive numbers");

      if ((this || _global$z).length <= s) {
        return this || _global$z;
      }

      if (r !== 0) {
        s++;
      }

      (this || _global$z).length = Math.min(s, (this || _global$z).length);

      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        (this || _global$z).words[(this || _global$z).length - 1] &= mask;
      }

      return this.strip();
    }; // Return only lowers bits of number


    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    }; // Add plain number `num` to `this`


    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0) return this.isubn(-num); // Possible sign change

      if ((this || _global$z).negative !== 0) {
        if ((this || _global$z).length === 1 && ((this || _global$z).words[0] | 0) < num) {
          (this || _global$z).words[0] = num - ((this || _global$z).words[0] | 0);
          (this || _global$z).negative = 0;
          return this || _global$z;
        }

        (this || _global$z).negative = 0;
        this.isubn(num);
        (this || _global$z).negative = 1;
        return this || _global$z;
      } // Add without checks


      return this._iaddn(num);
    };

    BN.prototype._iaddn = function _iaddn(num) {
      (this || _global$z).words[0] += num; // Carry

      for (var i = 0; i < (this || _global$z).length && (this || _global$z).words[i] >= 67108864; i++) {
        (this || _global$z).words[i] -= 67108864;

        if (i === (this || _global$z).length - 1) {
          (this || _global$z).words[i + 1] = 1;
        } else {
          (this || _global$z).words[i + 1]++;
        }
      }

      (this || _global$z).length = Math.max((this || _global$z).length, i + 1);
      return this || _global$z;
    }; // Subtract plain number `num` from `this`


    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0) return this.iaddn(-num);

      if ((this || _global$z).negative !== 0) {
        (this || _global$z).negative = 0;
        this.iaddn(num);
        (this || _global$z).negative = 1;
        return this || _global$z;
      }

      (this || _global$z).words[0] -= num;

      if ((this || _global$z).length === 1 && (this || _global$z).words[0] < 0) {
        (this || _global$z).words[0] = -(this || _global$z).words[0];
        (this || _global$z).negative = 1;
      } else {
        // Carry
        for (var i = 0; i < (this || _global$z).length && (this || _global$z).words[i] < 0; i++) {
          (this || _global$z).words[i] += 67108864;
          (this || _global$z).words[i + 1] -= 1;
        }
      }

      return this.strip();
    };

    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };

    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };

    BN.prototype.iabs = function iabs() {
      (this || _global$z).negative = 0;
      return this || _global$z;
    };

    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };

    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;

      this._expand(len);

      var w;
      var carry = 0;

      for (i = 0; i < num.length; i++) {
        w = ((this || _global$z).words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        (this || _global$z).words[i + shift] = w & 67108863;
      }

      for (; i < (this || _global$z).length - shift; i++) {
        w = ((this || _global$z).words[i + shift] | 0) + carry;
        carry = w >> 26;
        (this || _global$z).words[i + shift] = w & 67108863;
      }

      if (carry === 0) return this.strip(); // Subtraction overflow

      assert(carry === -1);
      carry = 0;

      for (i = 0; i < (this || _global$z).length; i++) {
        w = -((this || _global$z).words[i] | 0) + carry;
        carry = w >> 26;
        (this || _global$z).words[i] = w & 67108863;
      }

      (this || _global$z).negative = 1;
      return this.strip();
    };

    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = (this || _global$z).length - num.length;
      var a = this.clone();
      var b = num; // Normalize

      var bhi = b.words[b.length - 1] | 0;

      var bhiBits = this._countBits(bhi);

      shift = 26 - bhiBits;

      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      } // Initialize quotient


      var m = a.length - b.length;
      var q;

      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);

        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }

      var diff = a.clone()._ishlnsubmul(b, 1, m);

      if (diff.negative === 0) {
        a = diff;

        if (q) {
          q.words[m] = 1;
        }
      }

      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
        // (0x7ffffff)

        qj = Math.min(qj / bhi | 0, 67108863);

        a._ishlnsubmul(b, qj, j);

        while (a.negative !== 0) {
          qj--;
          a.negative = 0;

          a._ishlnsubmul(b, 1, j);

          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }

        if (q) {
          q.words[j] = qj;
        }
      }

      if (q) {
        q.strip();
      }

      a.strip(); // Denormalize

      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }

      return {
        div: q || null,
        mod: a
      };
    }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested


    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());

      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }

      var div, mod, res;

      if ((this || _global$z).negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);

        if (mode !== "mod") {
          div = res.div.neg();
        }

        if (mode !== "div") {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }

        return {
          div: div,
          mod: mod
        };
      }

      if ((this || _global$z).negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);

        if (mode !== "mod") {
          div = res.div.neg();
        }

        return {
          div: div,
          mod: res.mod
        };
      }

      if (((this || _global$z).negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);

        if (mode !== "div") {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }

        return {
          div: res.div,
          mod: mod
        };
      } // Both numbers are positive at this point
      // Strip both numbers to approximate shift value


      if (num.length > (this || _global$z).length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this || _global$z
        };
      } // Very short reduction


      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }

        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }

        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return this._wordDiv(num, mode);
    }; // Find `this` / `num`


    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    }; // Find `this` % `num`


    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };

    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    }; // Find Round(`this` / `num`)


    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num); // Fast case - exact division

      if (dm.mod.isZero()) return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half); // Round down

      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };

    BN.prototype.modn = function modn(num) {
      assert(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;

      for (var i = (this || _global$z).length - 1; i >= 0; i--) {
        acc = (p * acc + ((this || _global$z).words[i] | 0)) % num;
      }

      return acc;
    }; // In-place division by number


    BN.prototype.idivn = function idivn(num) {
      assert(num <= 67108863);
      var carry = 0;

      for (var i = (this || _global$z).length - 1; i >= 0; i--) {
        var w = ((this || _global$z).words[i] | 0) + carry * 67108864;
        (this || _global$z).words[i] = w / num | 0;
        carry = w % num;
      }

      return this.strip();
    };

    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };

    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this || _global$z;
      var y = p.clone();

      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      } // A * x + B * y = x


      var A = new BN(1);
      var B = new BN(0); // C * x + D * y = y

      var C = new BN(0);
      var D = new BN(1);
      var g = 0;

      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }

      var yp = y.clone();
      var xp = x.clone();

      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

        if (i > 0) {
          x.iushrn(i);

          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }

            A.iushrn(1);
            B.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

        if (j > 0) {
          y.iushrn(j);

          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }

            C.iushrn(1);
            D.iushrn(1);
          }
        }

        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }

      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    }; // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed


    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this || _global$z;
      var b = p.clone();

      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }

      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();

      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

        if (i > 0) {
          a.iushrn(i);

          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }

            x1.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

        if (j > 0) {
          b.iushrn(j);

          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }

            x2.iushrn(1);
          }
        }

        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }

      var res;

      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }

      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }

      return res;
    };

    BN.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0; // Remove common factor of two

      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }

      do {
        while (a.isEven()) {
          a.iushrn(1);
        }

        while (b.isEven()) {
          b.iushrn(1);
        }

        var r = a.cmp(b);

        if (r < 0) {
          // Swap `a` and `b` to make `a` always bigger than `b`
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }

        a.isub(b);
      } while (true);

      return b.iushln(shift);
    }; // Invert number in the field F(num)


    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };

    BN.prototype.isEven = function isEven() {
      return ((this || _global$z).words[0] & 1) === 0;
    };

    BN.prototype.isOdd = function isOdd() {
      return ((this || _global$z).words[0] & 1) === 1;
    }; // And first word and num


    BN.prototype.andln = function andln(num) {
      return (this || _global$z).words[0] & num;
    }; // Increment at the bit position in-line


    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if ((this || _global$z).length <= s) {
        this._expand(s + 1);

        (this || _global$z).words[s] |= q;
        return this || _global$z;
      } // Add bit and propagate, if needed


      var carry = q;

      for (var i = s; carry !== 0 && i < (this || _global$z).length; i++) {
        var w = (this || _global$z).words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        (this || _global$z).words[i] = w;
      }

      if (carry !== 0) {
        (this || _global$z).words[i] = carry;
        (this || _global$z).length++;
      }

      return this || _global$z;
    };

    BN.prototype.isZero = function isZero() {
      return (this || _global$z).length === 1 && (this || _global$z).words[0] === 0;
    };

    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if ((this || _global$z).negative !== 0 && !negative) return -1;
      if ((this || _global$z).negative === 0 && negative) return 1;
      this.strip();
      var res;

      if ((this || _global$z).length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }

        assert(num <= 67108863, "Number is too big");
        var w = (this || _global$z).words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }

      if ((this || _global$z).negative !== 0) return -res | 0;
      return res;
    }; // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`


    BN.prototype.cmp = function cmp(num) {
      if ((this || _global$z).negative !== 0 && num.negative === 0) return -1;
      if ((this || _global$z).negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if ((this || _global$z).negative !== 0) return -res | 0;
      return res;
    }; // Unsigned comparison


    BN.prototype.ucmp = function ucmp(num) {
      // At this point both numbers have the same sign
      if ((this || _global$z).length > num.length) return 1;
      if ((this || _global$z).length < num.length) return -1;
      var res = 0;

      for (var i = (this || _global$z).length - 1; i >= 0; i--) {
        var a = (this || _global$z).words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;

        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }

        break;
      }

      return res;
    };

    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };

    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };

    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };

    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };

    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };

    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };

    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };

    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };

    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };

    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    }; //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //


    BN.red = function red(num) {
      return new Red(num);
    };

    BN.prototype.toRed = function toRed(ctx) {
      assert(!(this || _global$z).red, "Already a number in reduction context");
      assert((this || _global$z).negative === 0, "red works only with positives");
      return ctx.convertTo(this || _global$z)._forceRed(ctx);
    };

    BN.prototype.fromRed = function fromRed() {
      assert((this || _global$z).red, "fromRed works only with numbers in reduction context");
      return (this || _global$z).red.convertFrom(this || _global$z);
    };

    BN.prototype._forceRed = function _forceRed(ctx) {
      (this || _global$z).red = ctx;
      return this || _global$z;
    };

    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!(this || _global$z).red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };

    BN.prototype.redAdd = function redAdd(num) {
      assert((this || _global$z).red, "redAdd works only with red numbers");
      return (this || _global$z).red.add(this || _global$z, num);
    };

    BN.prototype.redIAdd = function redIAdd(num) {
      assert((this || _global$z).red, "redIAdd works only with red numbers");
      return (this || _global$z).red.iadd(this || _global$z, num);
    };

    BN.prototype.redSub = function redSub(num) {
      assert((this || _global$z).red, "redSub works only with red numbers");
      return (this || _global$z).red.sub(this || _global$z, num);
    };

    BN.prototype.redISub = function redISub(num) {
      assert((this || _global$z).red, "redISub works only with red numbers");
      return (this || _global$z).red.isub(this || _global$z, num);
    };

    BN.prototype.redShl = function redShl(num) {
      assert((this || _global$z).red, "redShl works only with red numbers");
      return (this || _global$z).red.shl(this || _global$z, num);
    };

    BN.prototype.redMul = function redMul(num) {
      assert((this || _global$z).red, "redMul works only with red numbers");

      (this || _global$z).red._verify2(this || _global$z, num);

      return (this || _global$z).red.mul(this || _global$z, num);
    };

    BN.prototype.redIMul = function redIMul(num) {
      assert((this || _global$z).red, "redMul works only with red numbers");

      (this || _global$z).red._verify2(this || _global$z, num);

      return (this || _global$z).red.imul(this || _global$z, num);
    };

    BN.prototype.redSqr = function redSqr() {
      assert((this || _global$z).red, "redSqr works only with red numbers");

      (this || _global$z).red._verify1(this || _global$z);

      return (this || _global$z).red.sqr(this || _global$z);
    };

    BN.prototype.redISqr = function redISqr() {
      assert((this || _global$z).red, "redISqr works only with red numbers");

      (this || _global$z).red._verify1(this || _global$z);

      return (this || _global$z).red.isqr(this || _global$z);
    }; // Square root over p


    BN.prototype.redSqrt = function redSqrt() {
      assert((this || _global$z).red, "redSqrt works only with red numbers");

      (this || _global$z).red._verify1(this || _global$z);

      return (this || _global$z).red.sqrt(this || _global$z);
    };

    BN.prototype.redInvm = function redInvm() {
      assert((this || _global$z).red, "redInvm works only with red numbers");

      (this || _global$z).red._verify1(this || _global$z);

      return (this || _global$z).red.invm(this || _global$z);
    }; // Return negative clone of `this` % `red modulo`


    BN.prototype.redNeg = function redNeg() {
      assert((this || _global$z).red, "redNeg works only with red numbers");

      (this || _global$z).red._verify1(this || _global$z);

      return (this || _global$z).red.neg(this || _global$z);
    };

    BN.prototype.redPow = function redPow(num) {
      assert((this || _global$z).red && !num.red, "redPow(normalNum)");

      (this || _global$z).red._verify1(this || _global$z);

      return (this || _global$z).red.pow(this || _global$z, num);
    }; // Prime numbers with efficient reduction


    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    }; // Pseudo-Mersenne prime

    function MPrime(name, p) {
      // P = 2 ^ N - K
      (this || _global$z).name = name;
      (this || _global$z).p = new BN(p, 16);
      (this || _global$z).n = (this || _global$z).p.bitLength();
      (this || _global$z).k = new BN(1).iushln((this || _global$z).n).isub((this || _global$z).p);
      (this || _global$z).tmp = this._tmp();
    }

    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil((this || _global$z).n / 13));
      return tmp;
    };

    MPrime.prototype.ireduce = function ireduce(num) {
      // Assumes that `num` is less than `P^2`
      // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
      var r = num;
      var rlen;

      do {
        this.split(r, (this || _global$z).tmp);
        r = this.imulK(r);
        r = r.iadd((this || _global$z).tmp);
        rlen = r.bitLength();
      } while (rlen > (this || _global$z).n);

      var cmp = rlen < (this || _global$z).n ? -1 : r.ucmp((this || _global$z).p);

      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub((this || _global$z).p);
      } else {
        if (r.strip !== undefined) {
          // r is BN v4 instance
          r.strip();
        } else {
          // r is BN v5 instance
          r._strip();
        }
      }

      return r;
    };

    MPrime.prototype.split = function split(input, out) {
      input.iushrn((this || _global$z).n, 0, out);
    };

    MPrime.prototype.imulK = function imulK(num) {
      return num.imul((this || _global$z).k);
    };

    function K256() {
      MPrime.call(this || _global$z, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }

    inherits(K256, MPrime);

    K256.prototype.split = function split(input, output) {
      // 256 = 9 * 26 + 22
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);

      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }

      output.length = outLen;

      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      } // Shift by 9 limbs


      var prev = input.words[9];
      output.words[output.length++] = prev & mask;

      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }

      prev >>>= 22;
      input.words[i - 10] = prev;

      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };

    K256.prototype.imulK = function imulK(num) {
      // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

      var lo = 0;

      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      } // Fast length reduction


      if (num.words[num.length - 1] === 0) {
        num.length--;

        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }

      return num;
    };

    function P224() {
      MPrime.call(this || _global$z, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }

    inherits(P224, MPrime);

    function P192() {
      MPrime.call(this || _global$z, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }

    inherits(P192, MPrime);

    function P25519() {
      // 2 ^ 255 - 19
      MPrime.call(this || _global$z, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }

    inherits(P25519, MPrime);

    P25519.prototype.imulK = function imulK(num) {
      // K = 0x13
      var carry = 0;

      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }

      if (carry !== 0) {
        num.words[num.length++] = carry;
      }

      return num;
    }; // Exported mostly for testing purposes, use plain name instead


    BN._prime = function prime(name) {
      // Cached version of prime
      if (primes[name]) return primes[name];
      var prime;

      if (name === "k256") {
        prime = new K256();
      } else if (name === "p224") {
        prime = new P224();
      } else if (name === "p192") {
        prime = new P192();
      } else if (name === "p25519") {
        prime = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }

      primes[name] = prime;
      return prime;
    }; //
    // Base reduction engine
    //


    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);

        (this || _global$z).m = prime.p;
        (this || _global$z).prime = prime;
      } else {
        assert(m.gtn(1), "modulus must be greater than 1");
        (this || _global$z).m = m;
        (this || _global$z).prime = null;
      }
    }

    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, "red works only with positives");
      assert(a.red, "red works only with red numbers");
    };

    Red.prototype._verify2 = function _verify2(a, b) {
      assert((a.negative | b.negative) === 0, "red works only with positives");
      assert(a.red && a.red === b.red, "red works only with red numbers");
    };

    Red.prototype.imod = function imod(a) {
      if ((this || _global$z).prime) return (this || _global$z).prime.ireduce(a)._forceRed(this || _global$z);
      return a.umod((this || _global$z).m)._forceRed(this || _global$z);
    };

    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }

      return (this || _global$z).m.sub(a)._forceRed(this || _global$z);
    };

    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);

      var res = a.add(b);

      if (res.cmp((this || _global$z).m) >= 0) {
        res.isub((this || _global$z).m);
      }

      return res._forceRed(this || _global$z);
    };

    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);

      var res = a.iadd(b);

      if (res.cmp((this || _global$z).m) >= 0) {
        res.isub((this || _global$z).m);
      }

      return res;
    };

    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);

      var res = a.sub(b);

      if (res.cmpn(0) < 0) {
        res.iadd((this || _global$z).m);
      }

      return res._forceRed(this || _global$z);
    };

    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);

      var res = a.isub(b);

      if (res.cmpn(0) < 0) {
        res.iadd((this || _global$z).m);
      }

      return res;
    };

    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);

      return this.imod(a.ushln(num));
    };

    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);

      return this.imod(a.imul(b));
    };

    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);

      return this.imod(a.mul(b));
    };

    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };

    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };

    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero()) return a.clone();

      var mod3 = (this || _global$z).m.andln(3);

      assert(mod3 % 2 === 1); // Fast case

      if (mod3 === 3) {
        var pow = (this || _global$z).m.add(new BN(1)).iushrn(2);

        return this.pow(a, pow);
      } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
      //
      // Find Q and S, that Q * 2 ^ S = (P - 1)


      var q = (this || _global$z).m.subn(1);

      var s = 0;

      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }

      assert(!q.isZero());
      var one = new BN(1).toRed(this || _global$z);
      var nOne = one.redNeg(); // Find quadratic non-residue
      // NOTE: Max is such because of generalized Riemann hypothesis.

      var lpow = (this || _global$z).m.subn(1).iushrn(1);

      var z = (this || _global$z).m.bitLength();

      z = new BN(2 * z * z).toRed(this || _global$z);

      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }

      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;

      while (t.cmp(one) !== 0) {
        var tmp = t;

        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }

        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }

      return r;
    };

    Red.prototype.invm = function invm(a) {
      var inv = a._invmp((this || _global$z).m);

      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };

    Red.prototype.pow = function pow(a, num) {
      if (num.isZero()) return new BN(1).toRed(this || _global$z);
      if (num.cmpn(1) === 0) return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this || _global$z);
      wnd[1] = a;

      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }

      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;

      if (start === 0) {
        start = 26;
      }

      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];

        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;

          if (res !== wnd[0]) {
            res = this.sqr(res);
          }

          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }

          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }

        start = 26;
      }

      return res;
    };

    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod((this || _global$z).m);
      return r === num ? r.clone() : r;
    };

    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    }; //
    // Montgomery method engine
    //


    BN.mont = function mont(num) {
      return new Mont(num);
    };

    function Mont(m) {
      Red.call(this || _global$z, m);
      (this || _global$z).shift = (this || _global$z).m.bitLength();

      if ((this || _global$z).shift % 26 !== 0) {
        (this || _global$z).shift += 26 - (this || _global$z).shift % 26;
      }

      (this || _global$z).r = new BN(1).iushln((this || _global$z).shift);
      (this || _global$z).r2 = this.imod((this || _global$z).r.sqr());
      (this || _global$z).rinv = (this || _global$z).r._invmp((this || _global$z).m);
      (this || _global$z).minv = (this || _global$z).rinv.mul((this || _global$z).r).isubn(1).div((this || _global$z).m);
      (this || _global$z).minv = (this || _global$z).minv.umod((this || _global$z).r);
      (this || _global$z).minv = (this || _global$z).r.sub((this || _global$z).minv);
    }

    inherits(Mont, Red);

    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln((this || _global$z).shift));
    };

    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul((this || _global$z).rinv));
      r.red = null;
      return r;
    };

    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }

      var t = a.imul(b);
      var c = t.maskn((this || _global$z).shift).mul((this || _global$z).minv).imaskn((this || _global$z).shift).mul((this || _global$z).m);
      var u = t.isub(c).iushrn((this || _global$z).shift);
      var res = u;

      if (u.cmp((this || _global$z).m) >= 0) {
        res = u.isub((this || _global$z).m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd((this || _global$z).m);
      }

      return res._forceRed(this || _global$z);
    };

    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this || _global$z);
      var t = a.mul(b);
      var c = t.maskn((this || _global$z).shift).mul((this || _global$z).minv).imaskn((this || _global$z).shift).mul((this || _global$z).m);
      var u = t.isub(c).iushrn((this || _global$z).shift);
      var res = u;

      if (u.cmp((this || _global$z).m) >= 0) {
        res = u.isub((this || _global$z).m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd((this || _global$z).m);
      }

      return res._forceRed(this || _global$z);
    };

    Mont.prototype.invm = function invm(a) {
      // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
      var res = this.imod(a._invmp((this || _global$z).m).mul((this || _global$z).r2));
      return res._forceRed(this || _global$z);
    };
  })(module$a, exports$1Y);

  return module$a.exports;
}

var exports$1X = {},
    _dewExec$1W = false;
var module$9 = {
  exports: exports$1X
};

var _global$y = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1W() {
  if (_dewExec$1W) return module$9.exports;
  _dewExec$1W = true;

  (function (module, exports) {

    function assert(val, msg) {
      if (!val) throw new Error(msg || "Assertion failed");
    } // Could use `inherits` module, but don't want to move from single file
    // architecture yet.


    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    } // BN


    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }

      (this || _global$y).negative = 0;
      (this || _global$y).words = null;
      (this || _global$y).length = 0; // Reduction context

      (this || _global$y).red = null;

      if (number !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }

        this._init(number || 0, base || 10, endian || "be");
      }
    }

    if (typeof module === "object") {
      module.exports = BN;
    } else {
      exports.BN = BN;
    }

    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;

    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer = window.Buffer;
      } else {
        Buffer = buffer.Buffer;
      }
    } catch (e) {}

    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }

      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };

    BN.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };

    BN.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };

    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base, endian);
      }

      if (typeof number === "object") {
        return this._initArray(number, base, endian);
      }

      if (base === "hex") {
        base = 16;
      }

      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;

      if (number[0] === "-") {
        start++;
        (this || _global$y).negative = 1;
      }

      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);

          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };

    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        (this || _global$y).negative = 1;
        number = -number;
      }

      if (number < 67108864) {
        (this || _global$y).words = [number & 67108863];
        (this || _global$y).length = 1;
      } else if (number < 4503599627370496) {
        (this || _global$y).words = [number & 67108863, number / 67108864 & 67108863];
        (this || _global$y).length = 2;
      } else {
        assert(number < 9007199254740992); // 2 ^ 53 (unsafe)

        (this || _global$y).words = [number & 67108863, number / 67108864 & 67108863, 1];
        (this || _global$y).length = 3;
      }

      if (endian !== "le") return; // Reverse the bytes

      this._initArray(this.toArray(), base, endian);
    };

    BN.prototype._initArray = function _initArray(number, base, endian) {
      // Perhaps a Uint8Array
      assert(typeof number.length === "number");

      if (number.length <= 0) {
        (this || _global$y).words = [0];
        (this || _global$y).length = 1;
        return this || _global$y;
      }

      (this || _global$y).length = Math.ceil(number.length / 3);
      (this || _global$y).words = new Array((this || _global$y).length);

      for (var i = 0; i < (this || _global$y).length; i++) {
        (this || _global$y).words[i] = 0;
      }

      var j, w;
      var off = 0;

      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          (this || _global$y).words[j] |= w << off & 67108863;
          (this || _global$y).words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          (this || _global$y).words[j] |= w << off & 67108863;
          (this || _global$y).words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }

      return this.strip();
    };

    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index); // 'A' - 'F'

      if (c >= 65 && c <= 70) {
        return c - 55; // 'a' - 'f'
      } else if (c >= 97 && c <= 102) {
        return c - 87; // '0' - '9'
      } else {
        return c - 48 & 15;
      }
    }

    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);

      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }

      return r;
    }

    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      // Create possibly bigger array to ensure that it fits the number
      (this || _global$y).length = Math.ceil((number.length - start) / 6);
      (this || _global$y).words = new Array((this || _global$y).length);

      for (var i = 0; i < (this || _global$y).length; i++) {
        (this || _global$y).words[i] = 0;
      } // 24-bits chunks


      var off = 0;
      var j = 0;
      var w;

      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          (this || _global$y).words[j] |= w & 67108863;

          if (off >= 18) {
            off -= 18;
            j += 1;
            (this || _global$y).words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;

        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          (this || _global$y).words[j] |= w & 67108863;

          if (off >= 18) {
            off -= 18;
            j += 1;
            (this || _global$y).words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }

      this.strip();
    };

    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);

      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul; // 'a'

        if (c >= 49) {
          r += c - 49 + 10; // 'A'
        } else if (c >= 17) {
          r += c - 17 + 10; // '0' - '9'
        } else {
          r += c;
        }
      }

      return r;
    }

    BN.prototype._parseBase = function _parseBase(number, base, start) {
      // Initialize as zero
      (this || _global$y).words = [0];
      (this || _global$y).length = 1; // Find length of limb in base

      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }

      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;

      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);

        if ((this || _global$y).words[0] + word < 67108864) {
          (this || _global$y).words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);

        for (i = 0; i < mod; i++) {
          pow *= base;
        }

        this.imuln(pow);

        if ((this || _global$y).words[0] + word < 67108864) {
          (this || _global$y).words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      this.strip();
    };

    BN.prototype.copy = function copy(dest) {
      dest.words = new Array((this || _global$y).length);

      for (var i = 0; i < (this || _global$y).length; i++) {
        dest.words[i] = (this || _global$y).words[i];
      }

      dest.length = (this || _global$y).length;
      dest.negative = (this || _global$y).negative;
      dest.red = (this || _global$y).red;
    };

    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };

    BN.prototype._expand = function _expand(size) {
      while ((this || _global$y).length < size) {
        (this || _global$y).words[(this || _global$y).length++] = 0;
      }

      return this || _global$y;
    }; // Remove leading `0` from `this`


    BN.prototype.strip = function strip() {
      while ((this || _global$y).length > 1 && (this || _global$y).words[(this || _global$y).length - 1] === 0) {
        (this || _global$y).length--;
      }

      return this._normSign();
    };

    BN.prototype._normSign = function _normSign() {
      // -0 = 0
      if ((this || _global$y).length === 1 && (this || _global$y).words[0] === 0) {
        (this || _global$y).negative = 0;
      }

      return this || _global$y;
    };

    BN.prototype.inspect = function inspect() {
      return ((this || _global$y).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*
     var zeros = [];
    var groupSizes = [];
    var groupBases = [];
     var s = '';
    var i = -1;
    while (++i < BN.wordSize) {
      zeros[i] = s;
      s += '0';
    }
    groupSizes[0] = 0;
    groupSizes[1] = 0;
    groupBases[0] = 0;
    groupBases[1] = 0;
    var base = 2 - 1;
    while (++base < 36 + 1) {
      var groupSize = 0;
      var groupBase = 1;
      while (groupBase < (1 << BN.wordSize) / base) {
        groupBase *= base;
        groupSize += 1;
      }
      groupSizes[base] = groupSize;
      groupBases[base] = groupBase;
    }
     */


    var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;

      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;

        for (var i = 0; i < (this || _global$y).length; i++) {
          var w = (this || _global$y).words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;

          if (carry !== 0 || i !== (this || _global$y).length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }

          off += 2;

          if (off >= 26) {
            off -= 26;
            i--;
          }
        }

        if (carry !== 0) {
          out = carry.toString(16) + out;
        }

        while (out.length % padding !== 0) {
          out = "0" + out;
        }

        if ((this || _global$y).negative !== 0) {
          out = "-" + out;
        }

        return out;
      }

      if (base === (base | 0) && base >= 2 && base <= 36) {
        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
        var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;

        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);

          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }

        if (this.isZero()) {
          out = "0" + out;
        }

        while (out.length % padding !== 0) {
          out = "0" + out;
        }

        if ((this || _global$y).negative !== 0) {
          out = "-" + out;
        }

        return out;
      }

      assert(false, "Base should be between 2 and 36");
    };

    BN.prototype.toNumber = function toNumber() {
      var ret = (this || _global$y).words[0];

      if ((this || _global$y).length === 2) {
        ret += (this || _global$y).words[1] * 67108864;
      } else if ((this || _global$y).length === 3 && (this || _global$y).words[2] === 1) {
        // NOTE: at this stage it is known that the top bit is set
        ret += 4503599627370496 + (this || _global$y).words[1] * 67108864;
      } else if ((this || _global$y).length > 2) {
        assert(false, "Number can only safely store up to 53 bits");
      }

      return (this || _global$y).negative !== 0 ? -ret : ret;
    };

    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };

    BN.prototype.toBuffer = function toBuffer(endian, length) {
      assert(typeof Buffer !== "undefined");
      return this.toArrayLike(Buffer, endian, length);
    };

    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };

    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, "byte array longer than desired length");
      assert(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b, i;
      var q = this.clone();

      if (!littleEndian) {
        // Assume big-endian
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }

        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[i] = b;
        }

        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }

      return res;
    };

    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;

        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }

        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }

        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }

        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }

        return r + t;
      };
    }

    BN.prototype._zeroBits = function _zeroBits(w) {
      // Short-cut
      if (w === 0) return 26;
      var t = w;
      var r = 0;

      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }

      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }

      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }

      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }

      if ((t & 1) === 0) {
        r++;
      }

      return r;
    }; // Return number of used bits in a BN


    BN.prototype.bitLength = function bitLength() {
      var w = (this || _global$y).words[(this || _global$y).length - 1];

      var hi = this._countBits(w);

      return ((this || _global$y).length - 1) * 26 + hi;
    };

    function toBitArray(num) {
      var w = new Array(num.bitLength());

      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }

      return w;
    } // Number of trailing zero bits


    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r = 0;

      for (var i = 0; i < (this || _global$y).length; i++) {
        var b = this._zeroBits((this || _global$y).words[i]);

        r += b;
        if (b !== 26) break;
      }

      return r;
    };

    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };

    BN.prototype.toTwos = function toTwos(width) {
      if ((this || _global$y).negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }

      return this.clone();
    };

    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }

      return this.clone();
    };

    BN.prototype.isNeg = function isNeg() {
      return (this || _global$y).negative !== 0;
    }; // Return negative clone of `this`


    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };

    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        (this || _global$y).negative ^= 1;
      }

      return this || _global$y;
    }; // Or `num` with `this` in-place


    BN.prototype.iuor = function iuor(num) {
      while ((this || _global$y).length < num.length) {
        (this || _global$y).words[(this || _global$y).length++] = 0;
      }

      for (var i = 0; i < num.length; i++) {
        (this || _global$y).words[i] = (this || _global$y).words[i] | num.words[i];
      }

      return this.strip();
    };

    BN.prototype.ior = function ior(num) {
      assert(((this || _global$y).negative | num.negative) === 0);
      return this.iuor(num);
    }; // Or `num` with `this`


    BN.prototype.or = function or(num) {
      if ((this || _global$y).length > num.length) return this.clone().ior(num);
      return num.clone().ior(this || _global$y);
    };

    BN.prototype.uor = function uor(num) {
      if ((this || _global$y).length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this || _global$y);
    }; // And `num` with `this` in-place


    BN.prototype.iuand = function iuand(num) {
      // b = min-length(num, this)
      var b;

      if ((this || _global$y).length > num.length) {
        b = num;
      } else {
        b = this || _global$y;
      }

      for (var i = 0; i < b.length; i++) {
        (this || _global$y).words[i] = (this || _global$y).words[i] & num.words[i];
      }

      (this || _global$y).length = b.length;
      return this.strip();
    };

    BN.prototype.iand = function iand(num) {
      assert(((this || _global$y).negative | num.negative) === 0);
      return this.iuand(num);
    }; // And `num` with `this`


    BN.prototype.and = function and(num) {
      if ((this || _global$y).length > num.length) return this.clone().iand(num);
      return num.clone().iand(this || _global$y);
    };

    BN.prototype.uand = function uand(num) {
      if ((this || _global$y).length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this || _global$y);
    }; // Xor `num` with `this` in-place


    BN.prototype.iuxor = function iuxor(num) {
      // a.length > b.length
      var a;
      var b;

      if ((this || _global$y).length > num.length) {
        a = this || _global$y;
        b = num;
      } else {
        a = num;
        b = this || _global$y;
      }

      for (var i = 0; i < b.length; i++) {
        (this || _global$y).words[i] = a.words[i] ^ b.words[i];
      }

      if ((this || _global$y) !== a) {
        for (; i < a.length; i++) {
          (this || _global$y).words[i] = a.words[i];
        }
      }

      (this || _global$y).length = a.length;
      return this.strip();
    };

    BN.prototype.ixor = function ixor(num) {
      assert(((this || _global$y).negative | num.negative) === 0);
      return this.iuxor(num);
    }; // Xor `num` with `this`


    BN.prototype.xor = function xor(num) {
      if ((this || _global$y).length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this || _global$y);
    };

    BN.prototype.uxor = function uxor(num) {
      if ((this || _global$y).length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this || _global$y);
    }; // Not ``this`` with ``width`` bitwidth


    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26; // Extend the buffer with leading zeroes

      this._expand(bytesNeeded);

      if (bitsLeft > 0) {
        bytesNeeded--;
      } // Handle complete words


      for (var i = 0; i < bytesNeeded; i++) {
        (this || _global$y).words[i] = ~(this || _global$y).words[i] & 67108863;
      } // Handle the residue


      if (bitsLeft > 0) {
        (this || _global$y).words[i] = ~(this || _global$y).words[i] & 67108863 >> 26 - bitsLeft;
      } // And remove leading zeroes


      return this.strip();
    };

    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    }; // Set `bit` of `this`


    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;

      this._expand(off + 1);

      if (val) {
        (this || _global$y).words[off] = (this || _global$y).words[off] | 1 << wbit;
      } else {
        (this || _global$y).words[off] = (this || _global$y).words[off] & ~(1 << wbit);
      }

      return this.strip();
    }; // Add `num` to `this` in-place


    BN.prototype.iadd = function iadd(num) {
      var r; // negative + positive

      if ((this || _global$y).negative !== 0 && num.negative === 0) {
        (this || _global$y).negative = 0;
        r = this.isub(num);
        (this || _global$y).negative ^= 1;
        return this._normSign(); // positive + negative
      } else if ((this || _global$y).negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      } // a.length > b.length


      var a, b;

      if ((this || _global$y).length > num.length) {
        a = this || _global$y;
        b = num;
      } else {
        a = num;
        b = this || _global$y;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        (this || _global$y).words[i] = r & 67108863;
        carry = r >>> 26;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        (this || _global$y).words[i] = r & 67108863;
        carry = r >>> 26;
      }

      (this || _global$y).length = a.length;

      if (carry !== 0) {
        (this || _global$y).words[(this || _global$y).length] = carry;
        (this || _global$y).length++; // Copy the rest of the words
      } else if (a !== (this || _global$y)) {
        for (; i < a.length; i++) {
          (this || _global$y).words[i] = a.words[i];
        }
      }

      return this || _global$y;
    }; // Add `num` to `this`


    BN.prototype.add = function add(num) {
      var res;

      if (num.negative !== 0 && (this || _global$y).negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && (this || _global$y).negative !== 0) {
        (this || _global$y).negative = 0;
        res = num.sub(this || _global$y);
        (this || _global$y).negative = 1;
        return res;
      }

      if ((this || _global$y).length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this || _global$y);
    }; // Subtract `num` from `this` in-place


    BN.prototype.isub = function isub(num) {
      // this - (-num) = this + num
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign(); // -this - num = -(this + num)
      } else if ((this || _global$y).negative !== 0) {
        (this || _global$y).negative = 0;
        this.iadd(num);
        (this || _global$y).negative = 1;
        return this._normSign();
      } // At this point both numbers are positive


      var cmp = this.cmp(num); // Optimization - zeroify

      if (cmp === 0) {
        (this || _global$y).negative = 0;
        (this || _global$y).length = 1;
        (this || _global$y).words[0] = 0;
        return this || _global$y;
      } // a > b


      var a, b;

      if (cmp > 0) {
        a = this || _global$y;
        b = num;
      } else {
        a = num;
        b = this || _global$y;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        (this || _global$y).words[i] = r & 67108863;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        (this || _global$y).words[i] = r & 67108863;
      } // Copy rest of the words


      if (carry === 0 && i < a.length && a !== (this || _global$y)) {
        for (; i < a.length; i++) {
          (this || _global$y).words[i] = a.words[i];
        }
      }

      (this || _global$y).length = Math.max((this || _global$y).length, i);

      if (a !== (this || _global$y)) {
        (this || _global$y).negative = 1;
      }

      return this.strip();
    }; // Subtract `num` from `this`


    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };

    function smallMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      var len = self.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

      var a = self.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;

      for (var k = 1; k < len; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }

        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }

      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }

      return out.strip();
    } // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).


    var comb10MulTo = function comb10MulTo(self, num, out) {
      var a = self.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self.negative ^ num.negative;
      out.length = 19;
      /* k = 0 */

      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      /* k = 1 */

      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      /* k = 2 */

      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      /* k = 3 */

      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      /* k = 4 */

      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      /* k = 5 */

      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      /* k = 6 */

      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      /* k = 7 */

      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      /* k = 8 */

      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      /* k = 9 */

      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      /* k = 10 */

      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      /* k = 11 */

      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      /* k = 12 */

      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      /* k = 13 */

      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      /* k = 14 */

      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      /* k = 15 */

      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      /* k = 16 */

      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      /* k = 17 */

      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      /* k = 18 */

      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;

      if (c !== 0) {
        o[19] = c;
        out.length++;
      }

      return out;
    }; // Polyfill comb


    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }

    function bigMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      out.length = self.length + num.length;
      var carry = 0;
      var hncarry = 0;

      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }

        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }

      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }

      return out.strip();
    }

    function jumboMulTo(self, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self, num, out);
    }

    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = (this || _global$y).length + num.length;

      if ((this || _global$y).length === 10 && num.length === 10) {
        res = comb10MulTo(this || _global$y, num, out);
      } else if (len < 63) {
        res = smallMulTo(this || _global$y, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this || _global$y, num, out);
      } else {
        res = jumboMulTo(this || _global$y, num, out);
      }

      return res;
    }; // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion


    function FFTM(x, y) {
      (this || _global$y).x = x;
      (this || _global$y).y = y;
    }

    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;

      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }

      return t;
    }; // Returns binary-reversed representation of `x`


    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1) return x;
      var rb = 0;

      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }

      return rb;
    }; // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm


    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };

    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);

      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);

        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;

          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            /* jshint maxdepth : false */

            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };

    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;

      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }

      return 1 << i + 1 + odd;
    };

    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1) return;

      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };

    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;

      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;

        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }

      return ws;
    };

    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;

      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      } // Pad with zeroes


      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }

      assert(carry === 0);
      assert((carry & ~8191) === 0);
    };

    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);

      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }

      return ph;
    };

    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);

      var _ = this.stub(N);

      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);

      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }

      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    }; // Multiply `this` by `num`


    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array((this || _global$y).length + num.length);
      return this.mulTo(num, out);
    }; // Multiply employing FFT


    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array((this || _global$y).length + num.length);
      return jumboMulTo(this || _global$y, num, out);
    }; // In-place Multiplication


    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this || _global$y);
    };

    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === "number");
      assert(num < 67108864); // Carry

      var carry = 0;

      for (var i = 0; i < (this || _global$y).length; i++) {
        var w = ((this || _global$y).words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0; // NOTE: lo is 27bit maximum

        carry += lo >>> 26;
        (this || _global$y).words[i] = lo & 67108863;
      }

      if (carry !== 0) {
        (this || _global$y).words[i] = carry;
        (this || _global$y).length++;
      }

      return this || _global$y;
    };

    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    }; // `this` * `this`


    BN.prototype.sqr = function sqr() {
      return this.mul(this || _global$y);
    }; // `this` * `this` in-place


    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    }; // Math.pow(`this`, `num`)


    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN(1); // Skip leading zeroes

      var res = this || _global$y;

      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }

      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
          res = res.mul(q);
        }
      }

      return res;
    }; // Shift-left in-place


    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;

      if (r !== 0) {
        var carry = 0;

        for (i = 0; i < (this || _global$y).length; i++) {
          var newCarry = (this || _global$y).words[i] & carryMask;
          var c = ((this || _global$y).words[i] | 0) - newCarry << r;
          (this || _global$y).words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }

        if (carry) {
          (this || _global$y).words[i] = carry;
          (this || _global$y).length++;
        }
      }

      if (s !== 0) {
        for (i = (this || _global$y).length - 1; i >= 0; i--) {
          (this || _global$y).words[i + s] = (this || _global$y).words[i];
        }

        for (i = 0; i < s; i++) {
          (this || _global$y).words[i] = 0;
        }

        (this || _global$y).length += s;
      }

      return this.strip();
    };

    BN.prototype.ishln = function ishln(bits) {
      // TODO(indutny): implement me
      assert((this || _global$y).negative === 0);
      return this.iushln(bits);
    }; // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits


    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === "number" && bits >= 0);
      var h;

      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }

      var r = bits % 26;
      var s = Math.min((bits - r) / 26, (this || _global$y).length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h); // Extended mode, copy masked part

      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = (this || _global$y).words[i];
        }

        maskedWords.length = s;
      }

      if (s === 0) ; else if ((this || _global$y).length > s) {
        (this || _global$y).length -= s;

        for (i = 0; i < (this || _global$y).length; i++) {
          (this || _global$y).words[i] = (this || _global$y).words[i + s];
        }
      } else {
        (this || _global$y).words[0] = 0;
        (this || _global$y).length = 1;
      }

      var carry = 0;

      for (i = (this || _global$y).length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = (this || _global$y).words[i] | 0;
        (this || _global$y).words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      } // Push carried bits as a mask


      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }

      if ((this || _global$y).length === 0) {
        (this || _global$y).words[0] = 0;
        (this || _global$y).length = 1;
      }

      return this.strip();
    };

    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      // TODO(indutny): implement me
      assert((this || _global$y).negative === 0);
      return this.iushrn(bits, hint, extended);
    }; // Shift-left


    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };

    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    }; // Shift-right


    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };

    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    }; // Test if n bit is set


    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if ((this || _global$y).length <= s) return false; // Check bit and return

      var w = (this || _global$y).words[s];
      return !!(w & q);
    }; // Return only lowers bits of number (in-place)


    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert((this || _global$y).negative === 0, "imaskn works only with positive numbers");

      if ((this || _global$y).length <= s) {
        return this || _global$y;
      }

      if (r !== 0) {
        s++;
      }

      (this || _global$y).length = Math.min(s, (this || _global$y).length);

      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        (this || _global$y).words[(this || _global$y).length - 1] &= mask;
      }

      return this.strip();
    }; // Return only lowers bits of number


    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    }; // Add plain number `num` to `this`


    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0) return this.isubn(-num); // Possible sign change

      if ((this || _global$y).negative !== 0) {
        if ((this || _global$y).length === 1 && ((this || _global$y).words[0] | 0) < num) {
          (this || _global$y).words[0] = num - ((this || _global$y).words[0] | 0);
          (this || _global$y).negative = 0;
          return this || _global$y;
        }

        (this || _global$y).negative = 0;
        this.isubn(num);
        (this || _global$y).negative = 1;
        return this || _global$y;
      } // Add without checks


      return this._iaddn(num);
    };

    BN.prototype._iaddn = function _iaddn(num) {
      (this || _global$y).words[0] += num; // Carry

      for (var i = 0; i < (this || _global$y).length && (this || _global$y).words[i] >= 67108864; i++) {
        (this || _global$y).words[i] -= 67108864;

        if (i === (this || _global$y).length - 1) {
          (this || _global$y).words[i + 1] = 1;
        } else {
          (this || _global$y).words[i + 1]++;
        }
      }

      (this || _global$y).length = Math.max((this || _global$y).length, i + 1);
      return this || _global$y;
    }; // Subtract plain number `num` from `this`


    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0) return this.iaddn(-num);

      if ((this || _global$y).negative !== 0) {
        (this || _global$y).negative = 0;
        this.iaddn(num);
        (this || _global$y).negative = 1;
        return this || _global$y;
      }

      (this || _global$y).words[0] -= num;

      if ((this || _global$y).length === 1 && (this || _global$y).words[0] < 0) {
        (this || _global$y).words[0] = -(this || _global$y).words[0];
        (this || _global$y).negative = 1;
      } else {
        // Carry
        for (var i = 0; i < (this || _global$y).length && (this || _global$y).words[i] < 0; i++) {
          (this || _global$y).words[i] += 67108864;
          (this || _global$y).words[i + 1] -= 1;
        }
      }

      return this.strip();
    };

    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };

    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };

    BN.prototype.iabs = function iabs() {
      (this || _global$y).negative = 0;
      return this || _global$y;
    };

    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };

    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;

      this._expand(len);

      var w;
      var carry = 0;

      for (i = 0; i < num.length; i++) {
        w = ((this || _global$y).words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        (this || _global$y).words[i + shift] = w & 67108863;
      }

      for (; i < (this || _global$y).length - shift; i++) {
        w = ((this || _global$y).words[i + shift] | 0) + carry;
        carry = w >> 26;
        (this || _global$y).words[i + shift] = w & 67108863;
      }

      if (carry === 0) return this.strip(); // Subtraction overflow

      assert(carry === -1);
      carry = 0;

      for (i = 0; i < (this || _global$y).length; i++) {
        w = -((this || _global$y).words[i] | 0) + carry;
        carry = w >> 26;
        (this || _global$y).words[i] = w & 67108863;
      }

      (this || _global$y).negative = 1;
      return this.strip();
    };

    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = (this || _global$y).length - num.length;
      var a = this.clone();
      var b = num; // Normalize

      var bhi = b.words[b.length - 1] | 0;

      var bhiBits = this._countBits(bhi);

      shift = 26 - bhiBits;

      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      } // Initialize quotient


      var m = a.length - b.length;
      var q;

      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);

        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }

      var diff = a.clone()._ishlnsubmul(b, 1, m);

      if (diff.negative === 0) {
        a = diff;

        if (q) {
          q.words[m] = 1;
        }
      }

      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
        // (0x7ffffff)

        qj = Math.min(qj / bhi | 0, 67108863);

        a._ishlnsubmul(b, qj, j);

        while (a.negative !== 0) {
          qj--;
          a.negative = 0;

          a._ishlnsubmul(b, 1, j);

          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }

        if (q) {
          q.words[j] = qj;
        }
      }

      if (q) {
        q.strip();
      }

      a.strip(); // Denormalize

      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }

      return {
        div: q || null,
        mod: a
      };
    }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested


    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());

      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }

      var div, mod, res;

      if ((this || _global$y).negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);

        if (mode !== "mod") {
          div = res.div.neg();
        }

        if (mode !== "div") {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }

        return {
          div: div,
          mod: mod
        };
      }

      if ((this || _global$y).negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);

        if (mode !== "mod") {
          div = res.div.neg();
        }

        return {
          div: div,
          mod: res.mod
        };
      }

      if (((this || _global$y).negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);

        if (mode !== "div") {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }

        return {
          div: res.div,
          mod: mod
        };
      } // Both numbers are positive at this point
      // Strip both numbers to approximate shift value


      if (num.length > (this || _global$y).length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this || _global$y
        };
      } // Very short reduction


      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }

        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }

        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return this._wordDiv(num, mode);
    }; // Find `this` / `num`


    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    }; // Find `this` % `num`


    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };

    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    }; // Find Round(`this` / `num`)


    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num); // Fast case - exact division

      if (dm.mod.isZero()) return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half); // Round down

      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };

    BN.prototype.modn = function modn(num) {
      assert(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;

      for (var i = (this || _global$y).length - 1; i >= 0; i--) {
        acc = (p * acc + ((this || _global$y).words[i] | 0)) % num;
      }

      return acc;
    }; // In-place division by number


    BN.prototype.idivn = function idivn(num) {
      assert(num <= 67108863);
      var carry = 0;

      for (var i = (this || _global$y).length - 1; i >= 0; i--) {
        var w = ((this || _global$y).words[i] | 0) + carry * 67108864;
        (this || _global$y).words[i] = w / num | 0;
        carry = w % num;
      }

      return this.strip();
    };

    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };

    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this || _global$y;
      var y = p.clone();

      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      } // A * x + B * y = x


      var A = new BN(1);
      var B = new BN(0); // C * x + D * y = y

      var C = new BN(0);
      var D = new BN(1);
      var g = 0;

      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }

      var yp = y.clone();
      var xp = x.clone();

      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

        if (i > 0) {
          x.iushrn(i);

          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }

            A.iushrn(1);
            B.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

        if (j > 0) {
          y.iushrn(j);

          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }

            C.iushrn(1);
            D.iushrn(1);
          }
        }

        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }

      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    }; // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed


    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this || _global$y;
      var b = p.clone();

      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }

      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();

      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

        if (i > 0) {
          a.iushrn(i);

          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }

            x1.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

        if (j > 0) {
          b.iushrn(j);

          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }

            x2.iushrn(1);
          }
        }

        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }

      var res;

      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }

      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }

      return res;
    };

    BN.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0; // Remove common factor of two

      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }

      do {
        while (a.isEven()) {
          a.iushrn(1);
        }

        while (b.isEven()) {
          b.iushrn(1);
        }

        var r = a.cmp(b);

        if (r < 0) {
          // Swap `a` and `b` to make `a` always bigger than `b`
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }

        a.isub(b);
      } while (true);

      return b.iushln(shift);
    }; // Invert number in the field F(num)


    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };

    BN.prototype.isEven = function isEven() {
      return ((this || _global$y).words[0] & 1) === 0;
    };

    BN.prototype.isOdd = function isOdd() {
      return ((this || _global$y).words[0] & 1) === 1;
    }; // And first word and num


    BN.prototype.andln = function andln(num) {
      return (this || _global$y).words[0] & num;
    }; // Increment at the bit position in-line


    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if ((this || _global$y).length <= s) {
        this._expand(s + 1);

        (this || _global$y).words[s] |= q;
        return this || _global$y;
      } // Add bit and propagate, if needed


      var carry = q;

      for (var i = s; carry !== 0 && i < (this || _global$y).length; i++) {
        var w = (this || _global$y).words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        (this || _global$y).words[i] = w;
      }

      if (carry !== 0) {
        (this || _global$y).words[i] = carry;
        (this || _global$y).length++;
      }

      return this || _global$y;
    };

    BN.prototype.isZero = function isZero() {
      return (this || _global$y).length === 1 && (this || _global$y).words[0] === 0;
    };

    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if ((this || _global$y).negative !== 0 && !negative) return -1;
      if ((this || _global$y).negative === 0 && negative) return 1;
      this.strip();
      var res;

      if ((this || _global$y).length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }

        assert(num <= 67108863, "Number is too big");
        var w = (this || _global$y).words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }

      if ((this || _global$y).negative !== 0) return -res | 0;
      return res;
    }; // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`


    BN.prototype.cmp = function cmp(num) {
      if ((this || _global$y).negative !== 0 && num.negative === 0) return -1;
      if ((this || _global$y).negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if ((this || _global$y).negative !== 0) return -res | 0;
      return res;
    }; // Unsigned comparison


    BN.prototype.ucmp = function ucmp(num) {
      // At this point both numbers have the same sign
      if ((this || _global$y).length > num.length) return 1;
      if ((this || _global$y).length < num.length) return -1;
      var res = 0;

      for (var i = (this || _global$y).length - 1; i >= 0; i--) {
        var a = (this || _global$y).words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;

        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }

        break;
      }

      return res;
    };

    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };

    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };

    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };

    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };

    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };

    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };

    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };

    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };

    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };

    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    }; //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //


    BN.red = function red(num) {
      return new Red(num);
    };

    BN.prototype.toRed = function toRed(ctx) {
      assert(!(this || _global$y).red, "Already a number in reduction context");
      assert((this || _global$y).negative === 0, "red works only with positives");
      return ctx.convertTo(this || _global$y)._forceRed(ctx);
    };

    BN.prototype.fromRed = function fromRed() {
      assert((this || _global$y).red, "fromRed works only with numbers in reduction context");
      return (this || _global$y).red.convertFrom(this || _global$y);
    };

    BN.prototype._forceRed = function _forceRed(ctx) {
      (this || _global$y).red = ctx;
      return this || _global$y;
    };

    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!(this || _global$y).red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };

    BN.prototype.redAdd = function redAdd(num) {
      assert((this || _global$y).red, "redAdd works only with red numbers");
      return (this || _global$y).red.add(this || _global$y, num);
    };

    BN.prototype.redIAdd = function redIAdd(num) {
      assert((this || _global$y).red, "redIAdd works only with red numbers");
      return (this || _global$y).red.iadd(this || _global$y, num);
    };

    BN.prototype.redSub = function redSub(num) {
      assert((this || _global$y).red, "redSub works only with red numbers");
      return (this || _global$y).red.sub(this || _global$y, num);
    };

    BN.prototype.redISub = function redISub(num) {
      assert((this || _global$y).red, "redISub works only with red numbers");
      return (this || _global$y).red.isub(this || _global$y, num);
    };

    BN.prototype.redShl = function redShl(num) {
      assert((this || _global$y).red, "redShl works only with red numbers");
      return (this || _global$y).red.shl(this || _global$y, num);
    };

    BN.prototype.redMul = function redMul(num) {
      assert((this || _global$y).red, "redMul works only with red numbers");

      (this || _global$y).red._verify2(this || _global$y, num);

      return (this || _global$y).red.mul(this || _global$y, num);
    };

    BN.prototype.redIMul = function redIMul(num) {
      assert((this || _global$y).red, "redMul works only with red numbers");

      (this || _global$y).red._verify2(this || _global$y, num);

      return (this || _global$y).red.imul(this || _global$y, num);
    };

    BN.prototype.redSqr = function redSqr() {
      assert((this || _global$y).red, "redSqr works only with red numbers");

      (this || _global$y).red._verify1(this || _global$y);

      return (this || _global$y).red.sqr(this || _global$y);
    };

    BN.prototype.redISqr = function redISqr() {
      assert((this || _global$y).red, "redISqr works only with red numbers");

      (this || _global$y).red._verify1(this || _global$y);

      return (this || _global$y).red.isqr(this || _global$y);
    }; // Square root over p


    BN.prototype.redSqrt = function redSqrt() {
      assert((this || _global$y).red, "redSqrt works only with red numbers");

      (this || _global$y).red._verify1(this || _global$y);

      return (this || _global$y).red.sqrt(this || _global$y);
    };

    BN.prototype.redInvm = function redInvm() {
      assert((this || _global$y).red, "redInvm works only with red numbers");

      (this || _global$y).red._verify1(this || _global$y);

      return (this || _global$y).red.invm(this || _global$y);
    }; // Return negative clone of `this` % `red modulo`


    BN.prototype.redNeg = function redNeg() {
      assert((this || _global$y).red, "redNeg works only with red numbers");

      (this || _global$y).red._verify1(this || _global$y);

      return (this || _global$y).red.neg(this || _global$y);
    };

    BN.prototype.redPow = function redPow(num) {
      assert((this || _global$y).red && !num.red, "redPow(normalNum)");

      (this || _global$y).red._verify1(this || _global$y);

      return (this || _global$y).red.pow(this || _global$y, num);
    }; // Prime numbers with efficient reduction


    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    }; // Pseudo-Mersenne prime

    function MPrime(name, p) {
      // P = 2 ^ N - K
      (this || _global$y).name = name;
      (this || _global$y).p = new BN(p, 16);
      (this || _global$y).n = (this || _global$y).p.bitLength();
      (this || _global$y).k = new BN(1).iushln((this || _global$y).n).isub((this || _global$y).p);
      (this || _global$y).tmp = this._tmp();
    }

    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil((this || _global$y).n / 13));
      return tmp;
    };

    MPrime.prototype.ireduce = function ireduce(num) {
      // Assumes that `num` is less than `P^2`
      // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
      var r = num;
      var rlen;

      do {
        this.split(r, (this || _global$y).tmp);
        r = this.imulK(r);
        r = r.iadd((this || _global$y).tmp);
        rlen = r.bitLength();
      } while (rlen > (this || _global$y).n);

      var cmp = rlen < (this || _global$y).n ? -1 : r.ucmp((this || _global$y).p);

      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub((this || _global$y).p);
      } else {
        if (r.strip !== undefined) {
          // r is BN v4 instance
          r.strip();
        } else {
          // r is BN v5 instance
          r._strip();
        }
      }

      return r;
    };

    MPrime.prototype.split = function split(input, out) {
      input.iushrn((this || _global$y).n, 0, out);
    };

    MPrime.prototype.imulK = function imulK(num) {
      return num.imul((this || _global$y).k);
    };

    function K256() {
      MPrime.call(this || _global$y, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }

    inherits(K256, MPrime);

    K256.prototype.split = function split(input, output) {
      // 256 = 9 * 26 + 22
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);

      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }

      output.length = outLen;

      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      } // Shift by 9 limbs


      var prev = input.words[9];
      output.words[output.length++] = prev & mask;

      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }

      prev >>>= 22;
      input.words[i - 10] = prev;

      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };

    K256.prototype.imulK = function imulK(num) {
      // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

      var lo = 0;

      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      } // Fast length reduction


      if (num.words[num.length - 1] === 0) {
        num.length--;

        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }

      return num;
    };

    function P224() {
      MPrime.call(this || _global$y, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }

    inherits(P224, MPrime);

    function P192() {
      MPrime.call(this || _global$y, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }

    inherits(P192, MPrime);

    function P25519() {
      // 2 ^ 255 - 19
      MPrime.call(this || _global$y, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }

    inherits(P25519, MPrime);

    P25519.prototype.imulK = function imulK(num) {
      // K = 0x13
      var carry = 0;

      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }

      if (carry !== 0) {
        num.words[num.length++] = carry;
      }

      return num;
    }; // Exported mostly for testing purposes, use plain name instead


    BN._prime = function prime(name) {
      // Cached version of prime
      if (primes[name]) return primes[name];
      var prime;

      if (name === "k256") {
        prime = new K256();
      } else if (name === "p224") {
        prime = new P224();
      } else if (name === "p192") {
        prime = new P192();
      } else if (name === "p25519") {
        prime = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }

      primes[name] = prime;
      return prime;
    }; //
    // Base reduction engine
    //


    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);

        (this || _global$y).m = prime.p;
        (this || _global$y).prime = prime;
      } else {
        assert(m.gtn(1), "modulus must be greater than 1");
        (this || _global$y).m = m;
        (this || _global$y).prime = null;
      }
    }

    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, "red works only with positives");
      assert(a.red, "red works only with red numbers");
    };

    Red.prototype._verify2 = function _verify2(a, b) {
      assert((a.negative | b.negative) === 0, "red works only with positives");
      assert(a.red && a.red === b.red, "red works only with red numbers");
    };

    Red.prototype.imod = function imod(a) {
      if ((this || _global$y).prime) return (this || _global$y).prime.ireduce(a)._forceRed(this || _global$y);
      return a.umod((this || _global$y).m)._forceRed(this || _global$y);
    };

    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }

      return (this || _global$y).m.sub(a)._forceRed(this || _global$y);
    };

    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);

      var res = a.add(b);

      if (res.cmp((this || _global$y).m) >= 0) {
        res.isub((this || _global$y).m);
      }

      return res._forceRed(this || _global$y);
    };

    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);

      var res = a.iadd(b);

      if (res.cmp((this || _global$y).m) >= 0) {
        res.isub((this || _global$y).m);
      }

      return res;
    };

    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);

      var res = a.sub(b);

      if (res.cmpn(0) < 0) {
        res.iadd((this || _global$y).m);
      }

      return res._forceRed(this || _global$y);
    };

    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);

      var res = a.isub(b);

      if (res.cmpn(0) < 0) {
        res.iadd((this || _global$y).m);
      }

      return res;
    };

    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);

      return this.imod(a.ushln(num));
    };

    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);

      return this.imod(a.imul(b));
    };

    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);

      return this.imod(a.mul(b));
    };

    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };

    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };

    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero()) return a.clone();

      var mod3 = (this || _global$y).m.andln(3);

      assert(mod3 % 2 === 1); // Fast case

      if (mod3 === 3) {
        var pow = (this || _global$y).m.add(new BN(1)).iushrn(2);

        return this.pow(a, pow);
      } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
      //
      // Find Q and S, that Q * 2 ^ S = (P - 1)


      var q = (this || _global$y).m.subn(1);

      var s = 0;

      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }

      assert(!q.isZero());
      var one = new BN(1).toRed(this || _global$y);
      var nOne = one.redNeg(); // Find quadratic non-residue
      // NOTE: Max is such because of generalized Riemann hypothesis.

      var lpow = (this || _global$y).m.subn(1).iushrn(1);

      var z = (this || _global$y).m.bitLength();

      z = new BN(2 * z * z).toRed(this || _global$y);

      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }

      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;

      while (t.cmp(one) !== 0) {
        var tmp = t;

        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }

        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }

      return r;
    };

    Red.prototype.invm = function invm(a) {
      var inv = a._invmp((this || _global$y).m);

      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };

    Red.prototype.pow = function pow(a, num) {
      if (num.isZero()) return new BN(1).toRed(this || _global$y);
      if (num.cmpn(1) === 0) return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this || _global$y);
      wnd[1] = a;

      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }

      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;

      if (start === 0) {
        start = 26;
      }

      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];

        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;

          if (res !== wnd[0]) {
            res = this.sqr(res);
          }

          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }

          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }

        start = 26;
      }

      return res;
    };

    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod((this || _global$y).m);
      return r === num ? r.clone() : r;
    };

    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    }; //
    // Montgomery method engine
    //


    BN.mont = function mont(num) {
      return new Mont(num);
    };

    function Mont(m) {
      Red.call(this || _global$y, m);
      (this || _global$y).shift = (this || _global$y).m.bitLength();

      if ((this || _global$y).shift % 26 !== 0) {
        (this || _global$y).shift += 26 - (this || _global$y).shift % 26;
      }

      (this || _global$y).r = new BN(1).iushln((this || _global$y).shift);
      (this || _global$y).r2 = this.imod((this || _global$y).r.sqr());
      (this || _global$y).rinv = (this || _global$y).r._invmp((this || _global$y).m);
      (this || _global$y).minv = (this || _global$y).rinv.mul((this || _global$y).r).isubn(1).div((this || _global$y).m);
      (this || _global$y).minv = (this || _global$y).minv.umod((this || _global$y).r);
      (this || _global$y).minv = (this || _global$y).r.sub((this || _global$y).minv);
    }

    inherits(Mont, Red);

    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln((this || _global$y).shift));
    };

    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul((this || _global$y).rinv));
      r.red = null;
      return r;
    };

    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }

      var t = a.imul(b);
      var c = t.maskn((this || _global$y).shift).mul((this || _global$y).minv).imaskn((this || _global$y).shift).mul((this || _global$y).m);
      var u = t.isub(c).iushrn((this || _global$y).shift);
      var res = u;

      if (u.cmp((this || _global$y).m) >= 0) {
        res = u.isub((this || _global$y).m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd((this || _global$y).m);
      }

      return res._forceRed(this || _global$y);
    };

    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this || _global$y);
      var t = a.mul(b);
      var c = t.maskn((this || _global$y).shift).mul((this || _global$y).minv).imaskn((this || _global$y).shift).mul((this || _global$y).m);
      var u = t.isub(c).iushrn((this || _global$y).shift);
      var res = u;

      if (u.cmp((this || _global$y).m) >= 0) {
        res = u.isub((this || _global$y).m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd((this || _global$y).m);
      }

      return res._forceRed(this || _global$y);
    };

    Mont.prototype.invm = function invm(a) {
      // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
      var res = this.imod(a._invmp((this || _global$y).m).mul((this || _global$y).r2));
      return res._forceRed(this || _global$y);
    };
  })(module$9, exports$1X);

  return module$9.exports;
}

var exports$1W = {},
    _dewExec$1V = false;
function dew$1V() {
  if (_dewExec$1V) return exports$1W;
  _dewExec$1V = true;
  exports$1W = exports$1W = dew$3$2();
  exports$1W.Stream = exports$1W;
  exports$1W.Readable = exports$1W;
  exports$1W.Writable = dew$8$2();
  exports$1W.Duplex = dew$7$2();
  exports$1W.Transform = dew$2$2();
  exports$1W.PassThrough = dew$1$2();
  exports$1W.finished = dew$6$2();
  exports$1W.pipeline = dew$2B();
  return exports$1W;
}

var exports$1U = {},
    _dewExec$1T = false;
function dew$1T() {
  if (_dewExec$1T) return exports$1U;
  _dewExec$1T = true;

  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

  /* eslint-disable node/no-deprecated-api */
  var buffer = e$1$1$1;
  var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }

  if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    exports$1U = buffer;
  } else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports$1U);
    exports$1U.Buffer = SafeBuffer;
  }

  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
  }

  SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

  copyProps(Buffer, SafeBuffer);

  SafeBuffer.from = function (arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }

    return Buffer(arg, encodingOrOffset, length);
  };

  SafeBuffer.alloc = function (size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    var buf = Buffer(size);

    if (fill !== undefined) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }

    return buf;
  };

  SafeBuffer.allocUnsafe = function (size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    return Buffer(size);
  };

  SafeBuffer.allocUnsafeSlow = function (size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }

    return buffer.SlowBuffer(size);
  };

  return exports$1U;
}

var exports$1T = {},
    _dewExec$1S = false;

var _global$w = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1S() {
  if (_dewExec$1S) return exports$1T;
  _dewExec$1S = true;
  var process = T$9;
  // limit of Crypto.getRandomValues()
  // https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
  var MAX_BYTES = 65536; // Node supports requesting up to this number of bytes
  // https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48

  var MAX_UINT32 = 4294967295;

  function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
  }

  var Buffer = dew$1T().Buffer;

  var crypto = _global$w.crypto || _global$w.msCrypto;

  if (crypto && crypto.getRandomValues) {
    exports$1T = randomBytes;
  } else {
    exports$1T = oldBrowser;
  }

  function randomBytes(size, cb) {
    // phantomjs needs to throw
    if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
    var bytes = Buffer.allocUnsafe(size);

    if (size > 0) {
      // getRandomValues fails on IE if size == 0
      if (size > MAX_BYTES) {
        // this is the max bytes crypto.getRandomValues
        // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
        for (var generated = 0; generated < size; generated += MAX_BYTES) {
          // buffer.slice automatically checks if the end is past the end of
          // the buffer so we don't have to here
          crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
        }
      } else {
        crypto.getRandomValues(bytes);
      }
    }

    if (typeof cb === "function") {
      return process.nextTick(function () {
        cb(null, bytes);
      });
    }

    return bytes;
  }

  return exports$1T;
}

var exports$1S = {},
    _dewExec$1R = false;
function dew$1R() {
  if (_dewExec$1R) return exports$1S;
  _dewExec$1R = true;

  var Buffer = dew$1T().Buffer;

  var Transform = dew$1V().Transform;

  var inherits = dew$f$2();

  function throwIfNotStringOrBuffer(val, prefix) {
    if (!Buffer.isBuffer(val) && typeof val !== "string") {
      throw new TypeError(prefix + " must be a string or a buffer");
    }
  }

  function HashBase(blockSize) {
    Transform.call(this);
    this._block = Buffer.allocUnsafe(blockSize);
    this._blockSize = blockSize;
    this._blockOffset = 0;
    this._length = [0, 0, 0, 0];
    this._finalized = false;
  }

  inherits(HashBase, Transform);

  HashBase.prototype._transform = function (chunk, encoding, callback) {
    var error = null;

    try {
      this.update(chunk, encoding);
    } catch (err) {
      error = err;
    }

    callback(error);
  };

  HashBase.prototype._flush = function (callback) {
    var error = null;

    try {
      this.push(this.digest());
    } catch (err) {
      error = err;
    }

    callback(error);
  };

  HashBase.prototype.update = function (data, encoding) {
    throwIfNotStringOrBuffer(data, "Data");
    if (this._finalized) throw new Error("Digest already called");
    if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding); // consume data

    var block = this._block;
    var offset = 0;

    while (this._blockOffset + data.length - offset >= this._blockSize) {
      for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];

      this._update();

      this._blockOffset = 0;
    }

    while (offset < data.length) block[this._blockOffset++] = data[offset++]; // update length


    for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
      this._length[j] += carry;
      carry = this._length[j] / 4294967296 | 0;
      if (carry > 0) this._length[j] -= 4294967296 * carry;
    }

    return this;
  };

  HashBase.prototype._update = function () {
    throw new Error("_update is not implemented");
  };

  HashBase.prototype.digest = function (encoding) {
    if (this._finalized) throw new Error("Digest already called");
    this._finalized = true;

    var digest = this._digest();

    if (encoding !== undefined) digest = digest.toString(encoding); // reset state

    this._block.fill(0);

    this._blockOffset = 0;

    for (var i = 0; i < 4; ++i) this._length[i] = 0;

    return digest;
  };

  HashBase.prototype._digest = function () {
    throw new Error("_digest is not implemented");
  };

  exports$1S = HashBase;
  return exports$1S;
}

var exports$1R = {},
    _dewExec$1Q = false;
function dew$1Q() {
  if (_dewExec$1Q) return exports$1R;
  _dewExec$1Q = true;

  var inherits = dew$f$2();

  var HashBase = dew$1R();

  var Buffer = dew$1T().Buffer;

  var ARRAY16 = new Array(16);

  function MD5() {
    HashBase.call(this, 64); // state

    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
  }

  inherits(MD5, HashBase);

  MD5.prototype._update = function () {
    var M = ARRAY16;

    for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

    var a = this._a;
    var b = this._b;
    var c = this._c;
    var d = this._d;
    a = fnF(a, b, c, d, M[0], 3614090360, 7);
    d = fnF(d, a, b, c, M[1], 3905402710, 12);
    c = fnF(c, d, a, b, M[2], 606105819, 17);
    b = fnF(b, c, d, a, M[3], 3250441966, 22);
    a = fnF(a, b, c, d, M[4], 4118548399, 7);
    d = fnF(d, a, b, c, M[5], 1200080426, 12);
    c = fnF(c, d, a, b, M[6], 2821735955, 17);
    b = fnF(b, c, d, a, M[7], 4249261313, 22);
    a = fnF(a, b, c, d, M[8], 1770035416, 7);
    d = fnF(d, a, b, c, M[9], 2336552879, 12);
    c = fnF(c, d, a, b, M[10], 4294925233, 17);
    b = fnF(b, c, d, a, M[11], 2304563134, 22);
    a = fnF(a, b, c, d, M[12], 1804603682, 7);
    d = fnF(d, a, b, c, M[13], 4254626195, 12);
    c = fnF(c, d, a, b, M[14], 2792965006, 17);
    b = fnF(b, c, d, a, M[15], 1236535329, 22);
    a = fnG(a, b, c, d, M[1], 4129170786, 5);
    d = fnG(d, a, b, c, M[6], 3225465664, 9);
    c = fnG(c, d, a, b, M[11], 643717713, 14);
    b = fnG(b, c, d, a, M[0], 3921069994, 20);
    a = fnG(a, b, c, d, M[5], 3593408605, 5);
    d = fnG(d, a, b, c, M[10], 38016083, 9);
    c = fnG(c, d, a, b, M[15], 3634488961, 14);
    b = fnG(b, c, d, a, M[4], 3889429448, 20);
    a = fnG(a, b, c, d, M[9], 568446438, 5);
    d = fnG(d, a, b, c, M[14], 3275163606, 9);
    c = fnG(c, d, a, b, M[3], 4107603335, 14);
    b = fnG(b, c, d, a, M[8], 1163531501, 20);
    a = fnG(a, b, c, d, M[13], 2850285829, 5);
    d = fnG(d, a, b, c, M[2], 4243563512, 9);
    c = fnG(c, d, a, b, M[7], 1735328473, 14);
    b = fnG(b, c, d, a, M[12], 2368359562, 20);
    a = fnH(a, b, c, d, M[5], 4294588738, 4);
    d = fnH(d, a, b, c, M[8], 2272392833, 11);
    c = fnH(c, d, a, b, M[11], 1839030562, 16);
    b = fnH(b, c, d, a, M[14], 4259657740, 23);
    a = fnH(a, b, c, d, M[1], 2763975236, 4);
    d = fnH(d, a, b, c, M[4], 1272893353, 11);
    c = fnH(c, d, a, b, M[7], 4139469664, 16);
    b = fnH(b, c, d, a, M[10], 3200236656, 23);
    a = fnH(a, b, c, d, M[13], 681279174, 4);
    d = fnH(d, a, b, c, M[0], 3936430074, 11);
    c = fnH(c, d, a, b, M[3], 3572445317, 16);
    b = fnH(b, c, d, a, M[6], 76029189, 23);
    a = fnH(a, b, c, d, M[9], 3654602809, 4);
    d = fnH(d, a, b, c, M[12], 3873151461, 11);
    c = fnH(c, d, a, b, M[15], 530742520, 16);
    b = fnH(b, c, d, a, M[2], 3299628645, 23);
    a = fnI(a, b, c, d, M[0], 4096336452, 6);
    d = fnI(d, a, b, c, M[7], 1126891415, 10);
    c = fnI(c, d, a, b, M[14], 2878612391, 15);
    b = fnI(b, c, d, a, M[5], 4237533241, 21);
    a = fnI(a, b, c, d, M[12], 1700485571, 6);
    d = fnI(d, a, b, c, M[3], 2399980690, 10);
    c = fnI(c, d, a, b, M[10], 4293915773, 15);
    b = fnI(b, c, d, a, M[1], 2240044497, 21);
    a = fnI(a, b, c, d, M[8], 1873313359, 6);
    d = fnI(d, a, b, c, M[15], 4264355552, 10);
    c = fnI(c, d, a, b, M[6], 2734768916, 15);
    b = fnI(b, c, d, a, M[13], 1309151649, 21);
    a = fnI(a, b, c, d, M[4], 4149444226, 6);
    d = fnI(d, a, b, c, M[11], 3174756917, 10);
    c = fnI(c, d, a, b, M[2], 718787259, 15);
    b = fnI(b, c, d, a, M[9], 3951481745, 21);
    this._a = this._a + a | 0;
    this._b = this._b + b | 0;
    this._c = this._c + c | 0;
    this._d = this._d + d | 0;
  };

  MD5.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 128;

    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);

      this._update();

      this._blockOffset = 0;
    }

    this._block.fill(0, this._blockOffset, 56);

    this._block.writeUInt32LE(this._length[0], 56);

    this._block.writeUInt32LE(this._length[1], 60);

    this._update(); // produce result


    var buffer = Buffer.allocUnsafe(16);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    return buffer;
  };

  function rotl(x, n) {
    return x << n | x >>> 32 - n;
  }

  function fnF(a, b, c, d, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + b | 0;
  }

  function fnG(a, b, c, d, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + b | 0;
  }

  function fnH(a, b, c, d, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + b | 0;
  }

  function fnI(a, b, c, d, m, k, s) {
    return rotl(a + (c ^ (b | ~d)) + m + k | 0, s) + b | 0;
  }

  exports$1R = MD5;
  return exports$1R;
}

var exports$1Q = {},
    _dewExec$1P = false;
function dew$1P() {
  if (_dewExec$1P) return exports$1Q;
  _dewExec$1P = true;
  var Buffer = e$1$1$1.Buffer;

  var inherits = dew$f$2();

  var HashBase = dew$1R();

  var ARRAY16 = new Array(16);
  var zl = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
  var zr = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
  var sl = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
  var sr = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
  var hl = [0, 1518500249, 1859775393, 2400959708, 2840853838];
  var hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];

  function RIPEMD160() {
    HashBase.call(this, 64); // state

    this._a = 1732584193;
    this._b = 4023233417;
    this._c = 2562383102;
    this._d = 271733878;
    this._e = 3285377520;
  }

  inherits(RIPEMD160, HashBase);

  RIPEMD160.prototype._update = function () {
    var words = ARRAY16;

    for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

    var al = this._a | 0;
    var bl = this._b | 0;
    var cl = this._c | 0;
    var dl = this._d | 0;
    var el = this._e | 0;
    var ar = this._a | 0;
    var br = this._b | 0;
    var cr = this._c | 0;
    var dr = this._d | 0;
    var er = this._e | 0; // computation

    for (var i = 0; i < 80; i += 1) {
      var tl;
      var tr;

      if (i < 16) {
        tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
        tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
      } else if (i < 32) {
        tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
        tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
      } else if (i < 48) {
        tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
        tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
      } else if (i < 64) {
        tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
        tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
      } else {
        // if (i<80) {
        tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
        tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
      }

      al = el;
      el = dl;
      dl = rotl(cl, 10);
      cl = bl;
      bl = tl;
      ar = er;
      er = dr;
      dr = rotl(cr, 10);
      cr = br;
      br = tr;
    } // update state


    var t = this._b + cl + dr | 0;
    this._b = this._c + dl + er | 0;
    this._c = this._d + el + ar | 0;
    this._d = this._e + al + br | 0;
    this._e = this._a + bl + cr | 0;
    this._a = t;
  };

  RIPEMD160.prototype._digest = function () {
    // create padding and handle blocks
    this._block[this._blockOffset++] = 128;

    if (this._blockOffset > 56) {
      this._block.fill(0, this._blockOffset, 64);

      this._update();

      this._blockOffset = 0;
    }

    this._block.fill(0, this._blockOffset, 56);

    this._block.writeUInt32LE(this._length[0], 56);

    this._block.writeUInt32LE(this._length[1], 60);

    this._update(); // produce result


    var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
    buffer.writeInt32LE(this._a, 0);
    buffer.writeInt32LE(this._b, 4);
    buffer.writeInt32LE(this._c, 8);
    buffer.writeInt32LE(this._d, 12);
    buffer.writeInt32LE(this._e, 16);
    return buffer;
  };

  function rotl(x, n) {
    return x << n | x >>> 32 - n;
  }

  function fn1(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ c ^ d) + m + k | 0, s) + e | 0;
  }

  function fn2(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & c | ~b & d) + m + k | 0, s) + e | 0;
  }

  function fn3(a, b, c, d, e, m, k, s) {
    return rotl(a + ((b | ~c) ^ d) + m + k | 0, s) + e | 0;
  }

  function fn4(a, b, c, d, e, m, k, s) {
    return rotl(a + (b & d | c & ~d) + m + k | 0, s) + e | 0;
  }

  function fn5(a, b, c, d, e, m, k, s) {
    return rotl(a + (b ^ (c | ~d)) + m + k | 0, s) + e | 0;
  }

  exports$1Q = RIPEMD160;
  return exports$1Q;
}

var exports$1P = {},
    _dewExec$1O = false;

var _global$v = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1O() {
  if (_dewExec$1O) return exports$1P;
  _dewExec$1O = true;

  var Buffer = dew$1T().Buffer; // prototype class for hash functions


  function Hash(blockSize, finalSize) {
    (this || _global$v)._block = Buffer.alloc(blockSize);
    (this || _global$v)._finalSize = finalSize;
    (this || _global$v)._blockSize = blockSize;
    (this || _global$v)._len = 0;
  }

  Hash.prototype.update = function (data, enc) {
    if (typeof data === "string") {
      enc = enc || "utf8";
      data = Buffer.from(data, enc);
    }

    var block = (this || _global$v)._block;
    var blockSize = (this || _global$v)._blockSize;
    var length = data.length;
    var accum = (this || _global$v)._len;

    for (var offset = 0; offset < length;) {
      var assigned = accum % blockSize;
      var remainder = Math.min(length - offset, blockSize - assigned);

      for (var i = 0; i < remainder; i++) {
        block[assigned + i] = data[offset + i];
      }

      accum += remainder;
      offset += remainder;

      if (accum % blockSize === 0) {
        this._update(block);
      }
    }

    (this || _global$v)._len += length;
    return this || _global$v;
  };

  Hash.prototype.digest = function (enc) {
    var rem = (this || _global$v)._len % (this || _global$v)._blockSize;
    (this || _global$v)._block[rem] = 128; // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
    // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize

    (this || _global$v)._block.fill(0, rem + 1);

    if (rem >= (this || _global$v)._finalSize) {
      this._update((this || _global$v)._block);

      (this || _global$v)._block.fill(0);
    }

    var bits = (this || _global$v)._len * 8; // uint32

    if (bits <= 4294967295) {
      (this || _global$v)._block.writeUInt32BE(bits, (this || _global$v)._blockSize - 4); // uint64

    } else {
      var lowBits = (bits & 4294967295) >>> 0;
      var highBits = (bits - lowBits) / 4294967296;

      (this || _global$v)._block.writeUInt32BE(highBits, (this || _global$v)._blockSize - 8);

      (this || _global$v)._block.writeUInt32BE(lowBits, (this || _global$v)._blockSize - 4);
    }

    this._update((this || _global$v)._block);

    var hash = this._hash();

    return enc ? hash.toString(enc) : hash;
  };

  Hash.prototype._update = function () {
    throw new Error("_update must be implemented by subclass");
  };

  exports$1P = Hash;
  return exports$1P;
}

var exports$1O = {},
    _dewExec$1N = false;

var _global$u = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1N() {
  if (_dewExec$1N) return exports$1O;
  _dewExec$1N = true;

  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
   * in FIPS PUB 180-1
   * This source code is derived from sha1.js of the same repository.
   * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
   * operation was added.
   */
  var inherits = dew$f$2();

  var Hash = dew$1O();

  var Buffer = dew$1T().Buffer;

  var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
  var W = new Array(80);

  function Sha() {
    this.init();
    (this || _global$u)._w = W;
    Hash.call(this || _global$u, 64, 56);
  }

  inherits(Sha, Hash);

  Sha.prototype.init = function () {
    (this || _global$u)._a = 1732584193;
    (this || _global$u)._b = 4023233417;
    (this || _global$u)._c = 2562383102;
    (this || _global$u)._d = 271733878;
    (this || _global$u)._e = 3285377520;
    return this || _global$u;
  };

  function rotl5(num) {
    return num << 5 | num >>> 27;
  }

  function rotl30(num) {
    return num << 30 | num >>> 2;
  }

  function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }

  Sha.prototype._update = function (M) {
    var W = (this || _global$u)._w;
    var a = (this || _global$u)._a | 0;
    var b = (this || _global$u)._b | 0;
    var c = (this || _global$u)._c | 0;
    var d = (this || _global$u)._d | 0;
    var e = (this || _global$u)._e | 0;

    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

    for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }

    (this || _global$u)._a = a + (this || _global$u)._a | 0;
    (this || _global$u)._b = b + (this || _global$u)._b | 0;
    (this || _global$u)._c = c + (this || _global$u)._c | 0;
    (this || _global$u)._d = d + (this || _global$u)._d | 0;
    (this || _global$u)._e = e + (this || _global$u)._e | 0;
  };

  Sha.prototype._hash = function () {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE((this || _global$u)._a | 0, 0);
    H.writeInt32BE((this || _global$u)._b | 0, 4);
    H.writeInt32BE((this || _global$u)._c | 0, 8);
    H.writeInt32BE((this || _global$u)._d | 0, 12);
    H.writeInt32BE((this || _global$u)._e | 0, 16);
    return H;
  };

  exports$1O = Sha;
  return exports$1O;
}

var exports$1N = {},
    _dewExec$1M = false;

var _global$t = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1M() {
  if (_dewExec$1M) return exports$1N;
  _dewExec$1M = true;

  /*
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
   * in FIPS PUB 180-1
   * Version 2.1a Copyright Paul Johnston 2000 - 2002.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   * Distributed under the BSD License
   * See http://pajhome.org.uk/crypt/md5 for details.
   */
  var inherits = dew$f$2();

  var Hash = dew$1O();

  var Buffer = dew$1T().Buffer;

  var K = [1518500249, 1859775393, 2400959708 | 0, 3395469782 | 0];
  var W = new Array(80);

  function Sha1() {
    this.init();
    (this || _global$t)._w = W;
    Hash.call(this || _global$t, 64, 56);
  }

  inherits(Sha1, Hash);

  Sha1.prototype.init = function () {
    (this || _global$t)._a = 1732584193;
    (this || _global$t)._b = 4023233417;
    (this || _global$t)._c = 2562383102;
    (this || _global$t)._d = 271733878;
    (this || _global$t)._e = 3285377520;
    return this || _global$t;
  };

  function rotl1(num) {
    return num << 1 | num >>> 31;
  }

  function rotl5(num) {
    return num << 5 | num >>> 27;
  }

  function rotl30(num) {
    return num << 30 | num >>> 2;
  }

  function ft(s, b, c, d) {
    if (s === 0) return b & c | ~b & d;
    if (s === 2) return b & c | b & d | c & d;
    return b ^ c ^ d;
  }

  Sha1.prototype._update = function (M) {
    var W = (this || _global$t)._w;
    var a = (this || _global$t)._a | 0;
    var b = (this || _global$t)._b | 0;
    var c = (this || _global$t)._c | 0;
    var d = (this || _global$t)._d | 0;
    var e = (this || _global$t)._e | 0;

    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

    for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

    for (var j = 0; j < 80; ++j) {
      var s = ~~(j / 20);
      var t = rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s] | 0;
      e = d;
      d = c;
      c = rotl30(b);
      b = a;
      a = t;
    }

    (this || _global$t)._a = a + (this || _global$t)._a | 0;
    (this || _global$t)._b = b + (this || _global$t)._b | 0;
    (this || _global$t)._c = c + (this || _global$t)._c | 0;
    (this || _global$t)._d = d + (this || _global$t)._d | 0;
    (this || _global$t)._e = e + (this || _global$t)._e | 0;
  };

  Sha1.prototype._hash = function () {
    var H = Buffer.allocUnsafe(20);
    H.writeInt32BE((this || _global$t)._a | 0, 0);
    H.writeInt32BE((this || _global$t)._b | 0, 4);
    H.writeInt32BE((this || _global$t)._c | 0, 8);
    H.writeInt32BE((this || _global$t)._d | 0, 12);
    H.writeInt32BE((this || _global$t)._e | 0, 16);
    return H;
  };

  exports$1N = Sha1;
  return exports$1N;
}

var exports$1M = {},
    _dewExec$1L = false;

var _global$s = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1L() {
  if (_dewExec$1L) return exports$1M;
  _dewExec$1L = true;

  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */
  var inherits = dew$f$2();

  var Hash = dew$1O();

  var Buffer = dew$1T().Buffer;

  var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
  var W = new Array(64);

  function Sha256() {
    this.init();
    (this || _global$s)._w = W; // new Array(64)

    Hash.call(this || _global$s, 64, 56);
  }

  inherits(Sha256, Hash);

  Sha256.prototype.init = function () {
    (this || _global$s)._a = 1779033703;
    (this || _global$s)._b = 3144134277;
    (this || _global$s)._c = 1013904242;
    (this || _global$s)._d = 2773480762;
    (this || _global$s)._e = 1359893119;
    (this || _global$s)._f = 2600822924;
    (this || _global$s)._g = 528734635;
    (this || _global$s)._h = 1541459225;
    return this || _global$s;
  };

  function ch(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function maj(x, y, z) {
    return x & y | z & (x | y);
  }

  function sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }

  function sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }

  function gamma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }

  function gamma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }

  Sha256.prototype._update = function (M) {
    var W = (this || _global$s)._w;
    var a = (this || _global$s)._a | 0;
    var b = (this || _global$s)._b | 0;
    var c = (this || _global$s)._c | 0;
    var d = (this || _global$s)._d | 0;
    var e = (this || _global$s)._e | 0;
    var f = (this || _global$s)._f | 0;
    var g = (this || _global$s)._g | 0;
    var h = (this || _global$s)._h | 0;

    for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);

    for (; i < 64; ++i) W[i] = gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16] | 0;

    for (var j = 0; j < 64; ++j) {
      var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + W[j] | 0;
      var T2 = sigma0(a) + maj(a, b, c) | 0;
      h = g;
      g = f;
      f = e;
      e = d + T1 | 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 | 0;
    }

    (this || _global$s)._a = a + (this || _global$s)._a | 0;
    (this || _global$s)._b = b + (this || _global$s)._b | 0;
    (this || _global$s)._c = c + (this || _global$s)._c | 0;
    (this || _global$s)._d = d + (this || _global$s)._d | 0;
    (this || _global$s)._e = e + (this || _global$s)._e | 0;
    (this || _global$s)._f = f + (this || _global$s)._f | 0;
    (this || _global$s)._g = g + (this || _global$s)._g | 0;
    (this || _global$s)._h = h + (this || _global$s)._h | 0;
  };

  Sha256.prototype._hash = function () {
    var H = Buffer.allocUnsafe(32);
    H.writeInt32BE((this || _global$s)._a, 0);
    H.writeInt32BE((this || _global$s)._b, 4);
    H.writeInt32BE((this || _global$s)._c, 8);
    H.writeInt32BE((this || _global$s)._d, 12);
    H.writeInt32BE((this || _global$s)._e, 16);
    H.writeInt32BE((this || _global$s)._f, 20);
    H.writeInt32BE((this || _global$s)._g, 24);
    H.writeInt32BE((this || _global$s)._h, 28);
    return H;
  };

  exports$1M = Sha256;
  return exports$1M;
}

var exports$1L = {},
    _dewExec$1K = false;

var _global$r = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1K() {
  if (_dewExec$1K) return exports$1L;
  _dewExec$1K = true;

  /**
   * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
   * in FIPS 180-2
   * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
   * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
   *
   */
  var inherits = dew$f$2();

  var Sha256 = dew$1L();

  var Hash = dew$1O();

  var Buffer = dew$1T().Buffer;

  var W = new Array(64);

  function Sha224() {
    this.init();
    (this || _global$r)._w = W; // new Array(64)

    Hash.call(this || _global$r, 64, 56);
  }

  inherits(Sha224, Sha256);

  Sha224.prototype.init = function () {
    (this || _global$r)._a = 3238371032;
    (this || _global$r)._b = 914150663;
    (this || _global$r)._c = 812702999;
    (this || _global$r)._d = 4144912697;
    (this || _global$r)._e = 4290775857;
    (this || _global$r)._f = 1750603025;
    (this || _global$r)._g = 1694076839;
    (this || _global$r)._h = 3204075428;
    return this || _global$r;
  };

  Sha224.prototype._hash = function () {
    var H = Buffer.allocUnsafe(28);
    H.writeInt32BE((this || _global$r)._a, 0);
    H.writeInt32BE((this || _global$r)._b, 4);
    H.writeInt32BE((this || _global$r)._c, 8);
    H.writeInt32BE((this || _global$r)._d, 12);
    H.writeInt32BE((this || _global$r)._e, 16);
    H.writeInt32BE((this || _global$r)._f, 20);
    H.writeInt32BE((this || _global$r)._g, 24);
    return H;
  };

  exports$1L = Sha224;
  return exports$1L;
}

var exports$1K = {},
    _dewExec$1J = false;

var _global$q = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1J() {
  if (_dewExec$1J) return exports$1K;
  _dewExec$1J = true;

  var inherits = dew$f$2();

  var Hash = dew$1O();

  var Buffer = dew$1T().Buffer;

  var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
  var W = new Array(160);

  function Sha512() {
    this.init();
    (this || _global$q)._w = W;
    Hash.call(this || _global$q, 128, 112);
  }

  inherits(Sha512, Hash);

  Sha512.prototype.init = function () {
    (this || _global$q)._ah = 1779033703;
    (this || _global$q)._bh = 3144134277;
    (this || _global$q)._ch = 1013904242;
    (this || _global$q)._dh = 2773480762;
    (this || _global$q)._eh = 1359893119;
    (this || _global$q)._fh = 2600822924;
    (this || _global$q)._gh = 528734635;
    (this || _global$q)._hh = 1541459225;
    (this || _global$q)._al = 4089235720;
    (this || _global$q)._bl = 2227873595;
    (this || _global$q)._cl = 4271175723;
    (this || _global$q)._dl = 1595750129;
    (this || _global$q)._el = 2917565137;
    (this || _global$q)._fl = 725511199;
    (this || _global$q)._gl = 4215389547;
    (this || _global$q)._hl = 327033209;
    return this || _global$q;
  };

  function Ch(x, y, z) {
    return z ^ x & (y ^ z);
  }

  function maj(x, y, z) {
    return x & y | z & (x | y);
  }

  function sigma0(x, xl) {
    return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
  }

  function sigma1(x, xl) {
    return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
  }

  function Gamma0(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
  }

  function Gamma0l(x, xl) {
    return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
  }

  function Gamma1(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
  }

  function Gamma1l(x, xl) {
    return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
  }

  function getCarry(a, b) {
    return a >>> 0 < b >>> 0 ? 1 : 0;
  }

  Sha512.prototype._update = function (M) {
    var W = (this || _global$q)._w;
    var ah = (this || _global$q)._ah | 0;
    var bh = (this || _global$q)._bh | 0;
    var ch = (this || _global$q)._ch | 0;
    var dh = (this || _global$q)._dh | 0;
    var eh = (this || _global$q)._eh | 0;
    var fh = (this || _global$q)._fh | 0;
    var gh = (this || _global$q)._gh | 0;
    var hh = (this || _global$q)._hh | 0;
    var al = (this || _global$q)._al | 0;
    var bl = (this || _global$q)._bl | 0;
    var cl = (this || _global$q)._cl | 0;
    var dl = (this || _global$q)._dl | 0;
    var el = (this || _global$q)._el | 0;
    var fl = (this || _global$q)._fl | 0;
    var gl = (this || _global$q)._gl | 0;
    var hl = (this || _global$q)._hl | 0;

    for (var i = 0; i < 32; i += 2) {
      W[i] = M.readInt32BE(i * 4);
      W[i + 1] = M.readInt32BE(i * 4 + 4);
    }

    for (; i < 160; i += 2) {
      var xh = W[i - 15 * 2];
      var xl = W[i - 15 * 2 + 1];
      var gamma0 = Gamma0(xh, xl);
      var gamma0l = Gamma0l(xl, xh);
      xh = W[i - 2 * 2];
      xl = W[i - 2 * 2 + 1];
      var gamma1 = Gamma1(xh, xl);
      var gamma1l = Gamma1l(xl, xh); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

      var Wi7h = W[i - 7 * 2];
      var Wi7l = W[i - 7 * 2 + 1];
      var Wi16h = W[i - 16 * 2];
      var Wi16l = W[i - 16 * 2 + 1];
      var Wil = gamma0l + Wi7l | 0;
      var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
      Wil = Wil + gamma1l | 0;
      Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
      Wil = Wil + Wi16l | 0;
      Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
      W[i] = Wih;
      W[i + 1] = Wil;
    }

    for (var j = 0; j < 160; j += 2) {
      Wih = W[j];
      Wil = W[j + 1];
      var majh = maj(ah, bh, ch);
      var majl = maj(al, bl, cl);
      var sigma0h = sigma0(ah, al);
      var sigma0l = sigma0(al, ah);
      var sigma1h = sigma1(eh, el);
      var sigma1l = sigma1(el, eh); // t1 = h + sigma1 + ch + K[j] + W[j]

      var Kih = K[j];
      var Kil = K[j + 1];
      var chh = Ch(eh, fh, gh);
      var chl = Ch(el, fl, gl);
      var t1l = hl + sigma1l | 0;
      var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
      t1l = t1l + chl | 0;
      t1h = t1h + chh + getCarry(t1l, chl) | 0;
      t1l = t1l + Kil | 0;
      t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
      t1l = t1l + Wil | 0;
      t1h = t1h + Wih + getCarry(t1l, Wil) | 0; // t2 = sigma0 + maj

      var t2l = sigma0l + majl | 0;
      var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = dl + t1l | 0;
      eh = dh + t1h + getCarry(el, dl) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + getCarry(al, t1l) | 0;
    }

    (this || _global$q)._al = (this || _global$q)._al + al | 0;
    (this || _global$q)._bl = (this || _global$q)._bl + bl | 0;
    (this || _global$q)._cl = (this || _global$q)._cl + cl | 0;
    (this || _global$q)._dl = (this || _global$q)._dl + dl | 0;
    (this || _global$q)._el = (this || _global$q)._el + el | 0;
    (this || _global$q)._fl = (this || _global$q)._fl + fl | 0;
    (this || _global$q)._gl = (this || _global$q)._gl + gl | 0;
    (this || _global$q)._hl = (this || _global$q)._hl + hl | 0;
    (this || _global$q)._ah = (this || _global$q)._ah + ah + getCarry((this || _global$q)._al, al) | 0;
    (this || _global$q)._bh = (this || _global$q)._bh + bh + getCarry((this || _global$q)._bl, bl) | 0;
    (this || _global$q)._ch = (this || _global$q)._ch + ch + getCarry((this || _global$q)._cl, cl) | 0;
    (this || _global$q)._dh = (this || _global$q)._dh + dh + getCarry((this || _global$q)._dl, dl) | 0;
    (this || _global$q)._eh = (this || _global$q)._eh + eh + getCarry((this || _global$q)._el, el) | 0;
    (this || _global$q)._fh = (this || _global$q)._fh + fh + getCarry((this || _global$q)._fl, fl) | 0;
    (this || _global$q)._gh = (this || _global$q)._gh + gh + getCarry((this || _global$q)._gl, gl) | 0;
    (this || _global$q)._hh = (this || _global$q)._hh + hh + getCarry((this || _global$q)._hl, hl) | 0;
  };

  Sha512.prototype._hash = function () {
    var H = Buffer.allocUnsafe(64);

    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }

    writeInt64BE((this || _global$q)._ah, (this || _global$q)._al, 0);
    writeInt64BE((this || _global$q)._bh, (this || _global$q)._bl, 8);
    writeInt64BE((this || _global$q)._ch, (this || _global$q)._cl, 16);
    writeInt64BE((this || _global$q)._dh, (this || _global$q)._dl, 24);
    writeInt64BE((this || _global$q)._eh, (this || _global$q)._el, 32);
    writeInt64BE((this || _global$q)._fh, (this || _global$q)._fl, 40);
    writeInt64BE((this || _global$q)._gh, (this || _global$q)._gl, 48);
    writeInt64BE((this || _global$q)._hh, (this || _global$q)._hl, 56);
    return H;
  };

  exports$1K = Sha512;
  return exports$1K;
}

var exports$1J = {},
    _dewExec$1I = false;

var _global$p = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1I() {
  if (_dewExec$1I) return exports$1J;
  _dewExec$1I = true;

  var inherits = dew$f$2();

  var SHA512 = dew$1J();

  var Hash = dew$1O();

  var Buffer = dew$1T().Buffer;

  var W = new Array(160);

  function Sha384() {
    this.init();
    (this || _global$p)._w = W;
    Hash.call(this || _global$p, 128, 112);
  }

  inherits(Sha384, SHA512);

  Sha384.prototype.init = function () {
    (this || _global$p)._ah = 3418070365;
    (this || _global$p)._bh = 1654270250;
    (this || _global$p)._ch = 2438529370;
    (this || _global$p)._dh = 355462360;
    (this || _global$p)._eh = 1731405415;
    (this || _global$p)._fh = 2394180231;
    (this || _global$p)._gh = 3675008525;
    (this || _global$p)._hh = 1203062813;
    (this || _global$p)._al = 3238371032;
    (this || _global$p)._bl = 914150663;
    (this || _global$p)._cl = 812702999;
    (this || _global$p)._dl = 4144912697;
    (this || _global$p)._el = 4290775857;
    (this || _global$p)._fl = 1750603025;
    (this || _global$p)._gl = 1694076839;
    (this || _global$p)._hl = 3204075428;
    return this || _global$p;
  };

  Sha384.prototype._hash = function () {
    var H = Buffer.allocUnsafe(48);

    function writeInt64BE(h, l, offset) {
      H.writeInt32BE(h, offset);
      H.writeInt32BE(l, offset + 4);
    }

    writeInt64BE((this || _global$p)._ah, (this || _global$p)._al, 0);
    writeInt64BE((this || _global$p)._bh, (this || _global$p)._bl, 8);
    writeInt64BE((this || _global$p)._ch, (this || _global$p)._cl, 16);
    writeInt64BE((this || _global$p)._dh, (this || _global$p)._dl, 24);
    writeInt64BE((this || _global$p)._eh, (this || _global$p)._el, 32);
    writeInt64BE((this || _global$p)._fh, (this || _global$p)._fl, 40);
    return H;
  };

  exports$1J = Sha384;
  return exports$1J;
}

var exports$1I = {},
    _dewExec$1H = false;
var module$7 = {
  exports: exports$1I
};
function dew$1H() {
  if (_dewExec$1H) return module$7.exports;
  _dewExec$1H = true;

  var exports = module$7.exports = function SHA(algorithm) {
    algorithm = algorithm.toLowerCase();
    var Algorithm = exports[algorithm];
    if (!Algorithm) throw new Error(algorithm + " is not supported (we accept pull requests)");
    return new Algorithm();
  };

  exports.sha = dew$1N();
  exports.sha1 = dew$1M();
  exports.sha224 = dew$1K();
  exports.sha256 = dew$1L();
  exports.sha384 = dew$1I();
  exports.sha512 = dew$1J();
  return module$7.exports;
}

var e$g=y$o.EventEmitter;var e$1$1={};const t$c={};function n$q(e,n,r){r||(r=Error);class o extends r{constructor(e,t,r){super(function(e,t,r){return "string"==typeof n?n:n(e,t,r)}(e,t,r));}}o.prototype.name=r.name,o.prototype.code=e,t$c[e]=o;}function r$h(e,t){if(Array.isArray(e)){const n=e.length;return e=e.map(e=>String(e)),n>2?`one of ${t} ${e.slice(0,n-1).join(", ")}, or `+e[n-1]:2===n?`one of ${t} ${e[0]} or ${e[1]}`:`of ${t} ${e[0]}`}return `of ${t} ${String(e)}`}n$q("ERR_INVALID_OPT_VALUE",(function(e,t){return 'The value "'+t+'" is invalid for option "'+e+'"'}),TypeError),n$q("ERR_INVALID_ARG_TYPE",(function(e,t,n){let o;var E;let u;if("string"==typeof t&&(E="not ",t.substr(0,E.length)===E)?(o="must not be",t=t.replace(/^not /,"")):o="must be",function(e,t,n){return (void 0===n||n>e.length)&&(n=e.length),e.substring(n-t.length,n)===t}(e," argument"))u=`The ${e} ${o} ${r$h(t,"type")}`;else {u=`The "${e}" ${function(e,t,n){return "number"!=typeof n&&(n=0),!(n+t.length>e.length)&&-1!==e.indexOf(t,n)}(e,".")?"property":"argument"} ${o} ${r$h(t,"type")}`;}return u+=`. Received type ${typeof n}`,u}),TypeError),n$q("ERR_STREAM_PUSH_AFTER_EOF","stream.push() after EOF"),n$q("ERR_METHOD_NOT_IMPLEMENTED",(function(e){return "The "+e+" method is not implemented"})),n$q("ERR_STREAM_PREMATURE_CLOSE","Premature close"),n$q("ERR_STREAM_DESTROYED",(function(e){return "Cannot call "+e+" after a stream was destroyed"})),n$q("ERR_MULTIPLE_CALLBACK","Callback called multiple times"),n$q("ERR_STREAM_CANNOT_PIPE","Cannot pipe, not readable"),n$q("ERR_STREAM_WRITE_AFTER_END","write after end"),n$q("ERR_STREAM_NULL_VALUES","May not write null values to stream",TypeError),n$q("ERR_UNKNOWN_ENCODING",(function(e){return "Unknown encoding: "+e}),TypeError),n$q("ERR_STREAM_UNSHIFT_AFTER_END_EVENT","stream.unshift() after end event"),e$1$1.codes=t$c;var r$1$1=function(){throw new Error("Readable.from is not available in the browser")};var r$2$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global;function e$2$1(e){try{if(!r$2$1.localStorage)return !1}catch(r){return !1}var t=r$2$1.localStorage[e];return null!=t&&"true"===String(t).toLowerCase()}var t$1$1=function(t,n){if(e$2$1("noDeprecation"))return t;var o=!1;return function(){if(!o){if(e$2$1("throwDeprecation"))throw new Error(n);e$2$1("traceDeprecation")?console.trace(n):console.warn(n),o=!0;}return t.apply(this||r$2$1,arguments)}};function u$p(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r);}return n}function f$v(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function h$l(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}var c$n=e$1$1$1.Buffer,b$j=X$5.inspect,p$s=b$j&&b$j.custom||"inspect";var g$h=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0;}var t,n;return t=e,(n=[{key:"push",value:function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length;}},{key:"unshift",value:function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length;}},{key:"shift",value:function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}}},{key:"clear",value:function(){this.head=this.tail=null,this.length=0;}},{key:"join",value:function(e){if(0===this.length)return "";for(var t=this.head,n=""+t.data;t=t.next;)n+=e+t.data;return n}},{key:"concat",value:function(e){if(0===this.length)return c$n.alloc(0);for(var t,n,r,i=c$n.allocUnsafe(e>>>0),a=this.head,o=0;a;)t=a.data,n=i,r=o,void c$n.prototype.copy.call(t,n,r),o+=a.data.length,a=a.next;return i}},{key:"consume",value:function(e,t){var n;return e<this.head.data.length?(n=this.head.data.slice(0,e),this.head.data=this.head.data.slice(e)):n=e===this.head.data.length?this.shift():t?this._getString(e):this._getBuffer(e),n}},{key:"first",value:function(){return this.head.data}},{key:"_getString",value:function(e){var t=this.head,n=1,r=t.data;for(e-=r.length;t=t.next;){var i=t.data,a=e>i.length?i.length:e;if(a===i.length?r+=i:r+=i.slice(0,e),0==(e-=a)){a===i.length?(++n,t.next?this.head=t.next:this.head=this.tail=null):(this.head=t,t.data=i.slice(a));break}++n;}return this.length-=n,r}},{key:"_getBuffer",value:function(e){var t=c$n.allocUnsafe(e),n=this.head,r=1;for(n.data.copy(t),e-=n.data.length;n=n.next;){var i=n.data,a=e>i.length?i.length:e;if(i.copy(t,t.length-e,0,a),0==(e-=a)){a===i.length?(++r,n.next?this.head=n.next:this.head=this.tail=null):(this.head=n,n.data=i.slice(a));break}++r;}return this.length-=r,t}},{key:p$s,value:function(e,t){return b$j(this,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?u$p(Object(n),!0).forEach((function(t){f$v(e,t,n[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):u$p(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t));}));}return e}({},t,{depth:0,customInspect:!1}))}}])&&h$l(t.prototype,n),e}(),y$n=T$9;function w$j(e,t){_$h(e,t),v$k(e);}function v$k(e){e._writableState&&!e._writableState.emitClose||e._readableState&&!e._readableState.emitClose||e.emit("close");}function _$h(e,t){e.emit("error",t);}var m$m={destroy:function(e,t){var n=this,r=this._readableState&&this._readableState.destroyed,i=this._writableState&&this._writableState.destroyed;return r||i?(t?t(e):e&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,y$n.nextTick(_$h,this,e)):y$n.nextTick(_$h,this,e)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,(function(e){!t&&e?n._writableState?n._writableState.errorEmitted?y$n.nextTick(v$k,n):(n._writableState.errorEmitted=!0,y$n.nextTick(w$j,n,e)):y$n.nextTick(w$j,n,e):t?(y$n.nextTick(v$k,n),t(e)):y$n.nextTick(v$k,n);})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1);},errorOrDestroy:function(e,t){var n=e._readableState,r=e._writableState;n&&n.autoDestroy||r&&r.autoDestroy?e.destroy(t):e.emit("error",t);}},S$e=e$1$1.codes.ERR_INVALID_OPT_VALUE;var R$7={getHighWaterMark:function(e,t,n,r){var i=function(e,t,n){return null!=e.highWaterMark?e.highWaterMark:t?e[n]:null}(t,r,n);if(null!=i){if(!isFinite(i)||Math.floor(i)!==i||i<0)throw new S$e(r?n:"highWaterMark",i);return Math.floor(i)}return e.objectMode?16:16384}},k$g=e$1$1.codes.ERR_STREAM_PREMATURE_CLOSE;function E$e(){}var M$a,j$a=function e(t,n,r){if("function"==typeof n)return e(t,null,n);n||(n={}),r=function(e){var t=!1;return function(){if(!t){t=!0;for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];e.apply(this,r);}}}(r||E$e);var i=n.readable||!1!==n.readable&&t.readable,a=n.writable||!1!==n.writable&&t.writable,o=function(){t.writable||l();},s=t._writableState&&t._writableState.finished,l=function(){a=!1,s=!0,i||r.call(t);},d=t._readableState&&t._readableState.endEmitted,u=function(){i=!1,d=!0,a||r.call(t);},f=function(e){r.call(t,e);},h=function(){var e;return i&&!d?(t._readableState&&t._readableState.ended||(e=new k$g),r.call(t,e)):a&&!s?(t._writableState&&t._writableState.ended||(e=new k$g),r.call(t,e)):void 0},c=function(){t.req.on("finish",l);};return !function(e){return e.setHeader&&"function"==typeof e.abort}(t)?a&&!t._writableState&&(t.on("end",o),t.on("close",o)):(t.on("complete",l),t.on("abort",h),t.req?c():t.on("request",c)),t.on("end",u),t.on("finish",l),!1!==n.error&&t.on("error",f),t.on("close",h),function(){t.removeListener("complete",l),t.removeListener("abort",h),t.removeListener("request",c),t.req&&t.req.removeListener("finish",l),t.removeListener("end",o),t.removeListener("close",o),t.removeListener("finish",l),t.removeListener("end",u),t.removeListener("error",f),t.removeListener("close",h);}},O$8=T$9;function T$8(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var P$8=j$a,x$a=Symbol("lastResolve"),L$8=Symbol("lastReject"),D$9=Symbol("error"),C$9=Symbol("ended"),A$c=Symbol("lastPromise"),q$8=Symbol("handlePromise"),W$5=Symbol("stream");function B$c(e,t){return {value:e,done:t}}function I$b(e){var t=e[x$a];if(null!==t){var n=e[W$5].read();null!==n&&(e[A$c]=null,e[x$a]=null,e[L$8]=null,t(B$c(n,!1)));}}function N$7(e){O$8.nextTick(I$b,e);}var U$a=Object.getPrototypeOf((function(){})),H$7=Object.setPrototypeOf((T$8(M$a={get stream(){return this[W$5]},next:function(){var e=this,t=this[D$9];if(null!==t)return Promise.reject(t);if(this[C$9])return Promise.resolve(B$c(void 0,!0));if(this[W$5].destroyed)return new Promise((function(t,n){O$8.nextTick((function(){e[D$9]?n(e[D$9]):t(B$c(void 0,!0));}));}));var n,r=this[A$c];if(r)n=new Promise(function(e,t){return function(n,r){e.then((function(){if(t[C$9])return n(B$c(void 0,!0)),void 0;t[q$8](n,r);}),r);}}(r,this));else {var i=this[W$5].read();if(null!==i)return Promise.resolve(B$c(i,!1));n=new Promise(this[q$8]);}return this[A$c]=n,n}},Symbol.asyncIterator,(function(){return this})),T$8(M$a,"return",(function(){var e=this;return new Promise((function(t,n){e[W$5].destroy(null,(function(e){if(e)return n(e),void 0;t(B$c(void 0,!0));}));}))})),M$a),U$a),F$8=function(e){var t,n=Object.create(H$7,(T$8(t={},W$5,{value:e,writable:!0}),T$8(t,x$a,{value:null,writable:!0}),T$8(t,L$8,{value:null,writable:!0}),T$8(t,D$9,{value:null,writable:!0}),T$8(t,C$9,{value:e._readableState.endEmitted,writable:!0}),T$8(t,q$8,{value:function(e,t){var r=n[W$5].read();r?(n[A$c]=null,n[x$a]=null,n[L$8]=null,e(B$c(r,!1))):(n[x$a]=e,n[L$8]=t);},writable:!0}),t));return n[A$c]=null,P$8(e,(function(e){if(e&&"ERR_STREAM_PREMATURE_CLOSE"!==e.code){var t=n[L$8];return null!==t&&(n[A$c]=null,n[x$a]=null,n[L$8]=null,t(e)),n[D$9]=e,void 0}var r=n[x$a];null!==r&&(n[A$c]=null,n[x$a]=null,n[L$8]=null,r(B$c(void 0,!0))),n[C$9]=!0;})),e.on("readable",N$7.bind(null,n)),n},V$6={},G$5=!1,Y$4="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global;function K$8(){if(G$5)return V$6;G$5=!0;var d,u=T$9;V$6=C,C.ReadableState=D;y$o.EventEmitter;var f=function(e,t){return e.listeners(t).length},h=e$g,c=e$1$1$1.Buffer,b=Y$4.Uint8Array||function(){};var p,y=X$5;p=y&&y.debuglog?y.debuglog("stream"):function(){};var w,v,_,S=g$h,k=m$m,E=R$7.getHighWaterMark,M=e$1$1.codes,j=M.ERR_INVALID_ARG_TYPE,O=M.ERR_STREAM_PUSH_AFTER_EOF,T=M.ERR_METHOD_NOT_IMPLEMENTED,P=M.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;t$2$2(C,h);var x=k.errorOrDestroy,L=["error","close","destroy","pause","resume"];function D(e,t,n){d=d||ee$1(),e=e||{},"boolean"!=typeof n&&(n=t instanceof d),this.objectMode=!!e.objectMode,n&&(this.objectMode=this.objectMode||!!e.readableObjectMode),this.highWaterMark=E(this,e,"readableHighWaterMark",n),this.buffer=new S,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(w||(w=e$1$2.StringDecoder),this.decoder=new w(e.encoding),this.encoding=e.encoding);}function C(e){if(d=d||ee$1(),!(this instanceof C))return new C(e);var t=this instanceof d;this._readableState=new D(e,this,t),this.readable=!0,e&&("function"==typeof e.read&&(this._read=e.read),"function"==typeof e.destroy&&(this._destroy=e.destroy)),h.call(this);}function A(e,t,n,r,i){p("readableAddChunk",t);var a,o=e._readableState;if(null===t)o.reading=!1,function(e,t){if(p("onEofChunk"),t.ended)return;if(t.decoder){var n=t.decoder.end();n&&n.length&&(t.buffer.push(n),t.length+=t.objectMode?1:n.length);}t.ended=!0,t.sync?B(e):(t.needReadable=!1,t.emittedReadable||(t.emittedReadable=!0,I(e)));}(e,o);else if(i||(a=function(e,t){var n;r=t,c.isBuffer(r)||r instanceof b||"string"==typeof t||void 0===t||e.objectMode||(n=new j("chunk",["string","Buffer","Uint8Array"],t));var r;return n}(o,t)),a)x(e,a);else if(o.objectMode||t&&t.length>0)if("string"==typeof t||o.objectMode||Object.getPrototypeOf(t)===c.prototype||(t=function(e){return c.from(e)}(t)),r)o.endEmitted?x(e,new P):q(e,o,t,!0);else if(o.ended)x(e,new O);else {if(o.destroyed)return !1;o.reading=!1,o.decoder&&!n?(t=o.decoder.write(t),o.objectMode||0!==t.length?q(e,o,t,!1):N(e,o)):q(e,o,t,!1);}else r||(o.reading=!1,N(e,o));return !o.ended&&(o.length<o.highWaterMark||0===o.length)}function q(e,t,n,r){t.flowing&&0===t.length&&!t.sync?(t.awaitDrain=0,e.emit("data",n)):(t.length+=t.objectMode?1:n.length,r?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&&B(e)),N(e,t);}Object.defineProperty(C.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e);}}),C.prototype.destroy=k.destroy,C.prototype._undestroy=k.undestroy,C.prototype._destroy=function(e,t){t(e);},C.prototype.push=function(e,t){var n,r=this._readableState;return r.objectMode?n=!0:"string"==typeof e&&((t=t||r.defaultEncoding)!==r.encoding&&(e=c.from(e,t),t=""),n=!0),A(this,e,t,!1,n)},C.prototype.unshift=function(e){return A(this,e,null,!0,!1)},C.prototype.isPaused=function(){return !1===this._readableState.flowing},C.prototype.setEncoding=function(e){w||(w=e$1$2.StringDecoder);var t=new w(e);this._readableState.decoder=t,this._readableState.encoding=this._readableState.decoder.encoding;for(var n=this._readableState.buffer.head,r="";null!==n;)r+=t.write(n.data),n=n.next;return this._readableState.buffer.clear(),""!==r&&this._readableState.buffer.push(r),this._readableState.length=r.length,this};function W(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=1073741824?e=1073741824:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function B(e){var t=e._readableState;p("emitReadable",t.needReadable,t.emittedReadable),t.needReadable=!1,t.emittedReadable||(p("emitReadable",t.flowing),t.emittedReadable=!0,u.nextTick(I,e));}function I(e){var t=e._readableState;p("emitReadable_",t.destroyed,t.length,t.ended),t.destroyed||!t.length&&!t.ended||(e.emit("readable"),t.emittedReadable=!1),t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark,J(e);}function N(e,t){t.readingMore||(t.readingMore=!0,u.nextTick(U,e,t));}function U(e,t){for(;!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&0===t.length);){var n=t.length;if(p("maybeReadMore read 0"),e.read(0),n===t.length)break}t.readingMore=!1;}function H(e){var t=e._readableState;t.readableListening=e.listenerCount("readable")>0,t.resumeScheduled&&!t.paused?t.flowing=!0:e.listenerCount("data")>0&&e.resume();}function K(e){p("readable nexttick read 0"),e.read(0);}function z(e,t){p("resume",t.reading),t.reading||e.read(0),t.resumeScheduled=!1,e.emit("resume"),J(e),t.flowing&&!t.reading&&e.read(0);}function J(e){var t=e._readableState;for(p("flow",t.flowing);t.flowing&&null!==e.read(););}function Q(e,t){return 0===t.length?null:(t.objectMode?n=t.buffer.shift():!e||e>=t.length?(n=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.first():t.buffer.concat(t.length),t.buffer.clear()):n=t.buffer.consume(e,t.decoder),n);var n;}function X(e){var t=e._readableState;p("endReadable",t.endEmitted),t.endEmitted||(t.ended=!0,u.nextTick(Z,t,e));}function Z(e,t){if(p("endReadableNT",e.endEmitted,e.length),!e.endEmitted&&0===e.length&&(e.endEmitted=!0,t.readable=!1,t.emit("end"),e.autoDestroy)){var n=t._writableState;(!n||n.autoDestroy&&n.finished)&&t.destroy();}}function $(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return -1}return C.prototype.read=function(e){p("read",e),e=parseInt(e,10);var t=this._readableState,n=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&((0!==t.highWaterMark?t.length>=t.highWaterMark:t.length>0)||t.ended))return p("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?X(this):B(this),null;if(0===(e=W(e,t))&&t.ended)return 0===t.length&&X(this),null;var r,i=t.needReadable;return p("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&p("length less than watermark",i=!0),t.ended||t.reading?p("reading or ended",i=!1):i&&(p("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=W(n,t))),null===(r=e>0?Q(e,t):null)?(t.needReadable=t.length<=t.highWaterMark,e=0):(t.length-=e,t.awaitDrain=0),0===t.length&&(t.ended||(t.needReadable=!0),n!==e&&t.ended&&X(this)),null!==r&&this.emit("data",r),r},C.prototype._read=function(e){x(this,new T("_read()"));},C.prototype.pipe=function(e,t){var n=this,r=this._readableState;switch(r.pipesCount){case 0:r.pipes=e;break;case 1:r.pipes=[r.pipes,e];break;default:r.pipes.push(e);}r.pipesCount+=1,p("pipe count=%d opts=%j",r.pipesCount,t);var i=(!t||!1!==t.end)&&e!==u.stdout&&e!==u.stderr?o:g;function a(t,i){p("onunpipe"),t===n&&i&&!1===i.hasUnpiped&&(i.hasUnpiped=!0,p("cleanup"),e.removeListener("close",c),e.removeListener("finish",b),e.removeListener("drain",s),e.removeListener("error",h),e.removeListener("unpipe",a),n.removeListener("end",o),n.removeListener("end",g),n.removeListener("data",d),l=!0,!r.awaitDrain||e._writableState&&!e._writableState.needDrain||s());}function o(){p("onend"),e.end();}r.endEmitted?u.nextTick(i):n.once("end",i),e.on("unpipe",a);var s=function(e){return function(){var t=e._readableState;p("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&f(e,"data")&&(t.flowing=!0,J(e));}}(n);e.on("drain",s);var l=!1;function d(t){p("ondata");var i=e.write(t);p("dest.write",i),!1===i&&((1===r.pipesCount&&r.pipes===e||r.pipesCount>1&&-1!==$(r.pipes,e))&&!l&&(p("false write response, pause",r.awaitDrain),r.awaitDrain++),n.pause());}function h(t){p("onerror",t),g(),e.removeListener("error",h),0===f(e,"error")&&x(e,t);}function c(){e.removeListener("finish",b),g();}function b(){p("onfinish"),e.removeListener("close",c),g();}function g(){p("unpipe"),n.unpipe(e);}return n.on("data",d),function(e,t,n){if("function"==typeof e.prependListener)return e.prependListener(t,n);e._events&&e._events[t]?Array.isArray(e._events[t])?e._events[t].unshift(n):e._events[t]=[n,e._events[t]]:e.on(t,n);}(e,"error",h),e.once("close",c),e.once("finish",b),e.emit("pipe",n),r.flowing||(p("pipe resume"),n.resume()),e},C.prototype.unpipe=function(e){var t=this._readableState,n={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes||(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,n)),this;if(!e){var r=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var a=0;a<i;a++)r[a].emit("unpipe",this,{hasUnpiped:!1});return this}var o=$(t.pipes,e);return -1===o||(t.pipes.splice(o,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,n)),this},C.prototype.on=function(e,t){var n=h.prototype.on.call(this,e,t),r=this._readableState;return "data"===e?(r.readableListening=this.listenerCount("readable")>0,!1!==r.flowing&&this.resume()):"readable"===e&&(r.endEmitted||r.readableListening||(r.readableListening=r.needReadable=!0,r.flowing=!1,r.emittedReadable=!1,p("on readable",r.length,r.reading),r.length?B(this):r.reading||u.nextTick(K,this))),n},C.prototype.addListener=C.prototype.on,C.prototype.removeListener=function(e,t){var n=h.prototype.removeListener.call(this,e,t);return "readable"===e&&u.nextTick(H,this),n},C.prototype.removeAllListeners=function(e){var t=h.prototype.removeAllListeners.apply(this,arguments);return "readable"!==e&&void 0!==e||u.nextTick(H,this),t},C.prototype.resume=function(){var e=this._readableState;return e.flowing||(p("resume"),e.flowing=!e.readableListening,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,u.nextTick(z,e,t));}(this,e)),e.paused=!1,this},C.prototype.pause=function(){return p("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(p("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState.paused=!0,this},C.prototype.wrap=function(e){var t=this,n=this._readableState,r=!1;for(var i in e.on("end",(function(){if(p("wrapped end"),n.decoder&&!n.ended){var e=n.decoder.end();e&&e.length&&t.push(e);}t.push(null);})),e.on("data",(function(i){(p("wrapped data"),n.decoder&&(i=n.decoder.write(i)),n.objectMode&&null==i)||(n.objectMode||i&&i.length)&&(t.push(i)||(r=!0,e.pause()));})),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));for(var a=0;a<L.length;a++)e.on(L[a],this.emit.bind(this,L[a]));return this._read=function(t){p("wrapped _read",t),r&&(r=!1,e.resume());},this},"function"==typeof Symbol&&(C.prototype[Symbol.asyncIterator]=function(){return void 0===v&&(v=F$8),v(this)}),Object.defineProperty(C.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(C.prototype,"readableBuffer",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(C.prototype,"readableFlowing",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(e){this._readableState&&(this._readableState.flowing=e);}}),C._fromList=Q,Object.defineProperty(C.prototype,"readableLength",{enumerable:!1,get:function(){return this._readableState.length}}),"function"==typeof Symbol&&(C.from=function(e,t){return void 0===_&&(_=r$1$1),_(C,e,t)}),V$6}var z$9={},J$5=!1,Q$4="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global;function X$4(){if(J$5)return z$9;J$5=!0;var e$2,r=T$9;function s(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t,n){var r=e.entry;e.entry=null;for(;r;){var i=r.callback;t.pendingcb--,i(n),r=r.next;}t.corkedRequestsFree.next=e;}(t,e);};}z$9=P,P.WritableState=T;var l={deprecate:t$1$1},u=e$g,f=e$1$1$1.Buffer,h=Q$4.Uint8Array||function(){};var c,b=m$m,p=R$7.getHighWaterMark,g=e$1$1.codes,y=g.ERR_INVALID_ARG_TYPE,w=g.ERR_METHOD_NOT_IMPLEMENTED,v=g.ERR_MULTIPLE_CALLBACK,_=g.ERR_STREAM_CANNOT_PIPE,S=g.ERR_STREAM_DESTROYED,k=g.ERR_STREAM_NULL_VALUES,E=g.ERR_STREAM_WRITE_AFTER_END,M=g.ERR_UNKNOWN_ENCODING,j=b.errorOrDestroy;function O(){}function T(t,n,i){e$2=e$2||ee$1(),t=t||{},"boolean"!=typeof i&&(i=n instanceof e$2),this.objectMode=!!t.objectMode,i&&(this.objectMode=this.objectMode||!!t.writableObjectMode),this.highWaterMark=p(this,t,"writableHighWaterMark",i),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var a=!1===t.decodeStrings;this.decodeStrings=!a,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var n=e._writableState,i=n.sync,a=n.writecb;if("function"!=typeof a)throw new v;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0;}(n),t)!function(e,t,n,i,a){--t.pendingcb,n?(r.nextTick(a,i),r.nextTick(q,e,t),e._writableState.errorEmitted=!0,j(e,i)):(a(i),e._writableState.errorEmitted=!0,j(e,i),q(e,t));}(e,n,i,t,a);else {var o=C(n)||e.destroyed;o||n.corked||n.bufferProcessing||!n.bufferedRequest||D(e,n),i?r.nextTick(L,e,n,o,a):L(e,n,o,a);}}(n,e);},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new s(this);}function P(t){var n=this instanceof(e$2=e$2||ee$1());if(!n&&!c.call(P,this))return new P(t);this._writableState=new T(t,this,n),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),u.call(this);}function x(e,t,n,r,i,a,o){t.writelen=r,t.writecb=o,t.writing=!0,t.sync=!0,t.destroyed?t.onwrite(new S("write")):n?e._writev(i,t.onwrite):e._write(i,a,t.onwrite),t.sync=!1;}function L(e,t,n,r){n||!function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"));}(e,t),t.pendingcb--,r(),q(e,t);}function D(e,t){t.bufferProcessing=!0;var n=t.bufferedRequest;if(e._writev&&n&&n.next){var r=t.bufferedRequestCount,i=new Array(r),a=t.corkedRequestsFree;a.entry=n;for(var o=0,l=!0;n;)i[o]=n,n.isBuf||(l=!1),n=n.next,o+=1;i.allBuffers=l,x(e,t,!0,t.length,i,"",a.finish),t.pendingcb++,t.lastBufferedRequest=null,a.next?(t.corkedRequestsFree=a.next,a.next=null):t.corkedRequestsFree=new s(t),t.bufferedRequestCount=0;}else {for(;n;){var d=n.chunk,u=n.encoding,f=n.callback;if(x(e,t,!1,t.objectMode?1:d.length,d,u,f),n=n.next,t.bufferedRequestCount--,t.writing)break}null===n&&(t.lastBufferedRequest=null);}t.bufferedRequest=n,t.bufferProcessing=!1;}function C(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function A(e,t){e._final((function(n){t.pendingcb--,n&&j(e,n),t.prefinished=!0,e.emit("prefinish"),q(e,t);}));}function q(e,t){var n=C(t);if(n&&(!function(e,t){t.prefinished||t.finalCalled||("function"!=typeof e._final||t.destroyed?(t.prefinished=!0,e.emit("prefinish")):(t.pendingcb++,t.finalCalled=!0,r.nextTick(A,e,t)));}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"),t.autoDestroy))){var i=e._readableState;(!i||i.autoDestroy&&i.endEmitted)&&e.destroy();}return n}return t$2$2(P,u),T.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(T.prototype,"buffer",{get:l.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")});}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(c=Function.prototype[Symbol.hasInstance],Object.defineProperty(P,Symbol.hasInstance,{value:function(e){return !!c.call(this,e)||this===P&&(e&&e._writableState instanceof T)}})):c=function(e){return e instanceof this},P.prototype.pipe=function(){j(this,new _);},P.prototype.write=function(e,t,n){var i,a=this._writableState,o=!1,s=!a.objectMode&&(i=e,f.isBuffer(i)||i instanceof h);return s&&!f.isBuffer(e)&&(e=function(e){return f.from(e)}(e)),"function"==typeof t&&(n=t,t=null),s?t="buffer":t||(t=a.defaultEncoding),"function"!=typeof n&&(n=O),a.ending?function(e,t){var n=new E;j(e,n),r.nextTick(t,n);}(this,n):(s||function(e,t,n,i){var a;return null===n?a=new k:"string"==typeof n||t.objectMode||(a=new y("chunk",["string","Buffer"],n)),!a||(j(e,a),r.nextTick(i,a),!1)}(this,a,e,n))&&(a.pendingcb++,o=function(e,t,n,r,i,a){if(!n){var o=function(e,t,n){e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=f.from(t,n));return t}(t,r,i);r!==o&&(n=!0,i="buffer",r=o);}var s=t.objectMode?1:r.length;t.length+=s;var l=t.length<t.highWaterMark;l||(t.needDrain=!0);if(t.writing||t.corked){var d=t.lastBufferedRequest;t.lastBufferedRequest={chunk:r,encoding:i,isBuf:n,callback:a,next:null},d?d.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1;}else x(e,t,!1,s,r,i,a);return l}(this,a,s,e,t,n)),o},P.prototype.cork=function(){this._writableState.corked++;},P.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.bufferProcessing||!e.bufferedRequest||D(this,e));},P.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new M(e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(P.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(P.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),P.prototype._write=function(e,t,n){n(new w("_write()"));},P.prototype._writev=null,P.prototype.end=function(e,t,n){var i=this._writableState;return "function"==typeof e?(n=e,e=null,t=null):"function"==typeof t&&(n=t,t=null),null!=e&&this.write(e,t),i.corked&&(i.corked=1,this.uncork()),i.ending||function(e,t,n){t.ending=!0,q(e,t),n&&(t.finished?r.nextTick(n):e.once("finish",n));t.ended=!0,e.writable=!1;}(this,i,n),this},Object.defineProperty(P.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(P.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e);}}),P.prototype.destroy=b.destroy,P.prototype._undestroy=b.undestroy,P.prototype._destroy=function(e,t){t(e);},z$9}var Z$3={},$$3=!1;function ee$1(){if($$3)return Z$3;$$3=!0;var e=T$9,t=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};Z$3=d;var n=K$8(),r=X$4();t$2$2(d,n);for(var a=t(r.prototype),s=0;s<a.length;s++){var l=a[s];d.prototype[l]||(d.prototype[l]=r.prototype[l]);}function d(e){if(!(this instanceof d))return new d(e);n.call(this,e),r.call(this,e),this.allowHalfOpen=!0,e&&(!1===e.readable&&(this.readable=!1),!1===e.writable&&(this.writable=!1),!1===e.allowHalfOpen&&(this.allowHalfOpen=!1,this.once("end",u)));}function u(){this._writableState.ended||e.nextTick(f,this);}function f(e){e.end();}return Object.defineProperty(d.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(d.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(d.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(d.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e);}}),Z$3}var t$2$1=K$8();var r$3$1=e$1$1.codes.ERR_STREAM_PREMATURE_CLOSE;function t$3$1(){}var n$1$1=function e(n,o,a){if("function"==typeof o)return e(n,null,o);o||(o={}),a=function(e){var r=!1;return function(){if(!r){r=!0;for(var t=arguments.length,n=new Array(t),o=0;o<t;o++)n[o]=arguments[o];e.apply(this,n);}}}(a||t$3$1);var i=o.readable||!1!==o.readable&&n.readable,l=o.writable||!1!==o.writable&&n.writable,c=function(){n.writable||s();},f=n._writableState&&n._writableState.finished,s=function(){l=!1,f=!0,i||a.call(n);},u=n._readableState&&n._readableState.endEmitted,d=function(){i=!1,u=!0,l||a.call(n);},b=function(e){a.call(n,e);},v=function(){var e;return i&&!u?(n._readableState&&n._readableState.ended||(e=new r$3$1),a.call(n,e)):l&&!f?(n._writableState&&n._writableState.ended||(e=new r$3$1),a.call(n,e)):void 0},m=function(){n.req.on("finish",s);};return !function(e){return e.setHeader&&"function"==typeof e.abort}(n)?l&&!n._writableState&&(n.on("end",c),n.on("close",c)):(n.on("complete",s),n.on("abort",v),n.req?m():n.on("request",m)),n.on("end",d),n.on("finish",s),!1!==o.error&&n.on("error",b),n.on("close",v),function(){n.removeListener("complete",s),n.removeListener("abort",v),n.removeListener("request",m),n.req&&n.req.removeListener("finish",s),n.removeListener("end",c),n.removeListener("close",c),n.removeListener("finish",s),n.removeListener("end",d),n.removeListener("error",b),n.removeListener("close",v);}};function f$1$1(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r);}return n}function h$1$1(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c$1$1(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r);}}var b$1$1=e$1$1$1.Buffer,p$1$1=X$5.inspect,g$1$1=p$1$1&&p$1$1.custom||"inspect";var y$1$1=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.head=null,this.tail=null,this.length=0;}var t,n;return t=e,(n=[{key:"push",value:function(e){var t={data:e,next:null};this.length>0?this.tail.next=t:this.head=t,this.tail=t,++this.length;}},{key:"unshift",value:function(e){var t={data:e,next:this.head};0===this.length&&(this.tail=t),this.head=t,++this.length;}},{key:"shift",value:function(){if(0!==this.length){var e=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,e}}},{key:"clear",value:function(){this.head=this.tail=null,this.length=0;}},{key:"join",value:function(e){if(0===this.length)return "";for(var t=this.head,n=""+t.data;t=t.next;)n+=e+t.data;return n}},{key:"concat",value:function(e){if(0===this.length)return b$1$1.alloc(0);for(var t,n,r,i=b$1$1.allocUnsafe(e>>>0),a=this.head,o=0;a;)t=a.data,n=i,r=o,void b$1$1.prototype.copy.call(t,n,r),o+=a.data.length,a=a.next;return i}},{key:"consume",value:function(e,t){var n;return e<this.head.data.length?(n=this.head.data.slice(0,e),this.head.data=this.head.data.slice(e)):n=e===this.head.data.length?this.shift():t?this._getString(e):this._getBuffer(e),n}},{key:"first",value:function(){return this.head.data}},{key:"_getString",value:function(e){var t=this.head,n=1,r=t.data;for(e-=r.length;t=t.next;){var i=t.data,a=e>i.length?i.length:e;if(a===i.length?r+=i:r+=i.slice(0,e),0==(e-=a)){a===i.length?(++n,t.next?this.head=t.next:this.head=this.tail=null):(this.head=t,t.data=i.slice(a));break}++n;}return this.length-=n,r}},{key:"_getBuffer",value:function(e){var t=b$1$1.allocUnsafe(e),n=this.head,r=1;for(n.data.copy(t),e-=n.data.length;n=n.next;){var i=n.data,a=e>i.length?i.length:e;if(i.copy(t,t.length-e,0,a),0==(e-=a)){a===i.length?(++r,n.next?this.head=n.next:this.head=this.tail=null):(this.head=n,n.data=i.slice(a));break}++r;}return this.length-=r,t}},{key:g$1$1,value:function(e,t){return p$1$1(this,function(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?f$1$1(Object(n),!0).forEach((function(t){h$1$1(e,t,n[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):f$1$1(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t));}));}return e}({},t,{depth:0,customInspect:!1}))}}])&&c$1$1(t.prototype,n),e}(),w$1$1=T$9;function _$1$1(e,t){m$1$1(e,t),v$1$1(e);}function v$1$1(e){e._writableState&&!e._writableState.emitClose||e._readableState&&!e._readableState.emitClose||e.emit("close");}function m$1$1(e,t){e.emit("error",t);}var S$1$1={destroy:function(e,t){var n=this,r=this._readableState&&this._readableState.destroyed,i=this._writableState&&this._writableState.destroyed;return r||i?(t?t(e):e&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,w$1$1.nextTick(m$1$1,this,e)):w$1$1.nextTick(m$1$1,this,e)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(e||null,(function(e){!t&&e?n._writableState?n._writableState.errorEmitted?w$1$1.nextTick(v$1$1,n):(n._writableState.errorEmitted=!0,w$1$1.nextTick(_$1$1,n,e)):w$1$1.nextTick(_$1$1,n,e):t?(w$1$1.nextTick(v$1$1,n),t(e)):w$1$1.nextTick(v$1$1,n);})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1);},errorOrDestroy:function(e,t){var n=e._readableState,r=e._writableState;n&&n.autoDestroy||r&&r.autoDestroy?e.destroy(t):e.emit("error",t);}},R$1$1=e$1$1.codes.ERR_INVALID_OPT_VALUE;var k$1$1,E$1$1={getHighWaterMark:function(e,t,n,r){var i=function(e,t,n){return null!=e.highWaterMark?e.highWaterMark:t?e[n]:null}(t,r,n);if(null!=i){if(!isFinite(i)||Math.floor(i)!==i||i<0)throw new R$1$1(r?n:"highWaterMark",i);return Math.floor(i)}return e.objectMode?16:16384}},M$1$1=T$9;function j$1$1(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var O$1$1=n$1$1,T$1$1=Symbol("lastResolve"),x$1$1=Symbol("lastReject"),P$1$1=Symbol("error"),D$1$1=Symbol("ended"),L$1$1=Symbol("lastPromise"),C$1$1=Symbol("handlePromise"),A$1$1=Symbol("stream");function W$1$1(e,t){return {value:e,done:t}}function B$1$1(e){var t=e[T$1$1];if(null!==t){var n=e[A$1$1].read();null!==n&&(e[L$1$1]=null,e[T$1$1]=null,e[x$1$1]=null,t(W$1$1(n,!1)));}}function q$1$1(e){M$1$1.nextTick(B$1$1,e);}var I$1$1=Object.getPrototypeOf((function(){})),N$1$1=Object.setPrototypeOf((j$1$1(k$1$1={get stream(){return this[A$1$1]},next:function(){var e=this,t=this[P$1$1];if(null!==t)return Promise.reject(t);if(this[D$1$1])return Promise.resolve(W$1$1(void 0,!0));if(this[A$1$1].destroyed)return new Promise((function(t,n){M$1$1.nextTick((function(){e[P$1$1]?n(e[P$1$1]):t(W$1$1(void 0,!0));}));}));var n,r=this[L$1$1];if(r)n=new Promise(function(e,t){return function(n,r){e.then((function(){if(t[D$1$1])return n(W$1$1(void 0,!0)),void 0;t[C$1$1](n,r);}),r);}}(r,this));else {var i=this[A$1$1].read();if(null!==i)return Promise.resolve(W$1$1(i,!1));n=new Promise(this[C$1$1]);}return this[L$1$1]=n,n}},Symbol.asyncIterator,(function(){return this})),j$1$1(k$1$1,"return",(function(){var e=this;return new Promise((function(t,n){e[A$1$1].destroy(null,(function(e){if(e)return n(e),void 0;t(W$1$1(void 0,!0));}));}))})),k$1$1),I$1$1),U$1$1=function(e){var t,n=Object.create(N$1$1,(j$1$1(t={},A$1$1,{value:e,writable:!0}),j$1$1(t,T$1$1,{value:null,writable:!0}),j$1$1(t,x$1$1,{value:null,writable:!0}),j$1$1(t,P$1$1,{value:null,writable:!0}),j$1$1(t,D$1$1,{value:e._readableState.endEmitted,writable:!0}),j$1$1(t,C$1$1,{value:function(e,t){var r=n[A$1$1].read();r?(n[L$1$1]=null,n[T$1$1]=null,n[x$1$1]=null,e(W$1$1(r,!1))):(n[T$1$1]=e,n[x$1$1]=t);},writable:!0}),t));return n[L$1$1]=null,O$1$1(e,(function(e){if(e&&"ERR_STREAM_PREMATURE_CLOSE"!==e.code){var t=n[x$1$1];return null!==t&&(n[L$1$1]=null,n[T$1$1]=null,n[x$1$1]=null,t(e)),n[P$1$1]=e,void 0}var r=n[T$1$1];null!==r&&(n[L$1$1]=null,n[T$1$1]=null,n[x$1$1]=null,r(W$1$1(void 0,!0))),n[D$1$1]=!0;})),e.on("readable",q$1$1.bind(null,n)),n},H$1$1={},F$1$1=!1,V$1$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global;function G$1$1(){if(F$1$1)return H$1$1;F$1$1=!0;var l,u=T$9;H$1$1=C,C.ReadableState=L;y$o.EventEmitter;var f=function(e,t){return e.listeners(t).length},h=e$g,c=e$1$1$1.Buffer,b=V$1$1.Uint8Array||function(){};var p,g=X$5;p=g&&g.debuglog?g.debuglog("stream"):function(){};var w,_,v,m=y$1$1,R=S$1$1,k=E$1$1.getHighWaterMark,M=e$1$1.codes,j=M.ERR_INVALID_ARG_TYPE,O=M.ERR_STREAM_PUSH_AFTER_EOF,T=M.ERR_METHOD_NOT_IMPLEMENTED,x=M.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;t$2$2(C,h);var P=R.errorOrDestroy,D=["error","close","destroy","pause","resume"];function L(e,t,n){l=l||Z$1$1(),e=e||{},"boolean"!=typeof n&&(n=t instanceof l),this.objectMode=!!e.objectMode,n&&(this.objectMode=this.objectMode||!!e.readableObjectMode),this.highWaterMark=k(this,e,"readableHighWaterMark",n),this.buffer=new m,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==e.emitClose,this.autoDestroy=!!e.autoDestroy,this.destroyed=!1,this.defaultEncoding=e.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,e.encoding&&(w||(w=e$1$2.StringDecoder),this.decoder=new w(e.encoding),this.encoding=e.encoding);}function C(e){if(l=l||Z$1$1(),!(this instanceof C))return new C(e);var t=this instanceof l;this._readableState=new L(e,this,t),this.readable=!0,e&&("function"==typeof e.read&&(this._read=e.read),"function"==typeof e.destroy&&(this._destroy=e.destroy)),h.call(this);}function A(e,t,n,r,i){p("readableAddChunk",t);var a,o=e._readableState;if(null===t)o.reading=!1,function(e,t){if(p("onEofChunk"),t.ended)return;if(t.decoder){var n=t.decoder.end();n&&n.length&&(t.buffer.push(n),t.length+=t.objectMode?1:n.length);}t.ended=!0,t.sync?q(e):(t.needReadable=!1,t.emittedReadable||(t.emittedReadable=!0,I(e)));}(e,o);else if(i||(a=function(e,t){var n;r=t,c.isBuffer(r)||r instanceof b||"string"==typeof t||void 0===t||e.objectMode||(n=new j("chunk",["string","Buffer","Uint8Array"],t));var r;return n}(o,t)),a)P(e,a);else if(o.objectMode||t&&t.length>0)if("string"==typeof t||o.objectMode||Object.getPrototypeOf(t)===c.prototype||(t=function(e){return c.from(e)}(t)),r)o.endEmitted?P(e,new x):W(e,o,t,!0);else if(o.ended)P(e,new O);else {if(o.destroyed)return !1;o.reading=!1,o.decoder&&!n?(t=o.decoder.write(t),o.objectMode||0!==t.length?W(e,o,t,!1):N(e,o)):W(e,o,t,!1);}else r||(o.reading=!1,N(e,o));return !o.ended&&(o.length<o.highWaterMark||0===o.length)}function W(e,t,n,r){t.flowing&&0===t.length&&!t.sync?(t.awaitDrain=0,e.emit("data",n)):(t.length+=t.objectMode?1:n.length,r?t.buffer.unshift(n):t.buffer.push(n),t.needReadable&&q(e)),N(e,t);}Object.defineProperty(C.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(e){this._readableState&&(this._readableState.destroyed=e);}}),C.prototype.destroy=R.destroy,C.prototype._undestroy=R.undestroy,C.prototype._destroy=function(e,t){t(e);},C.prototype.push=function(e,t){var n,r=this._readableState;return r.objectMode?n=!0:"string"==typeof e&&((t=t||r.defaultEncoding)!==r.encoding&&(e=c.from(e,t),t=""),n=!0),A(this,e,t,!1,n)},C.prototype.unshift=function(e){return A(this,e,null,!0,!1)},C.prototype.isPaused=function(){return !1===this._readableState.flowing},C.prototype.setEncoding=function(e){w||(w=e$1$2.StringDecoder);var t=new w(e);this._readableState.decoder=t,this._readableState.encoding=this._readableState.decoder.encoding;for(var n=this._readableState.buffer.head,r="";null!==n;)r+=t.write(n.data),n=n.next;return this._readableState.buffer.clear(),""!==r&&this._readableState.buffer.push(r),this._readableState.length=r.length,this};function B(e,t){return e<=0||0===t.length&&t.ended?0:t.objectMode?1:e!=e?t.flowing&&t.length?t.buffer.head.data.length:t.length:(e>t.highWaterMark&&(t.highWaterMark=function(e){return e>=1073741824?e=1073741824:(e--,e|=e>>>1,e|=e>>>2,e|=e>>>4,e|=e>>>8,e|=e>>>16,e++),e}(e)),e<=t.length?e:t.ended?t.length:(t.needReadable=!0,0))}function q(e){var t=e._readableState;p("emitReadable",t.needReadable,t.emittedReadable),t.needReadable=!1,t.emittedReadable||(p("emitReadable",t.flowing),t.emittedReadable=!0,u.nextTick(I,e));}function I(e){var t=e._readableState;p("emitReadable_",t.destroyed,t.length,t.ended),t.destroyed||!t.length&&!t.ended||(e.emit("readable"),t.emittedReadable=!1),t.needReadable=!t.flowing&&!t.ended&&t.length<=t.highWaterMark,J(e);}function N(e,t){t.readingMore||(t.readingMore=!0,u.nextTick(G,e,t));}function G(e,t){for(;!t.reading&&!t.ended&&(t.length<t.highWaterMark||t.flowing&&0===t.length);){var n=t.length;if(p("maybeReadMore read 0"),e.read(0),n===t.length)break}t.readingMore=!1;}function Y(e){var t=e._readableState;t.readableListening=e.listenerCount("readable")>0,t.resumeScheduled&&!t.paused?t.flowing=!0:e.listenerCount("data")>0&&e.resume();}function K(e){p("readable nexttick read 0"),e.read(0);}function z(e,t){p("resume",t.reading),t.reading||e.read(0),t.resumeScheduled=!1,e.emit("resume"),J(e),t.flowing&&!t.reading&&e.read(0);}function J(e){var t=e._readableState;for(p("flow",t.flowing);t.flowing&&null!==e.read(););}function Q(e,t){return 0===t.length?null:(t.objectMode?n=t.buffer.shift():!e||e>=t.length?(n=t.decoder?t.buffer.join(""):1===t.buffer.length?t.buffer.first():t.buffer.concat(t.length),t.buffer.clear()):n=t.buffer.consume(e,t.decoder),n);var n;}function X(e){var t=e._readableState;p("endReadable",t.endEmitted),t.endEmitted||(t.ended=!0,u.nextTick($,t,e));}function $(e,t){if(p("endReadableNT",e.endEmitted,e.length),!e.endEmitted&&0===e.length&&(e.endEmitted=!0,t.readable=!1,t.emit("end"),e.autoDestroy)){var n=t._writableState;(!n||n.autoDestroy&&n.finished)&&t.destroy();}}function ee(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return -1}return C.prototype.read=function(e){p("read",e),e=parseInt(e,10);var t=this._readableState,n=e;if(0!==e&&(t.emittedReadable=!1),0===e&&t.needReadable&&((0!==t.highWaterMark?t.length>=t.highWaterMark:t.length>0)||t.ended))return p("read: emitReadable",t.length,t.ended),0===t.length&&t.ended?X(this):q(this),null;if(0===(e=B(e,t))&&t.ended)return 0===t.length&&X(this),null;var r,i=t.needReadable;return p("need readable",i),(0===t.length||t.length-e<t.highWaterMark)&&p("length less than watermark",i=!0),t.ended||t.reading?p("reading or ended",i=!1):i&&(p("do read"),t.reading=!0,t.sync=!0,0===t.length&&(t.needReadable=!0),this._read(t.highWaterMark),t.sync=!1,t.reading||(e=B(n,t))),null===(r=e>0?Q(e,t):null)?(t.needReadable=t.length<=t.highWaterMark,e=0):(t.length-=e,t.awaitDrain=0),0===t.length&&(t.ended||(t.needReadable=!0),n!==e&&t.ended&&X(this)),null!==r&&this.emit("data",r),r},C.prototype._read=function(e){P(this,new T("_read()"));},C.prototype.pipe=function(e,t){var n=this,r=this._readableState;switch(r.pipesCount){case 0:r.pipes=e;break;case 1:r.pipes=[r.pipes,e];break;default:r.pipes.push(e);}r.pipesCount+=1,p("pipe count=%d opts=%j",r.pipesCount,t);var i=(!t||!1!==t.end)&&e!==u.stdout&&e!==u.stderr?o:g;function a(t,i){p("onunpipe"),t===n&&i&&!1===i.hasUnpiped&&(i.hasUnpiped=!0,p("cleanup"),e.removeListener("close",c),e.removeListener("finish",b),e.removeListener("drain",s),e.removeListener("error",h),e.removeListener("unpipe",a),n.removeListener("end",o),n.removeListener("end",g),n.removeListener("data",d),l=!0,!r.awaitDrain||e._writableState&&!e._writableState.needDrain||s());}function o(){p("onend"),e.end();}r.endEmitted?u.nextTick(i):n.once("end",i),e.on("unpipe",a);var s=function(e){return function(){var t=e._readableState;p("pipeOnDrain",t.awaitDrain),t.awaitDrain&&t.awaitDrain--,0===t.awaitDrain&&f(e,"data")&&(t.flowing=!0,J(e));}}(n);e.on("drain",s);var l=!1;function d(t){p("ondata");var i=e.write(t);p("dest.write",i),!1===i&&((1===r.pipesCount&&r.pipes===e||r.pipesCount>1&&-1!==ee(r.pipes,e))&&!l&&(p("false write response, pause",r.awaitDrain),r.awaitDrain++),n.pause());}function h(t){p("onerror",t),g(),e.removeListener("error",h),0===f(e,"error")&&P(e,t);}function c(){e.removeListener("finish",b),g();}function b(){p("onfinish"),e.removeListener("close",c),g();}function g(){p("unpipe"),n.unpipe(e);}return n.on("data",d),function(e,t,n){if("function"==typeof e.prependListener)return e.prependListener(t,n);e._events&&e._events[t]?Array.isArray(e._events[t])?e._events[t].unshift(n):e._events[t]=[n,e._events[t]]:e.on(t,n);}(e,"error",h),e.once("close",c),e.once("finish",b),e.emit("pipe",n),r.flowing||(p("pipe resume"),n.resume()),e},C.prototype.unpipe=function(e){var t=this._readableState,n={hasUnpiped:!1};if(0===t.pipesCount)return this;if(1===t.pipesCount)return e&&e!==t.pipes||(e||(e=t.pipes),t.pipes=null,t.pipesCount=0,t.flowing=!1,e&&e.emit("unpipe",this,n)),this;if(!e){var r=t.pipes,i=t.pipesCount;t.pipes=null,t.pipesCount=0,t.flowing=!1;for(var a=0;a<i;a++)r[a].emit("unpipe",this,{hasUnpiped:!1});return this}var o=ee(t.pipes,e);return -1===o||(t.pipes.splice(o,1),t.pipesCount-=1,1===t.pipesCount&&(t.pipes=t.pipes[0]),e.emit("unpipe",this,n)),this},C.prototype.on=function(e,t){var n=h.prototype.on.call(this,e,t),r=this._readableState;return "data"===e?(r.readableListening=this.listenerCount("readable")>0,!1!==r.flowing&&this.resume()):"readable"===e&&(r.endEmitted||r.readableListening||(r.readableListening=r.needReadable=!0,r.flowing=!1,r.emittedReadable=!1,p("on readable",r.length,r.reading),r.length?q(this):r.reading||u.nextTick(K,this))),n},C.prototype.addListener=C.prototype.on,C.prototype.removeListener=function(e,t){var n=h.prototype.removeListener.call(this,e,t);return "readable"===e&&u.nextTick(Y,this),n},C.prototype.removeAllListeners=function(e){var t=h.prototype.removeAllListeners.apply(this,arguments);return "readable"!==e&&void 0!==e||u.nextTick(Y,this),t},C.prototype.resume=function(){var e=this._readableState;return e.flowing||(p("resume"),e.flowing=!e.readableListening,function(e,t){t.resumeScheduled||(t.resumeScheduled=!0,u.nextTick(z,e,t));}(this,e)),e.paused=!1,this},C.prototype.pause=function(){return p("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(p("pause"),this._readableState.flowing=!1,this.emit("pause")),this._readableState.paused=!0,this},C.prototype.wrap=function(e){var t=this,n=this._readableState,r=!1;for(var i in e.on("end",(function(){if(p("wrapped end"),n.decoder&&!n.ended){var e=n.decoder.end();e&&e.length&&t.push(e);}t.push(null);})),e.on("data",(function(i){(p("wrapped data"),n.decoder&&(i=n.decoder.write(i)),n.objectMode&&null==i)||(n.objectMode||i&&i.length)&&(t.push(i)||(r=!0,e.pause()));})),e)void 0===this[i]&&"function"==typeof e[i]&&(this[i]=function(t){return function(){return e[t].apply(e,arguments)}}(i));for(var a=0;a<D.length;a++)e.on(D[a],this.emit.bind(this,D[a]));return this._read=function(t){p("wrapped _read",t),r&&(r=!1,e.resume());},this},"function"==typeof Symbol&&(C.prototype[Symbol.asyncIterator]=function(){return void 0===_&&(_=U$1$1),_(this)}),Object.defineProperty(C.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(C.prototype,"readableBuffer",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(C.prototype,"readableFlowing",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(e){this._readableState&&(this._readableState.flowing=e);}}),C._fromList=Q,Object.defineProperty(C.prototype,"readableLength",{enumerable:!1,get:function(){return this._readableState.length}}),"function"==typeof Symbol&&(C.from=function(e,t){return void 0===v&&(v=r$1$1),v(C,e,t)}),H$1$1}var Y$1$1={},K$1$1=!1,z$1$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global;function J$1$1(){if(K$1$1)return Y$1$1;K$1$1=!0;var e$2,r=T$9;function s(e){var t=this;this.next=null,this.entry=null,this.finish=function(){!function(e,t,n){var r=e.entry;e.entry=null;for(;r;){var i=r.callback;t.pendingcb--,i(n),r=r.next;}t.corkedRequestsFree.next=e;}(t,e);};}Y$1$1=x,x.WritableState=T;var l={deprecate:t$1$1},d=e$g,f=e$1$1$1.Buffer,h=z$1$1.Uint8Array||function(){};var c,b=S$1$1,p=E$1$1.getHighWaterMark,g=e$1$1.codes,y=g.ERR_INVALID_ARG_TYPE,w=g.ERR_METHOD_NOT_IMPLEMENTED,_=g.ERR_MULTIPLE_CALLBACK,v=g.ERR_STREAM_CANNOT_PIPE,m=g.ERR_STREAM_DESTROYED,R=g.ERR_STREAM_NULL_VALUES,k=g.ERR_STREAM_WRITE_AFTER_END,M=g.ERR_UNKNOWN_ENCODING,j=b.errorOrDestroy;function O(){}function T(t,n,i){e$2=e$2||Z$1$1(),t=t||{},"boolean"!=typeof i&&(i=n instanceof e$2),this.objectMode=!!t.objectMode,i&&(this.objectMode=this.objectMode||!!t.writableObjectMode),this.highWaterMark=p(this,t,"writableHighWaterMark",i),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var a=!1===t.decodeStrings;this.decodeStrings=!a,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(e){!function(e,t){var n=e._writableState,i=n.sync,a=n.writecb;if("function"!=typeof a)throw new _;if(function(e){e.writing=!1,e.writecb=null,e.length-=e.writelen,e.writelen=0;}(n),t)!function(e,t,n,i,a){--t.pendingcb,n?(r.nextTick(a,i),r.nextTick(W,e,t),e._writableState.errorEmitted=!0,j(e,i)):(a(i),e._writableState.errorEmitted=!0,j(e,i),W(e,t));}(e,n,i,t,a);else {var o=C(n)||e.destroyed;o||n.corked||n.bufferProcessing||!n.bufferedRequest||L(e,n),i?r.nextTick(D,e,n,o,a):D(e,n,o,a);}}(n,e);},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new s(this);}function x(t){var n=this instanceof(e$2=e$2||Z$1$1());if(!n&&!c.call(x,this))return new x(t);this._writableState=new T(t,this,n),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),d.call(this);}function P(e,t,n,r,i,a,o){t.writelen=r,t.writecb=o,t.writing=!0,t.sync=!0,t.destroyed?t.onwrite(new m("write")):n?e._writev(i,t.onwrite):e._write(i,a,t.onwrite),t.sync=!1;}function D(e,t,n,r){n||!function(e,t){0===t.length&&t.needDrain&&(t.needDrain=!1,e.emit("drain"));}(e,t),t.pendingcb--,r(),W(e,t);}function L(e,t){t.bufferProcessing=!0;var n=t.bufferedRequest;if(e._writev&&n&&n.next){var r=t.bufferedRequestCount,i=new Array(r),a=t.corkedRequestsFree;a.entry=n;for(var o=0,l=!0;n;)i[o]=n,n.isBuf||(l=!1),n=n.next,o+=1;i.allBuffers=l,P(e,t,!0,t.length,i,"",a.finish),t.pendingcb++,t.lastBufferedRequest=null,a.next?(t.corkedRequestsFree=a.next,a.next=null):t.corkedRequestsFree=new s(t),t.bufferedRequestCount=0;}else {for(;n;){var d=n.chunk,u=n.encoding,f=n.callback;if(P(e,t,!1,t.objectMode?1:d.length,d,u,f),n=n.next,t.bufferedRequestCount--,t.writing)break}null===n&&(t.lastBufferedRequest=null);}t.bufferedRequest=n,t.bufferProcessing=!1;}function C(e){return e.ending&&0===e.length&&null===e.bufferedRequest&&!e.finished&&!e.writing}function A(e,t){e._final((function(n){t.pendingcb--,n&&j(e,n),t.prefinished=!0,e.emit("prefinish"),W(e,t);}));}function W(e,t){var n=C(t);if(n&&(!function(e,t){t.prefinished||t.finalCalled||("function"!=typeof e._final||t.destroyed?(t.prefinished=!0,e.emit("prefinish")):(t.pendingcb++,t.finalCalled=!0,r.nextTick(A,e,t)));}(e,t),0===t.pendingcb&&(t.finished=!0,e.emit("finish"),t.autoDestroy))){var i=e._readableState;(!i||i.autoDestroy&&i.endEmitted)&&e.destroy();}return n}return t$2$2(x,d),T.prototype.getBuffer=function(){for(var e=this.bufferedRequest,t=[];e;)t.push(e),e=e.next;return t},function(){try{Object.defineProperty(T.prototype,"buffer",{get:l.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")});}catch(e){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(c=Function.prototype[Symbol.hasInstance],Object.defineProperty(x,Symbol.hasInstance,{value:function(e){return !!c.call(this,e)||this===x&&(e&&e._writableState instanceof T)}})):c=function(e){return e instanceof this},x.prototype.pipe=function(){j(this,new v);},x.prototype.write=function(e,t,n){var i,a=this._writableState,o=!1,s=!a.objectMode&&(i=e,f.isBuffer(i)||i instanceof h);return s&&!f.isBuffer(e)&&(e=function(e){return f.from(e)}(e)),"function"==typeof t&&(n=t,t=null),s?t="buffer":t||(t=a.defaultEncoding),"function"!=typeof n&&(n=O),a.ending?function(e,t){var n=new k;j(e,n),r.nextTick(t,n);}(this,n):(s||function(e,t,n,i){var a;return null===n?a=new R:"string"==typeof n||t.objectMode||(a=new y("chunk",["string","Buffer"],n)),!a||(j(e,a),r.nextTick(i,a),!1)}(this,a,e,n))&&(a.pendingcb++,o=function(e,t,n,r,i,a){if(!n){var o=function(e,t,n){e.objectMode||!1===e.decodeStrings||"string"!=typeof t||(t=f.from(t,n));return t}(t,r,i);r!==o&&(n=!0,i="buffer",r=o);}var s=t.objectMode?1:r.length;t.length+=s;var l=t.length<t.highWaterMark;l||(t.needDrain=!0);if(t.writing||t.corked){var d=t.lastBufferedRequest;t.lastBufferedRequest={chunk:r,encoding:i,isBuf:n,callback:a,next:null},d?d.next=t.lastBufferedRequest:t.bufferedRequest=t.lastBufferedRequest,t.bufferedRequestCount+=1;}else P(e,t,!1,s,r,i,a);return l}(this,a,s,e,t,n)),o},x.prototype.cork=function(){this._writableState.corked++;},x.prototype.uncork=function(){var e=this._writableState;e.corked&&(e.corked--,e.writing||e.corked||e.bufferProcessing||!e.bufferedRequest||L(this,e));},x.prototype.setDefaultEncoding=function(e){if("string"==typeof e&&(e=e.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((e+"").toLowerCase())>-1))throw new M(e);return this._writableState.defaultEncoding=e,this},Object.defineProperty(x.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(x.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),x.prototype._write=function(e,t,n){n(new w("_write()"));},x.prototype._writev=null,x.prototype.end=function(e,t,n){var i=this._writableState;return "function"==typeof e?(n=e,e=null,t=null):"function"==typeof t&&(n=t,t=null),null!=e&&this.write(e,t),i.corked&&(i.corked=1,this.uncork()),i.ending||function(e,t,n){t.ending=!0,W(e,t),n&&(t.finished?r.nextTick(n):e.once("finish",n));t.ended=!0,e.writable=!1;}(this,i,n),this},Object.defineProperty(x.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(x.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(e){this._writableState&&(this._writableState.destroyed=e);}}),x.prototype.destroy=b.destroy,x.prototype._undestroy=b.undestroy,x.prototype._destroy=function(e,t){t(e);},Y$1$1}var Q$1$1={},X$1$1=!1;function Z$1$1(){if(X$1$1)return Q$1$1;X$1$1=!0;var e=T$9,t=Object.keys||function(e){var t=[];for(var n in e)t.push(n);return t};Q$1$1=d;var n=G$1$1(),r=J$1$1();t$2$2(d,n);for(var a=t(r.prototype),s=0;s<a.length;s++){var l=a[s];d.prototype[l]||(d.prototype[l]=r.prototype[l]);}function d(e){if(!(this instanceof d))return new d(e);n.call(this,e),r.call(this,e),this.allowHalfOpen=!0,e&&(!1===e.readable&&(this.readable=!1),!1===e.writable&&(this.writable=!1),!1===e.allowHalfOpen&&(this.allowHalfOpen=!1,this.once("end",u)));}function u(){this._writableState.ended||e.nextTick(f,this);}function f(e){e.end();}return Object.defineProperty(d.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(d.prototype,"writableBuffer",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(d.prototype,"writableLength",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(d.prototype,"destroyed",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(e){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=e,this._writableState.destroyed=e);}}),Q$1$1}var t$4$1=J$1$1();var t$5$1=ee$1();var n$2$1;n$2$1=u$1$1;var i$e=e$1$1.codes,a$p=i$e.ERR_METHOD_NOT_IMPLEMENTED,o$s=i$e.ERR_MULTIPLE_CALLBACK,s$q=i$e.ERR_TRANSFORM_ALREADY_TRANSFORMING,f$2$1=i$e.ERR_TRANSFORM_WITH_LENGTH_0,h$2$1=t$5$1;function l$s(t,r){var e=this._transformState;e.transforming=!1;var n=e.writecb;if(null===n)return this.emit("error",new o$s);e.writechunk=null,e.writecb=null,null!=r&&this.push(r),n(t);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark);}function u$1$1(t){if(!(this instanceof u$1$1))return new u$1$1(t);h$2$1.call(this,t),this._transformState={afterTransform:l$s.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,t&&("function"==typeof t.transform&&(this._transform=t.transform),"function"==typeof t.flush&&(this._flush=t.flush)),this.on("prefinish",m$2$1);}function m$2$1(){var t=this;"function"!=typeof this._flush||this._readableState.destroyed?_$2$1(this,null,null):this._flush((function(r,e){_$2$1(t,r,e);}));}function _$2$1(t,r,e){if(r)return t.emit("error",r);if(null!=e&&t.push(e),t._writableState.length)throw new f$2$1;if(t._transformState.transforming)throw new s$q;return t.push(null)}t$2$2(u$1$1,h$2$1),u$1$1.prototype.push=function(t,r){return this._transformState.needTransform=!1,h$2$1.prototype.push.call(this,t,r)},u$1$1.prototype._transform=function(t,r,e){e(new a$p("_transform()"));},u$1$1.prototype._write=function(t,r,e){var n=this._transformState;if(n.writecb=e,n.writechunk=t,n.writeencoding=r,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark);}},u$1$1.prototype._read=function(t){var r=this._transformState;null===r.writechunk||r.transforming?r.needTransform=!0:(r.transforming=!0,this._transform(r.writechunk,r.writeencoding,r.afterTransform));},u$1$1.prototype._destroy=function(t,r){h$2$1.prototype._destroy.call(this,t,(function(t){r(t);}));};var p$2$1=n$2$1;var o$1$1;o$1$1=i$1$1;var e$3$1=p$2$1;function i$1$1(r){if(!(this instanceof i$1$1))return new i$1$1(r);e$3$1.call(this,r);}t$2$2(i$1$1,e$3$1),i$1$1.prototype._transform=function(r,t,o){o(null,r);};var s$1$1=o$1$1;var t$6$1;var o$2$1=e$1$1.codes,e$4$1=o$2$1.ERR_MISSING_ARGS,f$3$1=o$2$1.ERR_STREAM_DESTROYED;function i$2$1(r){if(r)throw r}function u$2$1(r,o,e,i){i=function(r){var n=!1;return function(){n||(n=!0,r.apply(void 0,arguments));}}(i);var u=!1;r.on("close",(function(){u=!0;})),void 0===t$6$1&&(t$6$1=n$1$1),t$6$1(r,{readable:o,writable:e},(function(r){if(r)return i(r);u=!0,i();}));var a=!1;return function(n){if(!u&&!a)return a=!0,function(r){return r.setHeader&&"function"==typeof r.abort}(r)?r.abort():"function"==typeof r.destroy?r.destroy():(i(n||new f$3$1("pipe")),void 0)}}function a$1$1(r){r();}function c$2$1(r,n){return r.pipe(n)}function p$3$1(r){return r.length?"function"!=typeof r[r.length-1]?i$2$1:r.pop():i$2$1}var v$2$1=function(){for(var r=arguments.length,n=new Array(r),t=0;t<r;t++)n[t]=arguments[t];var o,f=p$3$1(n);if(Array.isArray(n[0])&&(n=n[0]),n.length<2)throw new e$4$1("streams");var i=n.map((function(r,t){var e=t<n.length-1;return u$2$1(r,e,t>0,(function(r){o||(o=r),r&&i.forEach(a$1$1),e||(i.forEach(a$1$1),f(o));}))}));return n.reduce(c$2$1)};

var l$r,d$n="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global;l$r=p$r;var f$u=y$o.EventEmitter;function p$r(){f$u.call(this||d$n);}t$2$2(p$r,f$u),p$r.Readable=t$2$1,p$r.Writable=t$4$1,p$r.Duplex=t$5$1,p$r.Transform=p$2$1,p$r.PassThrough=s$1$1,p$r.finished=n$1$1,p$r.pipeline=v$2$1,p$r.Stream=p$r,p$r.prototype.pipe=function(e,r){var t=this||d$n;function o(r){e.writable&&!1===e.write(r)&&t.pause&&t.pause();}function i(){t.readable&&t.resume&&t.resume();}t.on("data",o),e.on("drain",i),e._isStdio||r&&!1===r.end||(t.on("end",a),t.on("close",s));var n=!1;function a(){n||(n=!0,e.end());}function s(){n||(n=!0,"function"==typeof e.destroy&&e.destroy());}function m(e){if(l(),0===f$u.listenerCount(this||d$n,"error"))throw e}function l(){t.removeListener("data",o),e.removeListener("drain",i),t.removeListener("end",a),t.removeListener("close",s),t.removeListener("error",m),e.removeListener("error",m),t.removeListener("end",l),t.removeListener("close",l),e.removeListener("close",l);}return t.on("error",m),e.on("error",m),t.on("end",l),t.on("close",l),e.on("close",l),e.emit("pipe",t),e};var b$i=l$r;b$i.Readable;b$i.Writable;b$i.Duplex;b$i.Transform;b$i.PassThrough;b$i.finished;b$i.pipeline;b$i.Stream;

var exports$1H = {},
    _dewExec$1G = false;

var _global$o = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1G() {
  if (_dewExec$1G) return exports$1H;
  _dewExec$1G = true;

  var Buffer = dew$1T().Buffer;

  var Transform = b$i.Transform;
  var StringDecoder = e$1$2.StringDecoder;

  var inherits = dew$f$2();

  function CipherBase(hashMode) {
    Transform.call(this || _global$o);
    (this || _global$o).hashMode = typeof hashMode === "string";

    if ((this || _global$o).hashMode) {
      (this || _global$o)[hashMode] = (this || _global$o)._finalOrDigest;
    } else {
      (this || _global$o).final = (this || _global$o)._finalOrDigest;
    }

    if ((this || _global$o)._final) {
      (this || _global$o).__final = (this || _global$o)._final;
      (this || _global$o)._final = null;
    }

    (this || _global$o)._decoder = null;
    (this || _global$o)._encoding = null;
  }

  inherits(CipherBase, Transform);

  CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
    if (typeof data === "string") {
      data = Buffer.from(data, inputEnc);
    }

    var outData = this._update(data);

    if ((this || _global$o).hashMode) return this || _global$o;

    if (outputEnc) {
      outData = this._toString(outData, outputEnc);
    }

    return outData;
  };

  CipherBase.prototype.setAutoPadding = function () {};

  CipherBase.prototype.getAuthTag = function () {
    throw new Error("trying to get auth tag in unsupported state");
  };

  CipherBase.prototype.setAuthTag = function () {
    throw new Error("trying to set auth tag in unsupported state");
  };

  CipherBase.prototype.setAAD = function () {
    throw new Error("trying to set aad in unsupported state");
  };

  CipherBase.prototype._transform = function (data, _, next) {
    var err;

    try {
      if ((this || _global$o).hashMode) {
        this._update(data);
      } else {
        this.push(this._update(data));
      }
    } catch (e) {
      err = e;
    } finally {
      next(err);
    }
  };

  CipherBase.prototype._flush = function (done) {
    var err;

    try {
      this.push(this.__final());
    } catch (e) {
      err = e;
    }

    done(err);
  };

  CipherBase.prototype._finalOrDigest = function (outputEnc) {
    var outData = this.__final() || Buffer.alloc(0);

    if (outputEnc) {
      outData = this._toString(outData, outputEnc, true);
    }

    return outData;
  };

  CipherBase.prototype._toString = function (value, enc, fin) {
    if (!(this || _global$o)._decoder) {
      (this || _global$o)._decoder = new StringDecoder(enc);
      (this || _global$o)._encoding = enc;
    }

    if ((this || _global$o)._encoding !== enc) throw new Error("can't switch encodings");

    var out = (this || _global$o)._decoder.write(value);

    if (fin) {
      out += (this || _global$o)._decoder.end();
    }

    return out;
  };

  exports$1H = CipherBase;
  return exports$1H;
}

var exports$1G = {},
    _dewExec$1F = false;
function dew$1F() {
  if (_dewExec$1F) return exports$1G;
  _dewExec$1F = true;

  var inherits = dew$f$2();

  var MD5 = dew$1Q();

  var RIPEMD160 = dew$1P();

  var sha = dew$1H();

  var Base = dew$1G();

  function Hash(hash) {
    Base.call(this, "digest");
    this._hash = hash;
  }

  inherits(Hash, Base);

  Hash.prototype._update = function (data) {
    this._hash.update(data);
  };

  Hash.prototype._final = function () {
    return this._hash.digest();
  };

  exports$1G = function createHash(alg) {
    alg = alg.toLowerCase();
    if (alg === "md5") return new MD5();
    if (alg === "rmd160" || alg === "ripemd160") return new RIPEMD160();
    return new Hash(sha(alg));
  };

  return exports$1G;
}

var exports$1F = {},
    _dewExec$1E = false;
function dew$1E() {
  if (_dewExec$1E) return exports$1F;
  _dewExec$1E = true;

  var inherits = dew$f$2();

  var Buffer = dew$1T().Buffer;

  var Base = dew$1G();

  var ZEROS = Buffer.alloc(128);
  var blocksize = 64;

  function Hmac(alg, key) {
    Base.call(this, "digest");

    if (typeof key === "string") {
      key = Buffer.from(key);
    }

    this._alg = alg;
    this._key = key;

    if (key.length > blocksize) {
      key = alg(key);
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize);
    }

    var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
    var opad = this._opad = Buffer.allocUnsafe(blocksize);

    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 54;
      opad[i] = key[i] ^ 92;
    }

    this._hash = [ipad];
  }

  inherits(Hmac, Base);

  Hmac.prototype._update = function (data) {
    this._hash.push(data);
  };

  Hmac.prototype._final = function () {
    var h = this._alg(Buffer.concat(this._hash));

    return this._alg(Buffer.concat([this._opad, h]));
  };

  exports$1F = Hmac;
  return exports$1F;
}

var exports$1E = {},
    _dewExec$1D = false;
function dew$1D() {
  if (_dewExec$1D) return exports$1E;
  _dewExec$1D = true;

  var MD5 = dew$1Q();

  exports$1E = function (buffer) {
    return new MD5().update(buffer).digest();
  };

  return exports$1E;
}

var exports$1D = {},
    _dewExec$1C = false;
function dew$1C() {
  if (_dewExec$1C) return exports$1D;
  _dewExec$1C = true;

  var inherits = dew$f$2();

  var Legacy = dew$1E();

  var Base = dew$1G();

  var Buffer = dew$1T().Buffer;

  var md5 = dew$1D();

  var RIPEMD160 = dew$1P();

  var sha = dew$1H();

  var ZEROS = Buffer.alloc(128);

  function Hmac(alg, key) {
    Base.call(this, "digest");

    if (typeof key === "string") {
      key = Buffer.from(key);
    }

    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;
    this._alg = alg;
    this._key = key;

    if (key.length > blocksize) {
      var hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);
      key = hash.update(key).digest();
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize);
    }

    var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
    var opad = this._opad = Buffer.allocUnsafe(blocksize);

    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 54;
      opad[i] = key[i] ^ 92;
    }

    this._hash = alg === "rmd160" ? new RIPEMD160() : sha(alg);

    this._hash.update(ipad);
  }

  inherits(Hmac, Base);

  Hmac.prototype._update = function (data) {
    this._hash.update(data);
  };

  Hmac.prototype._final = function () {
    var h = this._hash.digest();

    var hash = this._alg === "rmd160" ? new RIPEMD160() : sha(this._alg);
    return hash.update(this._opad).update(h).digest();
  };

  exports$1D = function createHmac(alg, key) {
    alg = alg.toLowerCase();

    if (alg === "rmd160" || alg === "ripemd160") {
      return new Hmac("rmd160", key);
    }

    if (alg === "md5") {
      return new Legacy(md5, key);
    }

    return new Hmac(alg, key);
  };

  return exports$1D;
}

var _algorithms = {
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
};

var exports$1C = {},
    _dewExec$1B = false;
function dew$1B() {
  if (_dewExec$1B) return exports$1C;
  _dewExec$1B = true;
  exports$1C = _algorithms;
  return exports$1C;
}

var exports$1B = {},
    _dewExec$1A = false;
function dew$1A() {
  if (_dewExec$1A) return exports$1B;
  _dewExec$1A = true;
  var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

  exports$1B = function (iterations, keylen) {
    if (typeof iterations !== "number") {
      throw new TypeError("Iterations not a number");
    }

    if (iterations < 0) {
      throw new TypeError("Bad iterations");
    }

    if (typeof keylen !== "number") {
      throw new TypeError("Key length not a number");
    }

    if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) {
      /* eslint no-self-compare: 0 */
      throw new TypeError("Bad key length");
    }
  };

  return exports$1B;
}

var exports$1A = {},
    _dewExec$1z = false;

var _global$n = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1z() {
  if (_dewExec$1z) return exports$1A;
  _dewExec$1z = true;
  var process = T$9;
  var defaultEncoding;
  /* istanbul ignore next */

  if (_global$n.process && _global$n.process.browser) {
    defaultEncoding = "utf-8";
  } else if (_global$n.process && _global$n.process.version) {
    var pVersionMajor = parseInt(process.version.split(".")[0].slice(1), 10);
    defaultEncoding = pVersionMajor >= 6 ? "utf-8" : "binary";
  } else {
    defaultEncoding = "utf-8";
  }

  exports$1A = defaultEncoding;
  return exports$1A;
}

var exports$1z = {},
    _dewExec$1y = false;
function dew$1y() {
  if (_dewExec$1y) return exports$1z;
  _dewExec$1y = true;

  var Buffer = dew$1T().Buffer;

  exports$1z = function (thing, encoding, name) {
    if (Buffer.isBuffer(thing)) {
      return thing;
    } else if (typeof thing === "string") {
      return Buffer.from(thing, encoding);
    } else if (ArrayBuffer.isView(thing)) {
      return Buffer.from(thing.buffer);
    } else {
      throw new TypeError(name + " must be a string, a Buffer, a typed array or a DataView");
    }
  };

  return exports$1z;
}

var exports$1y = {},
    _dewExec$1x = false;

var _global$m = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1x() {
  if (_dewExec$1x) return exports$1y;
  _dewExec$1x = true;

  var md5 = dew$1D();

  var RIPEMD160 = dew$1P();

  var sha = dew$1H();

  var Buffer = dew$1T().Buffer;

  var checkParameters = dew$1A();

  var defaultEncoding = dew$1z();

  var toBuffer = dew$1y();

  var ZEROS = Buffer.alloc(128);
  var sizes = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };

  function Hmac(alg, key, saltLen) {
    var hash = getDigest(alg);
    var blocksize = alg === "sha512" || alg === "sha384" ? 128 : 64;

    if (key.length > blocksize) {
      key = hash(key);
    } else if (key.length < blocksize) {
      key = Buffer.concat([key, ZEROS], blocksize);
    }

    var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
    var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);

    for (var i = 0; i < blocksize; i++) {
      ipad[i] = key[i] ^ 54;
      opad[i] = key[i] ^ 92;
    }

    var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
    ipad.copy(ipad1, 0, 0, blocksize);
    (this || _global$m).ipad1 = ipad1;
    (this || _global$m).ipad2 = ipad;
    (this || _global$m).opad = opad;
    (this || _global$m).alg = alg;
    (this || _global$m).blocksize = blocksize;
    (this || _global$m).hash = hash;
    (this || _global$m).size = sizes[alg];
  }

  Hmac.prototype.run = function (data, ipad) {
    data.copy(ipad, (this || _global$m).blocksize);
    var h = this.hash(ipad);
    h.copy((this || _global$m).opad, (this || _global$m).blocksize);
    return this.hash((this || _global$m).opad);
  };

  function getDigest(alg) {
    function shaFunc(data) {
      return sha(alg).update(data).digest();
    }

    function rmd160Func(data) {
      return new RIPEMD160().update(data).digest();
    }

    if (alg === "rmd160" || alg === "ripemd160") return rmd160Func;
    if (alg === "md5") return md5;
    return shaFunc;
  }

  function pbkdf2(password, salt, iterations, keylen, digest) {
    checkParameters(iterations, keylen);
    password = toBuffer(password, defaultEncoding, "Password");
    salt = toBuffer(salt, defaultEncoding, "Salt");
    digest = digest || "sha1";
    var hmac = new Hmac(digest, password, salt.length);
    var DK = Buffer.allocUnsafe(keylen);
    var block1 = Buffer.allocUnsafe(salt.length + 4);
    salt.copy(block1, 0, 0, salt.length);
    var destPos = 0;
    var hLen = sizes[digest];
    var l = Math.ceil(keylen / hLen);

    for (var i = 1; i <= l; i++) {
      block1.writeUInt32BE(i, salt.length);
      var T = hmac.run(block1, hmac.ipad1);
      var U = T;

      for (var j = 1; j < iterations; j++) {
        U = hmac.run(U, hmac.ipad2);

        for (var k = 0; k < hLen; k++) T[k] ^= U[k];
      }

      T.copy(DK, destPos);
      destPos += hLen;
    }

    return DK;
  }

  exports$1y = pbkdf2;
  return exports$1y;
}

var exports$1x = {},
    _dewExec$1w = false;

var _global$l = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1w() {
  if (_dewExec$1w) return exports$1x;
  _dewExec$1w = true;

  var Buffer = dew$1T().Buffer;

  var checkParameters = dew$1A();

  var defaultEncoding = dew$1z();

  var sync = dew$1x();

  var toBuffer = dew$1y();

  var ZERO_BUF;
  var subtle = _global$l.crypto && _global$l.crypto.subtle;
  var toBrowser = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  };
  var checks = [];

  function checkNative(algo) {
    if (_global$l.process && !_global$l.process.browser) {
      return Promise.resolve(false);
    }

    if (!subtle || !subtle.importKey || !subtle.deriveBits) {
      return Promise.resolve(false);
    }

    if (checks[algo] !== undefined) {
      return checks[algo];
    }

    ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
    var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo).then(function () {
      return true;
    }).catch(function () {
      return false;
    });
    checks[algo] = prom;
    return prom;
  }

  var nextTick;

  function getNextTick() {
    if (nextTick) {
      return nextTick;
    }

    if (_global$l.process && _global$l.process.nextTick) {
      nextTick = _global$l.process.nextTick;
    } else if (_global$l.queueMicrotask) {
      nextTick = _global$l.queueMicrotask;
    } else if (_global$l.setImmediate) {
      nextTick = _global$l.setImmediate;
    } else {
      nextTick = _global$l.setTimeout;
    }

    return nextTick;
  }

  function browserPbkdf2(password, salt, iterations, length, algo) {
    return subtle.importKey("raw", password, {
      name: "PBKDF2"
    }, false, ["deriveBits"]).then(function (key) {
      return subtle.deriveBits({
        name: "PBKDF2",
        salt: salt,
        iterations: iterations,
        hash: {
          name: algo
        }
      }, key, length << 3);
    }).then(function (res) {
      return Buffer.from(res);
    });
  }

  function resolvePromise(promise, callback) {
    promise.then(function (out) {
      getNextTick()(function () {
        callback(null, out);
      });
    }, function (e) {
      getNextTick()(function () {
        callback(e);
      });
    });
  }

  exports$1x = function (password, salt, iterations, keylen, digest, callback) {
    if (typeof digest === "function") {
      callback = digest;
      digest = undefined;
    }

    digest = digest || "sha1";
    var algo = toBrowser[digest.toLowerCase()];

    if (!algo || typeof _global$l.Promise !== "function") {
      getNextTick()(function () {
        var out;

        try {
          out = sync(password, salt, iterations, keylen, digest);
        } catch (e) {
          return callback(e);
        }

        callback(null, out);
      });
      return;
    }

    checkParameters(iterations, keylen);
    password = toBuffer(password, defaultEncoding, "Password");
    salt = toBuffer(salt, defaultEncoding, "Salt");
    if (typeof callback !== "function") throw new Error("No callback provided to pbkdf2");
    resolvePromise(checkNative(algo).then(function (resp) {
      if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo);
      return sync(password, salt, iterations, keylen, digest);
    }), callback);
  };

  return exports$1x;
}

var exports$1w = {},
    _dewExec$1v = false;
function dew$1v() {
  if (_dewExec$1v) return exports$1w;
  _dewExec$1v = true;
  exports$1w.pbkdf2 = dew$1w();
  exports$1w.pbkdf2Sync = dew$1x();
  return exports$1w;
}

var exports$1v = {},
    _dewExec$1u = false;
function dew$1u() {
  if (_dewExec$1u) return exports$1v;
  _dewExec$1u = true;

  exports$1v.readUInt32BE = function readUInt32BE(bytes, off) {
    var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
    return res >>> 0;
  };

  exports$1v.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
    bytes[0 + off] = value >>> 24;
    bytes[1 + off] = value >>> 16 & 255;
    bytes[2 + off] = value >>> 8 & 255;
    bytes[3 + off] = value & 255;
  };

  exports$1v.ip = function ip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >>> j + i & 1;
      }

      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inL >>> j + i & 1;
      }
    }

    for (var i = 6; i >= 0; i -= 2) {
      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= inR >>> j + i & 1;
      }

      for (var j = 1; j <= 25; j += 8) {
        outR <<= 1;
        outR |= inL >>> j + i & 1;
      }
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports$1v.rip = function rip(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;

    for (var i = 0; i < 4; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outL <<= 1;
        outL |= inR >>> j + i & 1;
        outL <<= 1;
        outL |= inL >>> j + i & 1;
      }
    }

    for (var i = 4; i < 8; i++) {
      for (var j = 24; j >= 0; j -= 8) {
        outR <<= 1;
        outR |= inR >>> j + i & 1;
        outR <<= 1;
        outR |= inL >>> j + i & 1;
      }
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports$1v.pc1 = function pc1(inL, inR, out, off) {
    var outL = 0;
    var outR = 0; // 7, 15, 23, 31, 39, 47, 55, 63
    // 6, 14, 22, 30, 39, 47, 55, 63
    // 5, 13, 21, 29, 39, 47, 55, 63
    // 4, 12, 20, 28

    for (var i = 7; i >= 5; i--) {
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }

      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inL >> j + i & 1;
      }
    }

    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= inR >> j + i & 1;
    } // 1, 9, 17, 25, 33, 41, 49, 57
    // 2, 10, 18, 26, 34, 42, 50, 58
    // 3, 11, 19, 27, 35, 43, 51, 59
    // 36, 44, 52, 60


    for (var i = 1; i <= 3; i++) {
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inR >> j + i & 1;
      }

      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i & 1;
      }
    }

    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= inL >> j + i & 1;
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports$1v.r28shl = function r28shl(num, shift) {
    return num << shift & 268435455 | num >>> 28 - shift;
  };

  var pc2table = [// inL => outL
  14, 11, 17, 4, 27, 23, 25, 0, 13, 22, 7, 18, 5, 9, 16, 24, 2, 20, 12, 21, 1, 8, 15, 26, // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24];

  exports$1v.pc2 = function pc2(inL, inR, out, off) {
    var outL = 0;
    var outR = 0;
    var len = pc2table.length >>> 1;

    for (var i = 0; i < len; i++) {
      outL <<= 1;
      outL |= inL >>> pc2table[i] & 1;
    }

    for (var i = len; i < pc2table.length; i++) {
      outR <<= 1;
      outR |= inR >>> pc2table[i] & 1;
    }

    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  exports$1v.expand = function expand(r, out, off) {
    var outL = 0;
    var outR = 0;
    outL = (r & 1) << 5 | r >>> 27;

    for (var i = 23; i >= 15; i -= 4) {
      outL <<= 6;
      outL |= r >>> i & 63;
    }

    for (var i = 11; i >= 3; i -= 4) {
      outR |= r >>> i & 63;
      outR <<= 6;
    }

    outR |= (r & 31) << 1 | r >>> 31;
    out[off + 0] = outL >>> 0;
    out[off + 1] = outR >>> 0;
  };

  var sTable = [14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1, 3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8, 4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7, 15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13, 15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14, 9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5, 0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2, 5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9, 10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10, 1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1, 13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7, 11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12, 7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3, 1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9, 10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8, 15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14, 2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1, 8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6, 4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13, 15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3, 12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5, 0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8, 9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10, 7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13, 4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10, 3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6, 1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7, 10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12, 13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4, 10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2, 7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13, 0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11];

  exports$1v.substitute = function substitute(inL, inR) {
    var out = 0;

    for (var i = 0; i < 4; i++) {
      var b = inL >>> 18 - i * 6 & 63;
      var sb = sTable[i * 64 + b];
      out <<= 4;
      out |= sb;
    }

    for (var i = 0; i < 4; i++) {
      var b = inR >>> 18 - i * 6 & 63;
      var sb = sTable[4 * 64 + i * 64 + b];
      out <<= 4;
      out |= sb;
    }

    return out >>> 0;
  };

  var permuteTable = [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7];

  exports$1v.permute = function permute(num) {
    var out = 0;

    for (var i = 0; i < permuteTable.length; i++) {
      out <<= 1;
      out |= num >>> permuteTable[i] & 1;
    }

    return out >>> 0;
  };

  exports$1v.padSplit = function padSplit(num, size, group) {
    var str = num.toString(2);

    while (str.length < size) str = "0" + str;

    var out = [];

    for (var i = 0; i < size; i += group) out.push(str.slice(i, i + group));

    return out.join(" ");
  };

  return exports$1v;
}

var exports$1u = {},
    _dewExec$1t = false;
function dew$1t() {
  if (_dewExec$1t) return exports$1u;
  _dewExec$1t = true;
  exports$1u = assert;

  function assert(val, msg) {
    if (!val) throw new Error(msg || "Assertion failed");
  }

  assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || "Assertion failed: " + l + " != " + r);
  };

  return exports$1u;
}

var exports$1t = {},
    _dewExec$1s = false;
function dew$1s() {
  if (_dewExec$1s) return exports$1t;
  _dewExec$1s = true;

  var assert = dew$1t();

  function Cipher(options) {
    this.options = options;
    this.type = this.options.type;
    this.blockSize = 8;

    this._init();

    this.buffer = new Array(this.blockSize);
    this.bufferOff = 0;
  }

  exports$1t = Cipher;

  Cipher.prototype._init = function _init() {// Might be overrided
  };

  Cipher.prototype.update = function update(data) {
    if (data.length === 0) return [];
    if (this.type === "decrypt") return this._updateDecrypt(data);else return this._updateEncrypt(data);
  };

  Cipher.prototype._buffer = function _buffer(data, off) {
    // Append data to buffer
    var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);

    for (var i = 0; i < min; i++) this.buffer[this.bufferOff + i] = data[off + i];

    this.bufferOff += min; // Shift next

    return min;
  };

  Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
    this._update(this.buffer, 0, out, off);

    this.bufferOff = 0;
    return this.blockSize;
  };

  Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
    var inputOff = 0;
    var outputOff = 0;
    var count = (this.bufferOff + data.length) / this.blockSize | 0;
    var out = new Array(count * this.blockSize);

    if (this.bufferOff !== 0) {
      inputOff += this._buffer(data, inputOff);
      if (this.bufferOff === this.buffer.length) outputOff += this._flushBuffer(out, outputOff);
    } // Write blocks


    var max = data.length - (data.length - inputOff) % this.blockSize;

    for (; inputOff < max; inputOff += this.blockSize) {
      this._update(data, inputOff, out, outputOff);

      outputOff += this.blockSize;
    } // Queue rest


    for (; inputOff < data.length; inputOff++, this.bufferOff++) this.buffer[this.bufferOff] = data[inputOff];

    return out;
  };

  Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
    var inputOff = 0;
    var outputOff = 0;
    var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
    var out = new Array(count * this.blockSize); // TODO(indutny): optimize it, this is far from optimal

    for (; count > 0; count--) {
      inputOff += this._buffer(data, inputOff);
      outputOff += this._flushBuffer(out, outputOff);
    } // Buffer rest of the input


    inputOff += this._buffer(data, inputOff);
    return out;
  };

  Cipher.prototype.final = function final(buffer) {
    var first;
    if (buffer) first = this.update(buffer);
    var last;
    if (this.type === "encrypt") last = this._finalEncrypt();else last = this._finalDecrypt();
    if (first) return first.concat(last);else return last;
  };

  Cipher.prototype._pad = function _pad(buffer, off) {
    if (off === 0) return false;

    while (off < buffer.length) buffer[off++] = 0;

    return true;
  };

  Cipher.prototype._finalEncrypt = function _finalEncrypt() {
    if (!this._pad(this.buffer, this.bufferOff)) return [];
    var out = new Array(this.blockSize);

    this._update(this.buffer, 0, out, 0);

    return out;
  };

  Cipher.prototype._unpad = function _unpad(buffer) {
    return buffer;
  };

  Cipher.prototype._finalDecrypt = function _finalDecrypt() {
    assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var out = new Array(this.blockSize);

    this._flushBuffer(out, 0);

    return this._unpad(out);
  };

  return exports$1t;
}

var exports$1s = {},
    _dewExec$1r = false;
function dew$1r() {
  if (_dewExec$1r) return exports$1s;
  _dewExec$1r = true;

  var assert = dew$1t();

  var inherits = dew$f$2();

  var utils = dew$1u();

  var Cipher = dew$1s();

  function DESState() {
    this.tmp = new Array(2);
    this.keys = null;
  }

  function DES(options) {
    Cipher.call(this, options);
    var state = new DESState();
    this._desState = state;
    this.deriveKeys(state, options.key);
  }

  inherits(DES, Cipher);
  exports$1s = DES;

  DES.create = function create(options) {
    return new DES(options);
  };

  var shiftTable = [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1];

  DES.prototype.deriveKeys = function deriveKeys(state, key) {
    state.keys = new Array(16 * 2);
    assert.equal(key.length, this.blockSize, "Invalid key length");
    var kL = utils.readUInt32BE(key, 0);
    var kR = utils.readUInt32BE(key, 4);
    utils.pc1(kL, kR, state.tmp, 0);
    kL = state.tmp[0];
    kR = state.tmp[1];

    for (var i = 0; i < state.keys.length; i += 2) {
      var shift = shiftTable[i >>> 1];
      kL = utils.r28shl(kL, shift);
      kR = utils.r28shl(kR, shift);
      utils.pc2(kL, kR, state.keys, i);
    }
  };

  DES.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._desState;
    var l = utils.readUInt32BE(inp, inOff);
    var r = utils.readUInt32BE(inp, inOff + 4); // Initial Permutation

    utils.ip(l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    if (this.type === "encrypt") this._encrypt(state, l, r, state.tmp, 0);else this._decrypt(state, l, r, state.tmp, 0);
    l = state.tmp[0];
    r = state.tmp[1];
    utils.writeUInt32BE(out, l, outOff);
    utils.writeUInt32BE(out, r, outOff + 4);
  };

  DES.prototype._pad = function _pad(buffer, off) {
    var value = buffer.length - off;

    for (var i = off; i < buffer.length; i++) buffer[i] = value;

    return true;
  };

  DES.prototype._unpad = function _unpad(buffer) {
    var pad = buffer[buffer.length - 1];

    for (var i = buffer.length - pad; i < buffer.length; i++) assert.equal(buffer[i], pad);

    return buffer.slice(0, buffer.length - pad);
  };

  DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
    var l = lStart;
    var r = rStart; // Apply f() x16 times

    for (var i = 0; i < state.keys.length; i += 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1]; // f(r, k)

      utils.expand(r, state.tmp, 0);
      keyL ^= state.tmp[0];
      keyR ^= state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var f = utils.permute(s);
      var t = r;
      r = (l ^ f) >>> 0;
      l = t;
    } // Reverse Initial Permutation


    utils.rip(r, l, out, off);
  };

  DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
    var l = rStart;
    var r = lStart; // Apply f() x16 times

    for (var i = state.keys.length - 2; i >= 0; i -= 2) {
      var keyL = state.keys[i];
      var keyR = state.keys[i + 1]; // f(r, k)

      utils.expand(l, state.tmp, 0);
      keyL ^= state.tmp[0];
      keyR ^= state.tmp[1];
      var s = utils.substitute(keyL, keyR);
      var f = utils.permute(s);
      var t = l;
      l = (r ^ f) >>> 0;
      r = t;
    } // Reverse Initial Permutation


    utils.rip(l, r, out, off);
  };

  return exports$1s;
}

var exports$1r = {},
    _dewExec$1q = false;
function dew$1q() {
  if (_dewExec$1q) return exports$1r;
  _dewExec$1q = true;

  var assert = dew$1t();

  var inherits = dew$f$2();

  var proto = {};

  function CBCState(iv) {
    assert.equal(iv.length, 8, "Invalid IV length");
    this.iv = new Array(8);

    for (var i = 0; i < this.iv.length; i++) this.iv[i] = iv[i];
  }

  function instantiate(Base) {
    function CBC(options) {
      Base.call(this, options);

      this._cbcInit();
    }

    inherits(CBC, Base);
    var keys = Object.keys(proto);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      CBC.prototype[key] = proto[key];
    }

    CBC.create = function create(options) {
      return new CBC(options);
    };

    return CBC;
  }

  exports$1r.instantiate = instantiate;

  proto._cbcInit = function _cbcInit() {
    var state = new CBCState(this.options.iv);
    this._cbcState = state;
  };

  proto._update = function _update(inp, inOff, out, outOff) {
    var state = this._cbcState;
    var superProto = this.constructor.super_.prototype;
    var iv = state.iv;

    if (this.type === "encrypt") {
      for (var i = 0; i < this.blockSize; i++) iv[i] ^= inp[inOff + i];

      superProto._update.call(this, iv, 0, out, outOff);

      for (var i = 0; i < this.blockSize; i++) iv[i] = out[outOff + i];
    } else {
      superProto._update.call(this, inp, inOff, out, outOff);

      for (var i = 0; i < this.blockSize; i++) out[outOff + i] ^= iv[i];

      for (var i = 0; i < this.blockSize; i++) iv[i] = inp[inOff + i];
    }
  };

  return exports$1r;
}

var exports$1q = {},
    _dewExec$1p = false;
function dew$1p() {
  if (_dewExec$1p) return exports$1q;
  _dewExec$1p = true;

  var assert = dew$1t();

  var inherits = dew$f$2();

  var Cipher = dew$1s();

  var DES = dew$1r();

  function EDEState(type, key) {
    assert.equal(key.length, 24, "Invalid key length");
    var k1 = key.slice(0, 8);
    var k2 = key.slice(8, 16);
    var k3 = key.slice(16, 24);

    if (type === "encrypt") {
      this.ciphers = [DES.create({
        type: "encrypt",
        key: k1
      }), DES.create({
        type: "decrypt",
        key: k2
      }), DES.create({
        type: "encrypt",
        key: k3
      })];
    } else {
      this.ciphers = [DES.create({
        type: "decrypt",
        key: k3
      }), DES.create({
        type: "encrypt",
        key: k2
      }), DES.create({
        type: "decrypt",
        key: k1
      })];
    }
  }

  function EDE(options) {
    Cipher.call(this, options);
    var state = new EDEState(this.type, this.options.key);
    this._edeState = state;
  }

  inherits(EDE, Cipher);
  exports$1q = EDE;

  EDE.create = function create(options) {
    return new EDE(options);
  };

  EDE.prototype._update = function _update(inp, inOff, out, outOff) {
    var state = this._edeState;

    state.ciphers[0]._update(inp, inOff, out, outOff);

    state.ciphers[1]._update(out, outOff, out, outOff);

    state.ciphers[2]._update(out, outOff, out, outOff);
  };

  EDE.prototype._pad = DES.prototype._pad;
  EDE.prototype._unpad = DES.prototype._unpad;
  return exports$1q;
}

var exports$1p = {},
    _dewExec$1o = false;
function dew$1o() {
  if (_dewExec$1o) return exports$1p;
  _dewExec$1o = true;
  exports$1p.utils = dew$1u();
  exports$1p.Cipher = dew$1s();
  exports$1p.DES = dew$1r();
  exports$1p.CBC = dew$1q();
  exports$1p.EDE = dew$1p();
  return exports$1p;
}

var exports$1o = {},
    _dewExec$1n = false;

var _global$k = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1n() {
  if (_dewExec$1n) return exports$1o;
  _dewExec$1n = true;

  var CipherBase = dew$1G();

  var des = dew$1o();

  var inherits = dew$f$2();

  var Buffer = dew$1T().Buffer;

  var modes = {
    "des-ede3-cbc": des.CBC.instantiate(des.EDE),
    "des-ede3": des.EDE,
    "des-ede-cbc": des.CBC.instantiate(des.EDE),
    "des-ede": des.EDE,
    "des-cbc": des.CBC.instantiate(des.DES),
    "des-ecb": des.DES
  };
  modes.des = modes["des-cbc"];
  modes.des3 = modes["des-ede3-cbc"];
  exports$1o = DES;
  inherits(DES, CipherBase);

  function DES(opts) {
    CipherBase.call(this || _global$k);
    var modeName = opts.mode.toLowerCase();
    var mode = modes[modeName];
    var type;

    if (opts.decrypt) {
      type = "decrypt";
    } else {
      type = "encrypt";
    }

    var key = opts.key;

    if (!Buffer.isBuffer(key)) {
      key = Buffer.from(key);
    }

    if (modeName === "des-ede" || modeName === "des-ede-cbc") {
      key = Buffer.concat([key, key.slice(0, 8)]);
    }

    var iv = opts.iv;

    if (!Buffer.isBuffer(iv)) {
      iv = Buffer.from(iv);
    }

    (this || _global$k)._des = mode.create({
      key: key,
      iv: iv,
      type: type
    });
  }

  DES.prototype._update = function (data) {
    return Buffer.from((this || _global$k)._des.update(data));
  };

  DES.prototype._final = function () {
    return Buffer.from((this || _global$k)._des.final());
  };

  return exports$1o;
}

var exports$1n = {},
    _dewExec$1m = false;
function dew$1m() {
  if (_dewExec$1m) return exports$1n;
  _dewExec$1m = true;

  exports$1n.encrypt = function (self, block) {
    return self._cipher.encryptBlock(block);
  };

  exports$1n.decrypt = function (self, block) {
    return self._cipher.decryptBlock(block);
  };

  return exports$1n;
}

var exports$1m = {},
    _dewExec$1l = false;
function dew$1l() {
  if (_dewExec$1l) return exports$1m;
  _dewExec$1l = true;
  var Buffer = e$1$1$1.Buffer;

  exports$1m = function xor(a, b) {
    var length = Math.min(a.length, b.length);
    var buffer = new Buffer(length);

    for (var i = 0; i < length; ++i) {
      buffer[i] = a[i] ^ b[i];
    }

    return buffer;
  };

  return exports$1m;
}

var exports$1l = {},
    _dewExec$1k = false;
function dew$1k() {
  if (_dewExec$1k) return exports$1l;
  _dewExec$1k = true;

  var xor = dew$1l();

  exports$1l.encrypt = function (self, block) {
    var data = xor(block, self._prev);
    self._prev = self._cipher.encryptBlock(data);
    return self._prev;
  };

  exports$1l.decrypt = function (self, block) {
    var pad = self._prev;
    self._prev = block;

    var out = self._cipher.decryptBlock(block);

    return xor(out, pad);
  };

  return exports$1l;
}

var exports$1k = {},
    _dewExec$1j = false;
function dew$1j() {
  if (_dewExec$1j) return exports$1k;
  _dewExec$1j = true;

  var Buffer = dew$1T().Buffer;

  var xor = dew$1l();

  function encryptStart(self, data, decrypt) {
    var len = data.length;
    var out = xor(data, self._cache);
    self._cache = self._cache.slice(len);
    self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
    return out;
  }

  exports$1k.encrypt = function (self, data, decrypt) {
    var out = Buffer.allocUnsafe(0);
    var len;

    while (data.length) {
      if (self._cache.length === 0) {
        self._cache = self._cipher.encryptBlock(self._prev);
        self._prev = Buffer.allocUnsafe(0);
      }

      if (self._cache.length <= data.length) {
        len = self._cache.length;
        out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
        data = data.slice(len);
      } else {
        out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
        break;
      }
    }

    return out;
  };

  return exports$1k;
}

var exports$1j = {},
    _dewExec$1i = false;
function dew$1i() {
  if (_dewExec$1i) return exports$1j;
  _dewExec$1i = true;

  var Buffer = dew$1T().Buffer;

  function encryptByte(self, byteParam, decrypt) {
    var pad = self._cipher.encryptBlock(self._prev);

    var out = pad[0] ^ byteParam;
    self._prev = Buffer.concat([self._prev.slice(1), Buffer.from([decrypt ? byteParam : out])]);
    return out;
  }

  exports$1j.encrypt = function (self, chunk, decrypt) {
    var len = chunk.length;
    var out = Buffer.allocUnsafe(len);
    var i = -1;

    while (++i < len) {
      out[i] = encryptByte(self, chunk[i], decrypt);
    }

    return out;
  };

  return exports$1j;
}

var exports$1i = {},
    _dewExec$1h = false;
function dew$1h() {
  if (_dewExec$1h) return exports$1i;
  _dewExec$1h = true;

  var Buffer = dew$1T().Buffer;

  function encryptByte(self, byteParam, decrypt) {
    var pad;
    var i = -1;
    var len = 8;
    var out = 0;
    var bit, value;

    while (++i < len) {
      pad = self._cipher.encryptBlock(self._prev);
      bit = byteParam & 1 << 7 - i ? 128 : 0;
      value = pad[0] ^ bit;
      out += (value & 128) >> i % 8;
      self._prev = shiftIn(self._prev, decrypt ? bit : value);
    }

    return out;
  }

  function shiftIn(buffer, value) {
    var len = buffer.length;
    var i = -1;
    var out = Buffer.allocUnsafe(buffer.length);
    buffer = Buffer.concat([buffer, Buffer.from([value])]);

    while (++i < len) {
      out[i] = buffer[i] << 1 | buffer[i + 1] >> 7;
    }

    return out;
  }

  exports$1i.encrypt = function (self, chunk, decrypt) {
    var len = chunk.length;
    var out = Buffer.allocUnsafe(len);
    var i = -1;

    while (++i < len) {
      out[i] = encryptByte(self, chunk[i], decrypt);
    }

    return out;
  };

  return exports$1i;
}

var exports$1h = {},
    _dewExec$1g = false;
function dew$1g() {
  if (_dewExec$1g) return exports$1h;
  _dewExec$1g = true;
  var Buffer = e$1$1$1.Buffer;

  var xor = dew$1l();

  function getBlock(self) {
    self._prev = self._cipher.encryptBlock(self._prev);
    return self._prev;
  }

  exports$1h.encrypt = function (self, chunk) {
    while (self._cache.length < chunk.length) {
      self._cache = Buffer.concat([self._cache, getBlock(self)]);
    }

    var pad = self._cache.slice(0, chunk.length);

    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
  };

  return exports$1h;
}

var exports$1g = {},
    _dewExec$1f = false;
function dew$1f() {
  if (_dewExec$1f) return exports$1g;
  _dewExec$1f = true;

  function incr32(iv) {
    var len = iv.length;
    var item;

    while (len--) {
      item = iv.readUInt8(len);

      if (item === 255) {
        iv.writeUInt8(0, len);
      } else {
        item++;
        iv.writeUInt8(item, len);
        break;
      }
    }
  }

  exports$1g = incr32;
  return exports$1g;
}

var exports$1f = {},
    _dewExec$1e = false;
function dew$1e() {
  if (_dewExec$1e) return exports$1f;
  _dewExec$1e = true;

  var xor = dew$1l();

  var Buffer = dew$1T().Buffer;

  var incr32 = dew$1f();

  function getBlock(self) {
    var out = self._cipher.encryptBlockRaw(self._prev);

    incr32(self._prev);
    return out;
  }

  var blockSize = 16;

  exports$1f.encrypt = function (self, chunk) {
    var chunkNum = Math.ceil(chunk.length / blockSize);
    var start = self._cache.length;
    self._cache = Buffer.concat([self._cache, Buffer.allocUnsafe(chunkNum * blockSize)]);

    for (var i = 0; i < chunkNum; i++) {
      var out = getBlock(self);
      var offset = start + i * blockSize;

      self._cache.writeUInt32BE(out[0], offset + 0);

      self._cache.writeUInt32BE(out[1], offset + 4);

      self._cache.writeUInt32BE(out[2], offset + 8);

      self._cache.writeUInt32BE(out[3], offset + 12);
    }

    var pad = self._cache.slice(0, chunk.length);

    self._cache = self._cache.slice(chunk.length);
    return xor(chunk, pad);
  };

  return exports$1f;
}

var _list = {
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
};

var exports$1e = {},
    _dewExec$1d = false;
function dew$1d() {
  if (_dewExec$1d) return exports$1e;
  _dewExec$1d = true;
  var modeModules = {
    ECB: dew$1m(),
    CBC: dew$1k(),
    CFB: dew$1j(),
    CFB8: dew$1i(),
    CFB1: dew$1h(),
    OFB: dew$1g(),
    CTR: dew$1e(),
    GCM: dew$1e()
  };
  var modes = _list;

  for (var key in modes) {
    modes[key].module = modeModules[modes[key].mode];
  }

  exports$1e = modes;
  return exports$1e;
}

var exports$1d = {},
    _dewExec$1c = false;

var _global$j = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1c() {
  if (_dewExec$1c) return exports$1d;
  _dewExec$1c = true;

  // based on the aes implimentation in triple sec
  // https://github.com/keybase/triplesec
  // which is in turn based on the one from crypto-js
  // https://code.google.com/p/crypto-js/
  var Buffer = dew$1T().Buffer;

  function asUInt32Array(buf) {
    if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
    var len = buf.length / 4 | 0;
    var out = new Array(len);

    for (var i = 0; i < len; i++) {
      out[i] = buf.readUInt32BE(i * 4);
    }

    return out;
  }

  function scrubVec(v) {
    for (var i = 0; i < v.length; v++) {
      v[i] = 0;
    }
  }

  function cryptBlock(M, keySchedule, SUB_MIX, SBOX, nRounds) {
    var SUB_MIX0 = SUB_MIX[0];
    var SUB_MIX1 = SUB_MIX[1];
    var SUB_MIX2 = SUB_MIX[2];
    var SUB_MIX3 = SUB_MIX[3];
    var s0 = M[0] ^ keySchedule[0];
    var s1 = M[1] ^ keySchedule[1];
    var s2 = M[2] ^ keySchedule[2];
    var s3 = M[3] ^ keySchedule[3];
    var t0, t1, t2, t3;
    var ksRow = 4;

    for (var round = 1; round < nRounds; round++) {
      t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[s1 >>> 16 & 255] ^ SUB_MIX2[s2 >>> 8 & 255] ^ SUB_MIX3[s3 & 255] ^ keySchedule[ksRow++];
      t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[s2 >>> 16 & 255] ^ SUB_MIX2[s3 >>> 8 & 255] ^ SUB_MIX3[s0 & 255] ^ keySchedule[ksRow++];
      t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[s3 >>> 16 & 255] ^ SUB_MIX2[s0 >>> 8 & 255] ^ SUB_MIX3[s1 & 255] ^ keySchedule[ksRow++];
      t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[s0 >>> 16 & 255] ^ SUB_MIX2[s1 >>> 8 & 255] ^ SUB_MIX3[s2 & 255] ^ keySchedule[ksRow++];
      s0 = t0;
      s1 = t1;
      s2 = t2;
      s3 = t3;
    }

    t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow++];
    t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow++];
    t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow++];
    t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow++];
    t0 = t0 >>> 0;
    t1 = t1 >>> 0;
    t2 = t2 >>> 0;
    t3 = t3 >>> 0;
    return [t0, t1, t2, t3];
  } // AES constants


  var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];

  var G = function () {
    // Compute double table
    var d = new Array(256);

    for (var j = 0; j < 256; j++) {
      if (j < 128) {
        d[j] = j << 1;
      } else {
        d[j] = j << 1 ^ 283;
      }
    }

    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX = [[], [], [], []];
    var INV_SUB_MIX = [[], [], [], []]; // Walk GF(2^8)

    var x = 0;
    var xi = 0;

    for (var i = 0; i < 256; ++i) {
      // Compute sbox
      var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
      sx = sx >>> 8 ^ sx & 255 ^ 99;
      SBOX[x] = sx;
      INV_SBOX[sx] = x; // Compute multiplication

      var x2 = d[x];
      var x4 = d[x2];
      var x8 = d[x4]; // Compute sub bytes, mix columns tables

      var t = d[sx] * 257 ^ sx * 16843008;
      SUB_MIX[0][x] = t << 24 | t >>> 8;
      SUB_MIX[1][x] = t << 16 | t >>> 16;
      SUB_MIX[2][x] = t << 8 | t >>> 24;
      SUB_MIX[3][x] = t; // Compute inv sub bytes, inv mix columns tables

      t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      INV_SUB_MIX[0][sx] = t << 24 | t >>> 8;
      INV_SUB_MIX[1][sx] = t << 16 | t >>> 16;
      INV_SUB_MIX[2][sx] = t << 8 | t >>> 24;
      INV_SUB_MIX[3][sx] = t;

      if (x === 0) {
        x = xi = 1;
      } else {
        x = x2 ^ d[d[d[x8 ^ x2]]];
        xi ^= d[d[xi]];
      }
    }

    return {
      SBOX: SBOX,
      INV_SBOX: INV_SBOX,
      SUB_MIX: SUB_MIX,
      INV_SUB_MIX: INV_SUB_MIX
    };
  }();

  function AES(key) {
    (this || _global$j)._key = asUInt32Array(key);

    this._reset();
  }

  AES.blockSize = 4 * 4;
  AES.keySize = 256 / 8;
  AES.prototype.blockSize = AES.blockSize;
  AES.prototype.keySize = AES.keySize;

  AES.prototype._reset = function () {
    var keyWords = (this || _global$j)._key;
    var keySize = keyWords.length;
    var nRounds = keySize + 6;
    var ksRows = (nRounds + 1) * 4;
    var keySchedule = [];

    for (var k = 0; k < keySize; k++) {
      keySchedule[k] = keyWords[k];
    }

    for (k = keySize; k < ksRows; k++) {
      var t = keySchedule[k - 1];

      if (k % keySize === 0) {
        t = t << 8 | t >>> 24;
        t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
        t ^= RCON[k / keySize | 0] << 24;
      } else if (keySize > 6 && k % keySize === 4) {
        t = G.SBOX[t >>> 24] << 24 | G.SBOX[t >>> 16 & 255] << 16 | G.SBOX[t >>> 8 & 255] << 8 | G.SBOX[t & 255];
      }

      keySchedule[k] = keySchedule[k - keySize] ^ t;
    }

    var invKeySchedule = [];

    for (var ik = 0; ik < ksRows; ik++) {
      var ksR = ksRows - ik;
      var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];

      if (ik < 4 || ksR <= 4) {
        invKeySchedule[ik] = tt;
      } else {
        invKeySchedule[ik] = G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[tt >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[tt >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[tt & 255]];
      }
    }

    (this || _global$j)._nRounds = nRounds;
    (this || _global$j)._keySchedule = keySchedule;
    (this || _global$j)._invKeySchedule = invKeySchedule;
  };

  AES.prototype.encryptBlockRaw = function (M) {
    M = asUInt32Array(M);
    return cryptBlock(M, (this || _global$j)._keySchedule, G.SUB_MIX, G.SBOX, (this || _global$j)._nRounds);
  };

  AES.prototype.encryptBlock = function (M) {
    var out = this.encryptBlockRaw(M);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[1], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[3], 12);
    return buf;
  };

  AES.prototype.decryptBlock = function (M) {
    M = asUInt32Array(M); // swap

    var m1 = M[1];
    M[1] = M[3];
    M[3] = m1;
    var out = cryptBlock(M, (this || _global$j)._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, (this || _global$j)._nRounds);
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0], 0);
    buf.writeUInt32BE(out[3], 4);
    buf.writeUInt32BE(out[2], 8);
    buf.writeUInt32BE(out[1], 12);
    return buf;
  };

  AES.prototype.scrub = function () {
    scrubVec((this || _global$j)._keySchedule);
    scrubVec((this || _global$j)._invKeySchedule);
    scrubVec((this || _global$j)._key);
  };

  exports$1d.AES = AES;
  return exports$1d;
}

var exports$1c = {},
    _dewExec$1b = false;

var _global$i = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1b() {
  if (_dewExec$1b) return exports$1c;
  _dewExec$1b = true;

  var Buffer = dew$1T().Buffer;

  var ZEROES = Buffer.alloc(16, 0);

  function toArray(buf) {
    return [buf.readUInt32BE(0), buf.readUInt32BE(4), buf.readUInt32BE(8), buf.readUInt32BE(12)];
  }

  function fromArray(out) {
    var buf = Buffer.allocUnsafe(16);
    buf.writeUInt32BE(out[0] >>> 0, 0);
    buf.writeUInt32BE(out[1] >>> 0, 4);
    buf.writeUInt32BE(out[2] >>> 0, 8);
    buf.writeUInt32BE(out[3] >>> 0, 12);
    return buf;
  }

  function GHASH(key) {
    (this || _global$i).h = key;
    (this || _global$i).state = Buffer.alloc(16, 0);
    (this || _global$i).cache = Buffer.allocUnsafe(0);
  } // from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
  // by Juho Vähä-Herttua


  GHASH.prototype.ghash = function (block) {
    var i = -1;

    while (++i < block.length) {
      (this || _global$i).state[i] ^= block[i];
    }

    this._multiply();
  };

  GHASH.prototype._multiply = function () {
    var Vi = toArray((this || _global$i).h);
    var Zi = [0, 0, 0, 0];
    var j, xi, lsbVi;
    var i = -1;

    while (++i < 128) {
      xi = ((this || _global$i).state[~~(i / 8)] & 1 << 7 - i % 8) !== 0;

      if (xi) {
        // Z_i+1 = Z_i ^ V_i
        Zi[0] ^= Vi[0];
        Zi[1] ^= Vi[1];
        Zi[2] ^= Vi[2];
        Zi[3] ^= Vi[3];
      } // Store the value of LSB(V_i)


      lsbVi = (Vi[3] & 1) !== 0; // V_i+1 = V_i >> 1

      for (j = 3; j > 0; j--) {
        Vi[j] = Vi[j] >>> 1 | (Vi[j - 1] & 1) << 31;
      }

      Vi[0] = Vi[0] >>> 1; // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R

      if (lsbVi) {
        Vi[0] = Vi[0] ^ 225 << 24;
      }
    }

    (this || _global$i).state = fromArray(Zi);
  };

  GHASH.prototype.update = function (buf) {
    (this || _global$i).cache = Buffer.concat([(this || _global$i).cache, buf]);
    var chunk;

    while ((this || _global$i).cache.length >= 16) {
      chunk = (this || _global$i).cache.slice(0, 16);
      (this || _global$i).cache = (this || _global$i).cache.slice(16);
      this.ghash(chunk);
    }
  };

  GHASH.prototype.final = function (abl, bl) {
    if ((this || _global$i).cache.length) {
      this.ghash(Buffer.concat([(this || _global$i).cache, ZEROES], 16));
    }

    this.ghash(fromArray([0, abl, 0, bl]));
    return (this || _global$i).state;
  };

  exports$1c = GHASH;
  return exports$1c;
}

var exports$1b = {},
    _dewExec$1a = false;

var _global$h = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$1a() {
  if (_dewExec$1a) return exports$1b;
  _dewExec$1a = true;

  var aes = dew$1c();

  var Buffer = dew$1T().Buffer;

  var Transform = dew$1G();

  var inherits = dew$f$2();

  var GHASH = dew$1b();

  var xor = dew$1l();

  var incr32 = dew$1f();

  function xorTest(a, b) {
    var out = 0;
    if (a.length !== b.length) out++;
    var len = Math.min(a.length, b.length);

    for (var i = 0; i < len; ++i) {
      out += a[i] ^ b[i];
    }

    return out;
  }

  function calcIv(self, iv, ck) {
    if (iv.length === 12) {
      self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
      return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])]);
    }

    var ghash = new GHASH(ck);
    var len = iv.length;
    var toPad = len % 16;
    ghash.update(iv);

    if (toPad) {
      toPad = 16 - toPad;
      ghash.update(Buffer.alloc(toPad, 0));
    }

    ghash.update(Buffer.alloc(8, 0));
    var ivBits = len * 8;
    var tail = Buffer.alloc(8);
    tail.writeUIntBE(ivBits, 0, 8);
    ghash.update(tail);
    self._finID = ghash.state;
    var out = Buffer.from(self._finID);
    incr32(out);
    return out;
  }

  function StreamCipher(mode, key, iv, decrypt) {
    Transform.call(this || _global$h);
    var h = Buffer.alloc(4, 0);
    (this || _global$h)._cipher = new aes.AES(key);

    var ck = (this || _global$h)._cipher.encryptBlock(h);

    (this || _global$h)._ghash = new GHASH(ck);
    iv = calcIv(this || _global$h, iv, ck);
    (this || _global$h)._prev = Buffer.from(iv);
    (this || _global$h)._cache = Buffer.allocUnsafe(0);
    (this || _global$h)._secCache = Buffer.allocUnsafe(0);
    (this || _global$h)._decrypt = decrypt;
    (this || _global$h)._alen = 0;
    (this || _global$h)._len = 0;
    (this || _global$h)._mode = mode;
    (this || _global$h)._authTag = null;
    (this || _global$h)._called = false;
  }

  inherits(StreamCipher, Transform);

  StreamCipher.prototype._update = function (chunk) {
    if (!(this || _global$h)._called && (this || _global$h)._alen) {
      var rump = 16 - (this || _global$h)._alen % 16;

      if (rump < 16) {
        rump = Buffer.alloc(rump, 0);

        (this || _global$h)._ghash.update(rump);
      }
    }

    (this || _global$h)._called = true;

    var out = (this || _global$h)._mode.encrypt(this || _global$h, chunk);

    if ((this || _global$h)._decrypt) {
      (this || _global$h)._ghash.update(chunk);
    } else {
      (this || _global$h)._ghash.update(out);
    }

    (this || _global$h)._len += chunk.length;
    return out;
  };

  StreamCipher.prototype._final = function () {
    if ((this || _global$h)._decrypt && !(this || _global$h)._authTag) throw new Error("Unsupported state or unable to authenticate data");
    var tag = xor((this || _global$h)._ghash.final((this || _global$h)._alen * 8, (this || _global$h)._len * 8), (this || _global$h)._cipher.encryptBlock((this || _global$h)._finID));
    if ((this || _global$h)._decrypt && xorTest(tag, (this || _global$h)._authTag)) throw new Error("Unsupported state or unable to authenticate data");
    (this || _global$h)._authTag = tag;

    (this || _global$h)._cipher.scrub();
  };

  StreamCipher.prototype.getAuthTag = function getAuthTag() {
    if ((this || _global$h)._decrypt || !Buffer.isBuffer((this || _global$h)._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
    return (this || _global$h)._authTag;
  };

  StreamCipher.prototype.setAuthTag = function setAuthTag(tag) {
    if (!(this || _global$h)._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
    (this || _global$h)._authTag = tag;
  };

  StreamCipher.prototype.setAAD = function setAAD(buf) {
    if ((this || _global$h)._called) throw new Error("Attempting to set AAD in unsupported state");

    (this || _global$h)._ghash.update(buf);

    (this || _global$h)._alen += buf.length;
  };

  exports$1b = StreamCipher;
  return exports$1b;
}

var exports$1a = {},
    _dewExec$19 = false;

var _global$g = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$19() {
  if (_dewExec$19) return exports$1a;
  _dewExec$19 = true;

  var aes = dew$1c();

  var Buffer = dew$1T().Buffer;

  var Transform = dew$1G();

  var inherits = dew$f$2();

  function StreamCipher(mode, key, iv, decrypt) {
    Transform.call(this || _global$g);
    (this || _global$g)._cipher = new aes.AES(key);
    (this || _global$g)._prev = Buffer.from(iv);
    (this || _global$g)._cache = Buffer.allocUnsafe(0);
    (this || _global$g)._secCache = Buffer.allocUnsafe(0);
    (this || _global$g)._decrypt = decrypt;
    (this || _global$g)._mode = mode;
  }

  inherits(StreamCipher, Transform);

  StreamCipher.prototype._update = function (chunk) {
    return (this || _global$g)._mode.encrypt(this || _global$g, chunk, (this || _global$g)._decrypt);
  };

  StreamCipher.prototype._final = function () {
    (this || _global$g)._cipher.scrub();
  };

  exports$1a = StreamCipher;
  return exports$1a;
}

var exports$19 = {},
    _dewExec$18 = false;
function dew$18() {
  if (_dewExec$18) return exports$19;
  _dewExec$18 = true;

  var Buffer = dew$1T().Buffer;

  var MD5 = dew$1Q();
  /* eslint-disable camelcase */


  function EVP_BytesToKey(password, salt, keyBits, ivLen) {
    if (!Buffer.isBuffer(password)) password = Buffer.from(password, "binary");

    if (salt) {
      if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, "binary");
      if (salt.length !== 8) throw new RangeError("salt should be Buffer with 8 byte length");
    }

    var keyLen = keyBits / 8;
    var key = Buffer.alloc(keyLen);
    var iv = Buffer.alloc(ivLen || 0);
    var tmp = Buffer.alloc(0);

    while (keyLen > 0 || ivLen > 0) {
      var hash = new MD5();
      hash.update(tmp);
      hash.update(password);
      if (salt) hash.update(salt);
      tmp = hash.digest();
      var used = 0;

      if (keyLen > 0) {
        var keyStart = key.length - keyLen;
        used = Math.min(keyLen, tmp.length);
        tmp.copy(key, keyStart, 0, used);
        keyLen -= used;
      }

      if (used < tmp.length && ivLen > 0) {
        var ivStart = iv.length - ivLen;
        var length = Math.min(ivLen, tmp.length - used);
        tmp.copy(iv, ivStart, used, used + length);
        ivLen -= length;
      }
    }

    tmp.fill(0);
    return {
      key: key,
      iv: iv
    };
  }

  exports$19 = EVP_BytesToKey;
  return exports$19;
}

var exports$18 = {},
    _dewExec$17 = false;

var _global$f = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$17() {
  if (_dewExec$17) return exports$18;
  _dewExec$17 = true;

  var MODES = dew$1d();

  var AuthCipher = dew$1a();

  var Buffer = dew$1T().Buffer;

  var StreamCipher = dew$19();

  var Transform = dew$1G();

  var aes = dew$1c();

  var ebtk = dew$18();

  var inherits = dew$f$2();

  function Cipher(mode, key, iv) {
    Transform.call(this || _global$f);
    (this || _global$f)._cache = new Splitter();
    (this || _global$f)._cipher = new aes.AES(key);
    (this || _global$f)._prev = Buffer.from(iv);
    (this || _global$f)._mode = mode;
    (this || _global$f)._autopadding = true;
  }

  inherits(Cipher, Transform);

  Cipher.prototype._update = function (data) {
    (this || _global$f)._cache.add(data);

    var chunk;
    var thing;
    var out = [];

    while (chunk = (this || _global$f)._cache.get()) {
      thing = (this || _global$f)._mode.encrypt(this || _global$f, chunk);
      out.push(thing);
    }

    return Buffer.concat(out);
  };

  var PADDING = Buffer.alloc(16, 16);

  Cipher.prototype._final = function () {
    var chunk = (this || _global$f)._cache.flush();

    if ((this || _global$f)._autopadding) {
      chunk = (this || _global$f)._mode.encrypt(this || _global$f, chunk);

      (this || _global$f)._cipher.scrub();

      return chunk;
    }

    if (!chunk.equals(PADDING)) {
      (this || _global$f)._cipher.scrub();

      throw new Error("data not multiple of block length");
    }
  };

  Cipher.prototype.setAutoPadding = function (setTo) {
    (this || _global$f)._autopadding = !!setTo;
    return this || _global$f;
  };

  function Splitter() {
    (this || _global$f).cache = Buffer.allocUnsafe(0);
  }

  Splitter.prototype.add = function (data) {
    (this || _global$f).cache = Buffer.concat([(this || _global$f).cache, data]);
  };

  Splitter.prototype.get = function () {
    if ((this || _global$f).cache.length > 15) {
      var out = (this || _global$f).cache.slice(0, 16);

      (this || _global$f).cache = (this || _global$f).cache.slice(16);
      return out;
    }

    return null;
  };

  Splitter.prototype.flush = function () {
    var len = 16 - (this || _global$f).cache.length;
    var padBuff = Buffer.allocUnsafe(len);
    var i = -1;

    while (++i < len) {
      padBuff.writeUInt8(len, i);
    }

    return Buffer.concat([(this || _global$f).cache, padBuff]);
  };

  function createCipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);

    if (config.type === "stream") {
      return new StreamCipher(config.module, password, iv);
    } else if (config.type === "auth") {
      return new AuthCipher(config.module, password, iv);
    }

    return new Cipher(config.module, password, iv);
  }

  function createCipher(suite, password) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    var keys = ebtk(password, false, config.key, config.iv);
    return createCipheriv(suite, keys.key, keys.iv);
  }

  exports$18.createCipheriv = createCipheriv;
  exports$18.createCipher = createCipher;
  return exports$18;
}

var exports$17 = {},
    _dewExec$16 = false;

var _global$e = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$16() {
  if (_dewExec$16) return exports$17;
  _dewExec$16 = true;

  var AuthCipher = dew$1a();

  var Buffer = dew$1T().Buffer;

  var MODES = dew$1d();

  var StreamCipher = dew$19();

  var Transform = dew$1G();

  var aes = dew$1c();

  var ebtk = dew$18();

  var inherits = dew$f$2();

  function Decipher(mode, key, iv) {
    Transform.call(this || _global$e);
    (this || _global$e)._cache = new Splitter();
    (this || _global$e)._last = void 0;
    (this || _global$e)._cipher = new aes.AES(key);
    (this || _global$e)._prev = Buffer.from(iv);
    (this || _global$e)._mode = mode;
    (this || _global$e)._autopadding = true;
  }

  inherits(Decipher, Transform);

  Decipher.prototype._update = function (data) {
    (this || _global$e)._cache.add(data);

    var chunk;
    var thing;
    var out = [];

    while (chunk = (this || _global$e)._cache.get((this || _global$e)._autopadding)) {
      thing = (this || _global$e)._mode.decrypt(this || _global$e, chunk);
      out.push(thing);
    }

    return Buffer.concat(out);
  };

  Decipher.prototype._final = function () {
    var chunk = (this || _global$e)._cache.flush();

    if ((this || _global$e)._autopadding) {
      return unpad((this || _global$e)._mode.decrypt(this || _global$e, chunk));
    } else if (chunk) {
      throw new Error("data not multiple of block length");
    }
  };

  Decipher.prototype.setAutoPadding = function (setTo) {
    (this || _global$e)._autopadding = !!setTo;
    return this || _global$e;
  };

  function Splitter() {
    (this || _global$e).cache = Buffer.allocUnsafe(0);
  }

  Splitter.prototype.add = function (data) {
    (this || _global$e).cache = Buffer.concat([(this || _global$e).cache, data]);
  };

  Splitter.prototype.get = function (autoPadding) {
    var out;

    if (autoPadding) {
      if ((this || _global$e).cache.length > 16) {
        out = (this || _global$e).cache.slice(0, 16);
        (this || _global$e).cache = (this || _global$e).cache.slice(16);
        return out;
      }
    } else {
      if ((this || _global$e).cache.length >= 16) {
        out = (this || _global$e).cache.slice(0, 16);
        (this || _global$e).cache = (this || _global$e).cache.slice(16);
        return out;
      }
    }

    return null;
  };

  Splitter.prototype.flush = function () {
    if ((this || _global$e).cache.length) return (this || _global$e).cache;
  };

  function unpad(last) {
    var padded = last[15];

    if (padded < 1 || padded > 16) {
      throw new Error("unable to decrypt data");
    }

    var i = -1;

    while (++i < padded) {
      if (last[i + (16 - padded)] !== padded) {
        throw new Error("unable to decrypt data");
      }
    }

    if (padded === 16) return;
    return last.slice(0, 16 - padded);
  }

  function createDecipheriv(suite, password, iv) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    if (typeof iv === "string") iv = Buffer.from(iv);
    if (config.mode !== "GCM" && iv.length !== config.iv) throw new TypeError("invalid iv length " + iv.length);
    if (typeof password === "string") password = Buffer.from(password);
    if (password.length !== config.key / 8) throw new TypeError("invalid key length " + password.length);

    if (config.type === "stream") {
      return new StreamCipher(config.module, password, iv, true);
    } else if (config.type === "auth") {
      return new AuthCipher(config.module, password, iv, true);
    }

    return new Decipher(config.module, password, iv);
  }

  function createDecipher(suite, password) {
    var config = MODES[suite.toLowerCase()];
    if (!config) throw new TypeError("invalid suite type");
    var keys = ebtk(password, false, config.key, config.iv);
    return createDecipheriv(suite, keys.key, keys.iv);
  }

  exports$17.createDecipher = createDecipher;
  exports$17.createDecipheriv = createDecipheriv;
  return exports$17;
}

var exports$16 = {},
    _dewExec$15 = false;
function dew$15() {
  if (_dewExec$15) return exports$16;
  _dewExec$15 = true;

  var ciphers = dew$17();

  var deciphers = dew$16();

  var modes = _list;

  function getCiphers() {
    return Object.keys(modes);
  }

  exports$16.createCipher = exports$16.Cipher = ciphers.createCipher;
  exports$16.createCipheriv = exports$16.Cipheriv = ciphers.createCipheriv;
  exports$16.createDecipher = exports$16.Decipher = deciphers.createDecipher;
  exports$16.createDecipheriv = exports$16.Decipheriv = deciphers.createDecipheriv;
  exports$16.listCiphers = exports$16.getCiphers = getCiphers;
  return exports$16;
}

var exports$15 = {},
    _dewExec$14 = false;
function dew$14() {
  if (_dewExec$14) return exports$15;
  _dewExec$14 = true;
  exports$15["des-ecb"] = {
    key: 8,
    iv: 0
  };
  exports$15["des-cbc"] = exports$15.des = {
    key: 8,
    iv: 8
  };
  exports$15["des-ede3-cbc"] = exports$15.des3 = {
    key: 24,
    iv: 8
  };
  exports$15["des-ede3"] = {
    key: 24,
    iv: 0
  };
  exports$15["des-ede-cbc"] = {
    key: 16,
    iv: 8
  };
  exports$15["des-ede"] = {
    key: 16,
    iv: 0
  };
  return exports$15;
}

var exports$14 = {},
    _dewExec$13 = false;
function dew$13() {
  if (_dewExec$13) return exports$14;
  _dewExec$13 = true;

  var DES = dew$1n();

  var aes = dew$15();

  var aesModes = dew$1d();

  var desModes = dew$14();

  var ebtk = dew$18();

  function createCipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;

    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError("invalid suite type");
    }

    var keys = ebtk(password, false, keyLen, ivLen);
    return createCipheriv(suite, keys.key, keys.iv);
  }

  function createDecipher(suite, password) {
    suite = suite.toLowerCase();
    var keyLen, ivLen;

    if (aesModes[suite]) {
      keyLen = aesModes[suite].key;
      ivLen = aesModes[suite].iv;
    } else if (desModes[suite]) {
      keyLen = desModes[suite].key * 8;
      ivLen = desModes[suite].iv;
    } else {
      throw new TypeError("invalid suite type");
    }

    var keys = ebtk(password, false, keyLen, ivLen);
    return createDecipheriv(suite, keys.key, keys.iv);
  }

  function createCipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes.createCipheriv(suite, key, iv);
    if (desModes[suite]) return new DES({
      key: key,
      iv: iv,
      mode: suite
    });
    throw new TypeError("invalid suite type");
  }

  function createDecipheriv(suite, key, iv) {
    suite = suite.toLowerCase();
    if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv);
    if (desModes[suite]) return new DES({
      key: key,
      iv: iv,
      mode: suite,
      decrypt: true
    });
    throw new TypeError("invalid suite type");
  }

  function getCiphers() {
    return Object.keys(desModes).concat(aes.getCiphers());
  }

  exports$14.createCipher = exports$14.Cipher = createCipher;
  exports$14.createCipheriv = exports$14.Cipheriv = createCipheriv;
  exports$14.createDecipher = exports$14.Decipher = createDecipher;
  exports$14.createDecipheriv = exports$14.Decipheriv = createDecipheriv;
  exports$14.listCiphers = exports$14.getCiphers = getCiphers;
  return exports$14;
}

var exports$13 = {},
    _dewExec$12 = false;
var module$6 = {
  exports: exports$13
};

var _global$d = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$12() {
  if (_dewExec$12) return module$6.exports;
  _dewExec$12 = true;

  (function (module, exports) {

    function assert(val, msg) {
      if (!val) throw new Error(msg || "Assertion failed");
    } // Could use `inherits` module, but don't want to move from single file
    // architecture yet.


    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    } // BN


    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }

      (this || _global$d).negative = 0;
      (this || _global$d).words = null;
      (this || _global$d).length = 0; // Reduction context

      (this || _global$d).red = null;

      if (number !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }

        this._init(number || 0, base || 10, endian || "be");
      }
    }

    if (typeof module === "object") {
      module.exports = BN;
    } else {
      exports.BN = BN;
    }

    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;

    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer = window.Buffer;
      } else {
        Buffer = e$1$1$1.Buffer;
      }
    } catch (e) {}

    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }

      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };

    BN.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };

    BN.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };

    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base, endian);
      }

      if (typeof number === "object") {
        return this._initArray(number, base, endian);
      }

      if (base === "hex") {
        base = 16;
      }

      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;

      if (number[0] === "-") {
        start++;
        (this || _global$d).negative = 1;
      }

      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);

          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };

    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        (this || _global$d).negative = 1;
        number = -number;
      }

      if (number < 67108864) {
        (this || _global$d).words = [number & 67108863];
        (this || _global$d).length = 1;
      } else if (number < 4503599627370496) {
        (this || _global$d).words = [number & 67108863, number / 67108864 & 67108863];
        (this || _global$d).length = 2;
      } else {
        assert(number < 9007199254740992); // 2 ^ 53 (unsafe)

        (this || _global$d).words = [number & 67108863, number / 67108864 & 67108863, 1];
        (this || _global$d).length = 3;
      }

      if (endian !== "le") return; // Reverse the bytes

      this._initArray(this.toArray(), base, endian);
    };

    BN.prototype._initArray = function _initArray(number, base, endian) {
      // Perhaps a Uint8Array
      assert(typeof number.length === "number");

      if (number.length <= 0) {
        (this || _global$d).words = [0];
        (this || _global$d).length = 1;
        return this || _global$d;
      }

      (this || _global$d).length = Math.ceil(number.length / 3);
      (this || _global$d).words = new Array((this || _global$d).length);

      for (var i = 0; i < (this || _global$d).length; i++) {
        (this || _global$d).words[i] = 0;
      }

      var j, w;
      var off = 0;

      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          (this || _global$d).words[j] |= w << off & 67108863;
          (this || _global$d).words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          (this || _global$d).words[j] |= w << off & 67108863;
          (this || _global$d).words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }

      return this.strip();
    };

    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index); // 'A' - 'F'

      if (c >= 65 && c <= 70) {
        return c - 55; // 'a' - 'f'
      } else if (c >= 97 && c <= 102) {
        return c - 87; // '0' - '9'
      } else {
        return c - 48 & 15;
      }
    }

    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);

      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }

      return r;
    }

    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      // Create possibly bigger array to ensure that it fits the number
      (this || _global$d).length = Math.ceil((number.length - start) / 6);
      (this || _global$d).words = new Array((this || _global$d).length);

      for (var i = 0; i < (this || _global$d).length; i++) {
        (this || _global$d).words[i] = 0;
      } // 24-bits chunks


      var off = 0;
      var j = 0;
      var w;

      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          (this || _global$d).words[j] |= w & 67108863;

          if (off >= 18) {
            off -= 18;
            j += 1;
            (this || _global$d).words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;

        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          (this || _global$d).words[j] |= w & 67108863;

          if (off >= 18) {
            off -= 18;
            j += 1;
            (this || _global$d).words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }

      this.strip();
    };

    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);

      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul; // 'a'

        if (c >= 49) {
          r += c - 49 + 10; // 'A'
        } else if (c >= 17) {
          r += c - 17 + 10; // '0' - '9'
        } else {
          r += c;
        }
      }

      return r;
    }

    BN.prototype._parseBase = function _parseBase(number, base, start) {
      // Initialize as zero
      (this || _global$d).words = [0];
      (this || _global$d).length = 1; // Find length of limb in base

      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }

      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;

      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);

        if ((this || _global$d).words[0] + word < 67108864) {
          (this || _global$d).words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);

        for (i = 0; i < mod; i++) {
          pow *= base;
        }

        this.imuln(pow);

        if ((this || _global$d).words[0] + word < 67108864) {
          (this || _global$d).words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      this.strip();
    };

    BN.prototype.copy = function copy(dest) {
      dest.words = new Array((this || _global$d).length);

      for (var i = 0; i < (this || _global$d).length; i++) {
        dest.words[i] = (this || _global$d).words[i];
      }

      dest.length = (this || _global$d).length;
      dest.negative = (this || _global$d).negative;
      dest.red = (this || _global$d).red;
    };

    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };

    BN.prototype._expand = function _expand(size) {
      while ((this || _global$d).length < size) {
        (this || _global$d).words[(this || _global$d).length++] = 0;
      }

      return this || _global$d;
    }; // Remove leading `0` from `this`


    BN.prototype.strip = function strip() {
      while ((this || _global$d).length > 1 && (this || _global$d).words[(this || _global$d).length - 1] === 0) {
        (this || _global$d).length--;
      }

      return this._normSign();
    };

    BN.prototype._normSign = function _normSign() {
      // -0 = 0
      if ((this || _global$d).length === 1 && (this || _global$d).words[0] === 0) {
        (this || _global$d).negative = 0;
      }

      return this || _global$d;
    };

    BN.prototype.inspect = function inspect() {
      return ((this || _global$d).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*
     var zeros = [];
    var groupSizes = [];
    var groupBases = [];
     var s = '';
    var i = -1;
    while (++i < BN.wordSize) {
      zeros[i] = s;
      s += '0';
    }
    groupSizes[0] = 0;
    groupSizes[1] = 0;
    groupBases[0] = 0;
    groupBases[1] = 0;
    var base = 2 - 1;
    while (++base < 36 + 1) {
      var groupSize = 0;
      var groupBase = 1;
      while (groupBase < (1 << BN.wordSize) / base) {
        groupBase *= base;
        groupSize += 1;
      }
      groupSizes[base] = groupSize;
      groupBases[base] = groupBase;
    }
     */


    var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;

      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;

        for (var i = 0; i < (this || _global$d).length; i++) {
          var w = (this || _global$d).words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;

          if (carry !== 0 || i !== (this || _global$d).length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }

          off += 2;

          if (off >= 26) {
            off -= 26;
            i--;
          }
        }

        if (carry !== 0) {
          out = carry.toString(16) + out;
        }

        while (out.length % padding !== 0) {
          out = "0" + out;
        }

        if ((this || _global$d).negative !== 0) {
          out = "-" + out;
        }

        return out;
      }

      if (base === (base | 0) && base >= 2 && base <= 36) {
        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
        var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;

        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);

          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }

        if (this.isZero()) {
          out = "0" + out;
        }

        while (out.length % padding !== 0) {
          out = "0" + out;
        }

        if ((this || _global$d).negative !== 0) {
          out = "-" + out;
        }

        return out;
      }

      assert(false, "Base should be between 2 and 36");
    };

    BN.prototype.toNumber = function toNumber() {
      var ret = (this || _global$d).words[0];

      if ((this || _global$d).length === 2) {
        ret += (this || _global$d).words[1] * 67108864;
      } else if ((this || _global$d).length === 3 && (this || _global$d).words[2] === 1) {
        // NOTE: at this stage it is known that the top bit is set
        ret += 4503599627370496 + (this || _global$d).words[1] * 67108864;
      } else if ((this || _global$d).length > 2) {
        assert(false, "Number can only safely store up to 53 bits");
      }

      return (this || _global$d).negative !== 0 ? -ret : ret;
    };

    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };

    BN.prototype.toBuffer = function toBuffer(endian, length) {
      assert(typeof Buffer !== "undefined");
      return this.toArrayLike(Buffer, endian, length);
    };

    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };

    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, "byte array longer than desired length");
      assert(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b, i;
      var q = this.clone();

      if (!littleEndian) {
        // Assume big-endian
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }

        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[i] = b;
        }

        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }

      return res;
    };

    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;

        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }

        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }

        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }

        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }

        return r + t;
      };
    }

    BN.prototype._zeroBits = function _zeroBits(w) {
      // Short-cut
      if (w === 0) return 26;
      var t = w;
      var r = 0;

      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }

      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }

      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }

      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }

      if ((t & 1) === 0) {
        r++;
      }

      return r;
    }; // Return number of used bits in a BN


    BN.prototype.bitLength = function bitLength() {
      var w = (this || _global$d).words[(this || _global$d).length - 1];

      var hi = this._countBits(w);

      return ((this || _global$d).length - 1) * 26 + hi;
    };

    function toBitArray(num) {
      var w = new Array(num.bitLength());

      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }

      return w;
    } // Number of trailing zero bits


    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r = 0;

      for (var i = 0; i < (this || _global$d).length; i++) {
        var b = this._zeroBits((this || _global$d).words[i]);

        r += b;
        if (b !== 26) break;
      }

      return r;
    };

    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };

    BN.prototype.toTwos = function toTwos(width) {
      if ((this || _global$d).negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }

      return this.clone();
    };

    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }

      return this.clone();
    };

    BN.prototype.isNeg = function isNeg() {
      return (this || _global$d).negative !== 0;
    }; // Return negative clone of `this`


    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };

    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        (this || _global$d).negative ^= 1;
      }

      return this || _global$d;
    }; // Or `num` with `this` in-place


    BN.prototype.iuor = function iuor(num) {
      while ((this || _global$d).length < num.length) {
        (this || _global$d).words[(this || _global$d).length++] = 0;
      }

      for (var i = 0; i < num.length; i++) {
        (this || _global$d).words[i] = (this || _global$d).words[i] | num.words[i];
      }

      return this.strip();
    };

    BN.prototype.ior = function ior(num) {
      assert(((this || _global$d).negative | num.negative) === 0);
      return this.iuor(num);
    }; // Or `num` with `this`


    BN.prototype.or = function or(num) {
      if ((this || _global$d).length > num.length) return this.clone().ior(num);
      return num.clone().ior(this || _global$d);
    };

    BN.prototype.uor = function uor(num) {
      if ((this || _global$d).length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this || _global$d);
    }; // And `num` with `this` in-place


    BN.prototype.iuand = function iuand(num) {
      // b = min-length(num, this)
      var b;

      if ((this || _global$d).length > num.length) {
        b = num;
      } else {
        b = this || _global$d;
      }

      for (var i = 0; i < b.length; i++) {
        (this || _global$d).words[i] = (this || _global$d).words[i] & num.words[i];
      }

      (this || _global$d).length = b.length;
      return this.strip();
    };

    BN.prototype.iand = function iand(num) {
      assert(((this || _global$d).negative | num.negative) === 0);
      return this.iuand(num);
    }; // And `num` with `this`


    BN.prototype.and = function and(num) {
      if ((this || _global$d).length > num.length) return this.clone().iand(num);
      return num.clone().iand(this || _global$d);
    };

    BN.prototype.uand = function uand(num) {
      if ((this || _global$d).length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this || _global$d);
    }; // Xor `num` with `this` in-place


    BN.prototype.iuxor = function iuxor(num) {
      // a.length > b.length
      var a;
      var b;

      if ((this || _global$d).length > num.length) {
        a = this || _global$d;
        b = num;
      } else {
        a = num;
        b = this || _global$d;
      }

      for (var i = 0; i < b.length; i++) {
        (this || _global$d).words[i] = a.words[i] ^ b.words[i];
      }

      if ((this || _global$d) !== a) {
        for (; i < a.length; i++) {
          (this || _global$d).words[i] = a.words[i];
        }
      }

      (this || _global$d).length = a.length;
      return this.strip();
    };

    BN.prototype.ixor = function ixor(num) {
      assert(((this || _global$d).negative | num.negative) === 0);
      return this.iuxor(num);
    }; // Xor `num` with `this`


    BN.prototype.xor = function xor(num) {
      if ((this || _global$d).length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this || _global$d);
    };

    BN.prototype.uxor = function uxor(num) {
      if ((this || _global$d).length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this || _global$d);
    }; // Not ``this`` with ``width`` bitwidth


    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26; // Extend the buffer with leading zeroes

      this._expand(bytesNeeded);

      if (bitsLeft > 0) {
        bytesNeeded--;
      } // Handle complete words


      for (var i = 0; i < bytesNeeded; i++) {
        (this || _global$d).words[i] = ~(this || _global$d).words[i] & 67108863;
      } // Handle the residue


      if (bitsLeft > 0) {
        (this || _global$d).words[i] = ~(this || _global$d).words[i] & 67108863 >> 26 - bitsLeft;
      } // And remove leading zeroes


      return this.strip();
    };

    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    }; // Set `bit` of `this`


    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;

      this._expand(off + 1);

      if (val) {
        (this || _global$d).words[off] = (this || _global$d).words[off] | 1 << wbit;
      } else {
        (this || _global$d).words[off] = (this || _global$d).words[off] & ~(1 << wbit);
      }

      return this.strip();
    }; // Add `num` to `this` in-place


    BN.prototype.iadd = function iadd(num) {
      var r; // negative + positive

      if ((this || _global$d).negative !== 0 && num.negative === 0) {
        (this || _global$d).negative = 0;
        r = this.isub(num);
        (this || _global$d).negative ^= 1;
        return this._normSign(); // positive + negative
      } else if ((this || _global$d).negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      } // a.length > b.length


      var a, b;

      if ((this || _global$d).length > num.length) {
        a = this || _global$d;
        b = num;
      } else {
        a = num;
        b = this || _global$d;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        (this || _global$d).words[i] = r & 67108863;
        carry = r >>> 26;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        (this || _global$d).words[i] = r & 67108863;
        carry = r >>> 26;
      }

      (this || _global$d).length = a.length;

      if (carry !== 0) {
        (this || _global$d).words[(this || _global$d).length] = carry;
        (this || _global$d).length++; // Copy the rest of the words
      } else if (a !== (this || _global$d)) {
        for (; i < a.length; i++) {
          (this || _global$d).words[i] = a.words[i];
        }
      }

      return this || _global$d;
    }; // Add `num` to `this`


    BN.prototype.add = function add(num) {
      var res;

      if (num.negative !== 0 && (this || _global$d).negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && (this || _global$d).negative !== 0) {
        (this || _global$d).negative = 0;
        res = num.sub(this || _global$d);
        (this || _global$d).negative = 1;
        return res;
      }

      if ((this || _global$d).length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this || _global$d);
    }; // Subtract `num` from `this` in-place


    BN.prototype.isub = function isub(num) {
      // this - (-num) = this + num
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign(); // -this - num = -(this + num)
      } else if ((this || _global$d).negative !== 0) {
        (this || _global$d).negative = 0;
        this.iadd(num);
        (this || _global$d).negative = 1;
        return this._normSign();
      } // At this point both numbers are positive


      var cmp = this.cmp(num); // Optimization - zeroify

      if (cmp === 0) {
        (this || _global$d).negative = 0;
        (this || _global$d).length = 1;
        (this || _global$d).words[0] = 0;
        return this || _global$d;
      } // a > b


      var a, b;

      if (cmp > 0) {
        a = this || _global$d;
        b = num;
      } else {
        a = num;
        b = this || _global$d;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        (this || _global$d).words[i] = r & 67108863;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        (this || _global$d).words[i] = r & 67108863;
      } // Copy rest of the words


      if (carry === 0 && i < a.length && a !== (this || _global$d)) {
        for (; i < a.length; i++) {
          (this || _global$d).words[i] = a.words[i];
        }
      }

      (this || _global$d).length = Math.max((this || _global$d).length, i);

      if (a !== (this || _global$d)) {
        (this || _global$d).negative = 1;
      }

      return this.strip();
    }; // Subtract `num` from `this`


    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };

    function smallMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      var len = self.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

      var a = self.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;

      for (var k = 1; k < len; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }

        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }

      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }

      return out.strip();
    } // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).


    var comb10MulTo = function comb10MulTo(self, num, out) {
      var a = self.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self.negative ^ num.negative;
      out.length = 19;
      /* k = 0 */

      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      /* k = 1 */

      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      /* k = 2 */

      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      /* k = 3 */

      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      /* k = 4 */

      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      /* k = 5 */

      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      /* k = 6 */

      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      /* k = 7 */

      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      /* k = 8 */

      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      /* k = 9 */

      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      /* k = 10 */

      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      /* k = 11 */

      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      /* k = 12 */

      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      /* k = 13 */

      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      /* k = 14 */

      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      /* k = 15 */

      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      /* k = 16 */

      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      /* k = 17 */

      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      /* k = 18 */

      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;

      if (c !== 0) {
        o[19] = c;
        out.length++;
      }

      return out;
    }; // Polyfill comb


    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }

    function bigMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      out.length = self.length + num.length;
      var carry = 0;
      var hncarry = 0;

      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }

        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }

      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }

      return out.strip();
    }

    function jumboMulTo(self, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self, num, out);
    }

    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = (this || _global$d).length + num.length;

      if ((this || _global$d).length === 10 && num.length === 10) {
        res = comb10MulTo(this || _global$d, num, out);
      } else if (len < 63) {
        res = smallMulTo(this || _global$d, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this || _global$d, num, out);
      } else {
        res = jumboMulTo(this || _global$d, num, out);
      }

      return res;
    }; // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion


    function FFTM(x, y) {
      (this || _global$d).x = x;
      (this || _global$d).y = y;
    }

    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;

      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }

      return t;
    }; // Returns binary-reversed representation of `x`


    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1) return x;
      var rb = 0;

      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }

      return rb;
    }; // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm


    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };

    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);

      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);

        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;

          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            /* jshint maxdepth : false */

            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };

    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;

      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }

      return 1 << i + 1 + odd;
    };

    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1) return;

      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };

    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;

      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;

        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }

      return ws;
    };

    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;

      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      } // Pad with zeroes


      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }

      assert(carry === 0);
      assert((carry & ~8191) === 0);
    };

    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);

      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }

      return ph;
    };

    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);

      var _ = this.stub(N);

      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);

      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }

      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    }; // Multiply `this` by `num`


    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array((this || _global$d).length + num.length);
      return this.mulTo(num, out);
    }; // Multiply employing FFT


    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array((this || _global$d).length + num.length);
      return jumboMulTo(this || _global$d, num, out);
    }; // In-place Multiplication


    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this || _global$d);
    };

    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === "number");
      assert(num < 67108864); // Carry

      var carry = 0;

      for (var i = 0; i < (this || _global$d).length; i++) {
        var w = ((this || _global$d).words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0; // NOTE: lo is 27bit maximum

        carry += lo >>> 26;
        (this || _global$d).words[i] = lo & 67108863;
      }

      if (carry !== 0) {
        (this || _global$d).words[i] = carry;
        (this || _global$d).length++;
      }

      return this || _global$d;
    };

    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    }; // `this` * `this`


    BN.prototype.sqr = function sqr() {
      return this.mul(this || _global$d);
    }; // `this` * `this` in-place


    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    }; // Math.pow(`this`, `num`)


    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN(1); // Skip leading zeroes

      var res = this || _global$d;

      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }

      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
          res = res.mul(q);
        }
      }

      return res;
    }; // Shift-left in-place


    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;

      if (r !== 0) {
        var carry = 0;

        for (i = 0; i < (this || _global$d).length; i++) {
          var newCarry = (this || _global$d).words[i] & carryMask;
          var c = ((this || _global$d).words[i] | 0) - newCarry << r;
          (this || _global$d).words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }

        if (carry) {
          (this || _global$d).words[i] = carry;
          (this || _global$d).length++;
        }
      }

      if (s !== 0) {
        for (i = (this || _global$d).length - 1; i >= 0; i--) {
          (this || _global$d).words[i + s] = (this || _global$d).words[i];
        }

        for (i = 0; i < s; i++) {
          (this || _global$d).words[i] = 0;
        }

        (this || _global$d).length += s;
      }

      return this.strip();
    };

    BN.prototype.ishln = function ishln(bits) {
      // TODO(indutny): implement me
      assert((this || _global$d).negative === 0);
      return this.iushln(bits);
    }; // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits


    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === "number" && bits >= 0);
      var h;

      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }

      var r = bits % 26;
      var s = Math.min((bits - r) / 26, (this || _global$d).length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h); // Extended mode, copy masked part

      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = (this || _global$d).words[i];
        }

        maskedWords.length = s;
      }

      if (s === 0) ; else if ((this || _global$d).length > s) {
        (this || _global$d).length -= s;

        for (i = 0; i < (this || _global$d).length; i++) {
          (this || _global$d).words[i] = (this || _global$d).words[i + s];
        }
      } else {
        (this || _global$d).words[0] = 0;
        (this || _global$d).length = 1;
      }

      var carry = 0;

      for (i = (this || _global$d).length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = (this || _global$d).words[i] | 0;
        (this || _global$d).words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      } // Push carried bits as a mask


      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }

      if ((this || _global$d).length === 0) {
        (this || _global$d).words[0] = 0;
        (this || _global$d).length = 1;
      }

      return this.strip();
    };

    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      // TODO(indutny): implement me
      assert((this || _global$d).negative === 0);
      return this.iushrn(bits, hint, extended);
    }; // Shift-left


    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };

    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    }; // Shift-right


    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };

    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    }; // Test if n bit is set


    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if ((this || _global$d).length <= s) return false; // Check bit and return

      var w = (this || _global$d).words[s];
      return !!(w & q);
    }; // Return only lowers bits of number (in-place)


    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert((this || _global$d).negative === 0, "imaskn works only with positive numbers");

      if ((this || _global$d).length <= s) {
        return this || _global$d;
      }

      if (r !== 0) {
        s++;
      }

      (this || _global$d).length = Math.min(s, (this || _global$d).length);

      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        (this || _global$d).words[(this || _global$d).length - 1] &= mask;
      }

      return this.strip();
    }; // Return only lowers bits of number


    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    }; // Add plain number `num` to `this`


    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0) return this.isubn(-num); // Possible sign change

      if ((this || _global$d).negative !== 0) {
        if ((this || _global$d).length === 1 && ((this || _global$d).words[0] | 0) < num) {
          (this || _global$d).words[0] = num - ((this || _global$d).words[0] | 0);
          (this || _global$d).negative = 0;
          return this || _global$d;
        }

        (this || _global$d).negative = 0;
        this.isubn(num);
        (this || _global$d).negative = 1;
        return this || _global$d;
      } // Add without checks


      return this._iaddn(num);
    };

    BN.prototype._iaddn = function _iaddn(num) {
      (this || _global$d).words[0] += num; // Carry

      for (var i = 0; i < (this || _global$d).length && (this || _global$d).words[i] >= 67108864; i++) {
        (this || _global$d).words[i] -= 67108864;

        if (i === (this || _global$d).length - 1) {
          (this || _global$d).words[i + 1] = 1;
        } else {
          (this || _global$d).words[i + 1]++;
        }
      }

      (this || _global$d).length = Math.max((this || _global$d).length, i + 1);
      return this || _global$d;
    }; // Subtract plain number `num` from `this`


    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0) return this.iaddn(-num);

      if ((this || _global$d).negative !== 0) {
        (this || _global$d).negative = 0;
        this.iaddn(num);
        (this || _global$d).negative = 1;
        return this || _global$d;
      }

      (this || _global$d).words[0] -= num;

      if ((this || _global$d).length === 1 && (this || _global$d).words[0] < 0) {
        (this || _global$d).words[0] = -(this || _global$d).words[0];
        (this || _global$d).negative = 1;
      } else {
        // Carry
        for (var i = 0; i < (this || _global$d).length && (this || _global$d).words[i] < 0; i++) {
          (this || _global$d).words[i] += 67108864;
          (this || _global$d).words[i + 1] -= 1;
        }
      }

      return this.strip();
    };

    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };

    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };

    BN.prototype.iabs = function iabs() {
      (this || _global$d).negative = 0;
      return this || _global$d;
    };

    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };

    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;

      this._expand(len);

      var w;
      var carry = 0;

      for (i = 0; i < num.length; i++) {
        w = ((this || _global$d).words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        (this || _global$d).words[i + shift] = w & 67108863;
      }

      for (; i < (this || _global$d).length - shift; i++) {
        w = ((this || _global$d).words[i + shift] | 0) + carry;
        carry = w >> 26;
        (this || _global$d).words[i + shift] = w & 67108863;
      }

      if (carry === 0) return this.strip(); // Subtraction overflow

      assert(carry === -1);
      carry = 0;

      for (i = 0; i < (this || _global$d).length; i++) {
        w = -((this || _global$d).words[i] | 0) + carry;
        carry = w >> 26;
        (this || _global$d).words[i] = w & 67108863;
      }

      (this || _global$d).negative = 1;
      return this.strip();
    };

    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = (this || _global$d).length - num.length;
      var a = this.clone();
      var b = num; // Normalize

      var bhi = b.words[b.length - 1] | 0;

      var bhiBits = this._countBits(bhi);

      shift = 26 - bhiBits;

      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      } // Initialize quotient


      var m = a.length - b.length;
      var q;

      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);

        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }

      var diff = a.clone()._ishlnsubmul(b, 1, m);

      if (diff.negative === 0) {
        a = diff;

        if (q) {
          q.words[m] = 1;
        }
      }

      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
        // (0x7ffffff)

        qj = Math.min(qj / bhi | 0, 67108863);

        a._ishlnsubmul(b, qj, j);

        while (a.negative !== 0) {
          qj--;
          a.negative = 0;

          a._ishlnsubmul(b, 1, j);

          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }

        if (q) {
          q.words[j] = qj;
        }
      }

      if (q) {
        q.strip();
      }

      a.strip(); // Denormalize

      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }

      return {
        div: q || null,
        mod: a
      };
    }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested


    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());

      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }

      var div, mod, res;

      if ((this || _global$d).negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);

        if (mode !== "mod") {
          div = res.div.neg();
        }

        if (mode !== "div") {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }

        return {
          div: div,
          mod: mod
        };
      }

      if ((this || _global$d).negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);

        if (mode !== "mod") {
          div = res.div.neg();
        }

        return {
          div: div,
          mod: res.mod
        };
      }

      if (((this || _global$d).negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);

        if (mode !== "div") {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }

        return {
          div: res.div,
          mod: mod
        };
      } // Both numbers are positive at this point
      // Strip both numbers to approximate shift value


      if (num.length > (this || _global$d).length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this || _global$d
        };
      } // Very short reduction


      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }

        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }

        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return this._wordDiv(num, mode);
    }; // Find `this` / `num`


    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    }; // Find `this` % `num`


    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };

    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    }; // Find Round(`this` / `num`)


    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num); // Fast case - exact division

      if (dm.mod.isZero()) return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half); // Round down

      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };

    BN.prototype.modn = function modn(num) {
      assert(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;

      for (var i = (this || _global$d).length - 1; i >= 0; i--) {
        acc = (p * acc + ((this || _global$d).words[i] | 0)) % num;
      }

      return acc;
    }; // In-place division by number


    BN.prototype.idivn = function idivn(num) {
      assert(num <= 67108863);
      var carry = 0;

      for (var i = (this || _global$d).length - 1; i >= 0; i--) {
        var w = ((this || _global$d).words[i] | 0) + carry * 67108864;
        (this || _global$d).words[i] = w / num | 0;
        carry = w % num;
      }

      return this.strip();
    };

    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };

    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this || _global$d;
      var y = p.clone();

      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      } // A * x + B * y = x


      var A = new BN(1);
      var B = new BN(0); // C * x + D * y = y

      var C = new BN(0);
      var D = new BN(1);
      var g = 0;

      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }

      var yp = y.clone();
      var xp = x.clone();

      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

        if (i > 0) {
          x.iushrn(i);

          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }

            A.iushrn(1);
            B.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

        if (j > 0) {
          y.iushrn(j);

          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }

            C.iushrn(1);
            D.iushrn(1);
          }
        }

        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }

      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    }; // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed


    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this || _global$d;
      var b = p.clone();

      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }

      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();

      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

        if (i > 0) {
          a.iushrn(i);

          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }

            x1.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

        if (j > 0) {
          b.iushrn(j);

          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }

            x2.iushrn(1);
          }
        }

        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }

      var res;

      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }

      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }

      return res;
    };

    BN.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0; // Remove common factor of two

      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }

      do {
        while (a.isEven()) {
          a.iushrn(1);
        }

        while (b.isEven()) {
          b.iushrn(1);
        }

        var r = a.cmp(b);

        if (r < 0) {
          // Swap `a` and `b` to make `a` always bigger than `b`
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }

        a.isub(b);
      } while (true);

      return b.iushln(shift);
    }; // Invert number in the field F(num)


    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };

    BN.prototype.isEven = function isEven() {
      return ((this || _global$d).words[0] & 1) === 0;
    };

    BN.prototype.isOdd = function isOdd() {
      return ((this || _global$d).words[0] & 1) === 1;
    }; // And first word and num


    BN.prototype.andln = function andln(num) {
      return (this || _global$d).words[0] & num;
    }; // Increment at the bit position in-line


    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if ((this || _global$d).length <= s) {
        this._expand(s + 1);

        (this || _global$d).words[s] |= q;
        return this || _global$d;
      } // Add bit and propagate, if needed


      var carry = q;

      for (var i = s; carry !== 0 && i < (this || _global$d).length; i++) {
        var w = (this || _global$d).words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        (this || _global$d).words[i] = w;
      }

      if (carry !== 0) {
        (this || _global$d).words[i] = carry;
        (this || _global$d).length++;
      }

      return this || _global$d;
    };

    BN.prototype.isZero = function isZero() {
      return (this || _global$d).length === 1 && (this || _global$d).words[0] === 0;
    };

    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if ((this || _global$d).negative !== 0 && !negative) return -1;
      if ((this || _global$d).negative === 0 && negative) return 1;
      this.strip();
      var res;

      if ((this || _global$d).length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }

        assert(num <= 67108863, "Number is too big");
        var w = (this || _global$d).words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }

      if ((this || _global$d).negative !== 0) return -res | 0;
      return res;
    }; // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`


    BN.prototype.cmp = function cmp(num) {
      if ((this || _global$d).negative !== 0 && num.negative === 0) return -1;
      if ((this || _global$d).negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if ((this || _global$d).negative !== 0) return -res | 0;
      return res;
    }; // Unsigned comparison


    BN.prototype.ucmp = function ucmp(num) {
      // At this point both numbers have the same sign
      if ((this || _global$d).length > num.length) return 1;
      if ((this || _global$d).length < num.length) return -1;
      var res = 0;

      for (var i = (this || _global$d).length - 1; i >= 0; i--) {
        var a = (this || _global$d).words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;

        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }

        break;
      }

      return res;
    };

    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };

    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };

    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };

    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };

    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };

    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };

    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };

    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };

    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };

    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    }; //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //


    BN.red = function red(num) {
      return new Red(num);
    };

    BN.prototype.toRed = function toRed(ctx) {
      assert(!(this || _global$d).red, "Already a number in reduction context");
      assert((this || _global$d).negative === 0, "red works only with positives");
      return ctx.convertTo(this || _global$d)._forceRed(ctx);
    };

    BN.prototype.fromRed = function fromRed() {
      assert((this || _global$d).red, "fromRed works only with numbers in reduction context");
      return (this || _global$d).red.convertFrom(this || _global$d);
    };

    BN.prototype._forceRed = function _forceRed(ctx) {
      (this || _global$d).red = ctx;
      return this || _global$d;
    };

    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!(this || _global$d).red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };

    BN.prototype.redAdd = function redAdd(num) {
      assert((this || _global$d).red, "redAdd works only with red numbers");
      return (this || _global$d).red.add(this || _global$d, num);
    };

    BN.prototype.redIAdd = function redIAdd(num) {
      assert((this || _global$d).red, "redIAdd works only with red numbers");
      return (this || _global$d).red.iadd(this || _global$d, num);
    };

    BN.prototype.redSub = function redSub(num) {
      assert((this || _global$d).red, "redSub works only with red numbers");
      return (this || _global$d).red.sub(this || _global$d, num);
    };

    BN.prototype.redISub = function redISub(num) {
      assert((this || _global$d).red, "redISub works only with red numbers");
      return (this || _global$d).red.isub(this || _global$d, num);
    };

    BN.prototype.redShl = function redShl(num) {
      assert((this || _global$d).red, "redShl works only with red numbers");
      return (this || _global$d).red.shl(this || _global$d, num);
    };

    BN.prototype.redMul = function redMul(num) {
      assert((this || _global$d).red, "redMul works only with red numbers");

      (this || _global$d).red._verify2(this || _global$d, num);

      return (this || _global$d).red.mul(this || _global$d, num);
    };

    BN.prototype.redIMul = function redIMul(num) {
      assert((this || _global$d).red, "redMul works only with red numbers");

      (this || _global$d).red._verify2(this || _global$d, num);

      return (this || _global$d).red.imul(this || _global$d, num);
    };

    BN.prototype.redSqr = function redSqr() {
      assert((this || _global$d).red, "redSqr works only with red numbers");

      (this || _global$d).red._verify1(this || _global$d);

      return (this || _global$d).red.sqr(this || _global$d);
    };

    BN.prototype.redISqr = function redISqr() {
      assert((this || _global$d).red, "redISqr works only with red numbers");

      (this || _global$d).red._verify1(this || _global$d);

      return (this || _global$d).red.isqr(this || _global$d);
    }; // Square root over p


    BN.prototype.redSqrt = function redSqrt() {
      assert((this || _global$d).red, "redSqrt works only with red numbers");

      (this || _global$d).red._verify1(this || _global$d);

      return (this || _global$d).red.sqrt(this || _global$d);
    };

    BN.prototype.redInvm = function redInvm() {
      assert((this || _global$d).red, "redInvm works only with red numbers");

      (this || _global$d).red._verify1(this || _global$d);

      return (this || _global$d).red.invm(this || _global$d);
    }; // Return negative clone of `this` % `red modulo`


    BN.prototype.redNeg = function redNeg() {
      assert((this || _global$d).red, "redNeg works only with red numbers");

      (this || _global$d).red._verify1(this || _global$d);

      return (this || _global$d).red.neg(this || _global$d);
    };

    BN.prototype.redPow = function redPow(num) {
      assert((this || _global$d).red && !num.red, "redPow(normalNum)");

      (this || _global$d).red._verify1(this || _global$d);

      return (this || _global$d).red.pow(this || _global$d, num);
    }; // Prime numbers with efficient reduction


    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    }; // Pseudo-Mersenne prime

    function MPrime(name, p) {
      // P = 2 ^ N - K
      (this || _global$d).name = name;
      (this || _global$d).p = new BN(p, 16);
      (this || _global$d).n = (this || _global$d).p.bitLength();
      (this || _global$d).k = new BN(1).iushln((this || _global$d).n).isub((this || _global$d).p);
      (this || _global$d).tmp = this._tmp();
    }

    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil((this || _global$d).n / 13));
      return tmp;
    };

    MPrime.prototype.ireduce = function ireduce(num) {
      // Assumes that `num` is less than `P^2`
      // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
      var r = num;
      var rlen;

      do {
        this.split(r, (this || _global$d).tmp);
        r = this.imulK(r);
        r = r.iadd((this || _global$d).tmp);
        rlen = r.bitLength();
      } while (rlen > (this || _global$d).n);

      var cmp = rlen < (this || _global$d).n ? -1 : r.ucmp((this || _global$d).p);

      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub((this || _global$d).p);
      } else {
        if (r.strip !== undefined) {
          // r is BN v4 instance
          r.strip();
        } else {
          // r is BN v5 instance
          r._strip();
        }
      }

      return r;
    };

    MPrime.prototype.split = function split(input, out) {
      input.iushrn((this || _global$d).n, 0, out);
    };

    MPrime.prototype.imulK = function imulK(num) {
      return num.imul((this || _global$d).k);
    };

    function K256() {
      MPrime.call(this || _global$d, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }

    inherits(K256, MPrime);

    K256.prototype.split = function split(input, output) {
      // 256 = 9 * 26 + 22
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);

      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }

      output.length = outLen;

      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      } // Shift by 9 limbs


      var prev = input.words[9];
      output.words[output.length++] = prev & mask;

      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }

      prev >>>= 22;
      input.words[i - 10] = prev;

      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };

    K256.prototype.imulK = function imulK(num) {
      // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

      var lo = 0;

      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      } // Fast length reduction


      if (num.words[num.length - 1] === 0) {
        num.length--;

        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }

      return num;
    };

    function P224() {
      MPrime.call(this || _global$d, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }

    inherits(P224, MPrime);

    function P192() {
      MPrime.call(this || _global$d, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }

    inherits(P192, MPrime);

    function P25519() {
      // 2 ^ 255 - 19
      MPrime.call(this || _global$d, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }

    inherits(P25519, MPrime);

    P25519.prototype.imulK = function imulK(num) {
      // K = 0x13
      var carry = 0;

      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }

      if (carry !== 0) {
        num.words[num.length++] = carry;
      }

      return num;
    }; // Exported mostly for testing purposes, use plain name instead


    BN._prime = function prime(name) {
      // Cached version of prime
      if (primes[name]) return primes[name];
      var prime;

      if (name === "k256") {
        prime = new K256();
      } else if (name === "p224") {
        prime = new P224();
      } else if (name === "p192") {
        prime = new P192();
      } else if (name === "p25519") {
        prime = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }

      primes[name] = prime;
      return prime;
    }; //
    // Base reduction engine
    //


    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);

        (this || _global$d).m = prime.p;
        (this || _global$d).prime = prime;
      } else {
        assert(m.gtn(1), "modulus must be greater than 1");
        (this || _global$d).m = m;
        (this || _global$d).prime = null;
      }
    }

    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, "red works only with positives");
      assert(a.red, "red works only with red numbers");
    };

    Red.prototype._verify2 = function _verify2(a, b) {
      assert((a.negative | b.negative) === 0, "red works only with positives");
      assert(a.red && a.red === b.red, "red works only with red numbers");
    };

    Red.prototype.imod = function imod(a) {
      if ((this || _global$d).prime) return (this || _global$d).prime.ireduce(a)._forceRed(this || _global$d);
      return a.umod((this || _global$d).m)._forceRed(this || _global$d);
    };

    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }

      return (this || _global$d).m.sub(a)._forceRed(this || _global$d);
    };

    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);

      var res = a.add(b);

      if (res.cmp((this || _global$d).m) >= 0) {
        res.isub((this || _global$d).m);
      }

      return res._forceRed(this || _global$d);
    };

    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);

      var res = a.iadd(b);

      if (res.cmp((this || _global$d).m) >= 0) {
        res.isub((this || _global$d).m);
      }

      return res;
    };

    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);

      var res = a.sub(b);

      if (res.cmpn(0) < 0) {
        res.iadd((this || _global$d).m);
      }

      return res._forceRed(this || _global$d);
    };

    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);

      var res = a.isub(b);

      if (res.cmpn(0) < 0) {
        res.iadd((this || _global$d).m);
      }

      return res;
    };

    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);

      return this.imod(a.ushln(num));
    };

    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);

      return this.imod(a.imul(b));
    };

    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);

      return this.imod(a.mul(b));
    };

    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };

    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };

    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero()) return a.clone();

      var mod3 = (this || _global$d).m.andln(3);

      assert(mod3 % 2 === 1); // Fast case

      if (mod3 === 3) {
        var pow = (this || _global$d).m.add(new BN(1)).iushrn(2);

        return this.pow(a, pow);
      } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
      //
      // Find Q and S, that Q * 2 ^ S = (P - 1)


      var q = (this || _global$d).m.subn(1);

      var s = 0;

      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }

      assert(!q.isZero());
      var one = new BN(1).toRed(this || _global$d);
      var nOne = one.redNeg(); // Find quadratic non-residue
      // NOTE: Max is such because of generalized Riemann hypothesis.

      var lpow = (this || _global$d).m.subn(1).iushrn(1);

      var z = (this || _global$d).m.bitLength();

      z = new BN(2 * z * z).toRed(this || _global$d);

      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }

      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;

      while (t.cmp(one) !== 0) {
        var tmp = t;

        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }

        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }

      return r;
    };

    Red.prototype.invm = function invm(a) {
      var inv = a._invmp((this || _global$d).m);

      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };

    Red.prototype.pow = function pow(a, num) {
      if (num.isZero()) return new BN(1).toRed(this || _global$d);
      if (num.cmpn(1) === 0) return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this || _global$d);
      wnd[1] = a;

      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }

      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;

      if (start === 0) {
        start = 26;
      }

      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];

        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;

          if (res !== wnd[0]) {
            res = this.sqr(res);
          }

          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }

          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }

        start = 26;
      }

      return res;
    };

    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod((this || _global$d).m);
      return r === num ? r.clone() : r;
    };

    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    }; //
    // Montgomery method engine
    //


    BN.mont = function mont(num) {
      return new Mont(num);
    };

    function Mont(m) {
      Red.call(this || _global$d, m);
      (this || _global$d).shift = (this || _global$d).m.bitLength();

      if ((this || _global$d).shift % 26 !== 0) {
        (this || _global$d).shift += 26 - (this || _global$d).shift % 26;
      }

      (this || _global$d).r = new BN(1).iushln((this || _global$d).shift);
      (this || _global$d).r2 = this.imod((this || _global$d).r.sqr());
      (this || _global$d).rinv = (this || _global$d).r._invmp((this || _global$d).m);
      (this || _global$d).minv = (this || _global$d).rinv.mul((this || _global$d).r).isubn(1).div((this || _global$d).m);
      (this || _global$d).minv = (this || _global$d).minv.umod((this || _global$d).r);
      (this || _global$d).minv = (this || _global$d).r.sub((this || _global$d).minv);
    }

    inherits(Mont, Red);

    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln((this || _global$d).shift));
    };

    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul((this || _global$d).rinv));
      r.red = null;
      return r;
    };

    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }

      var t = a.imul(b);
      var c = t.maskn((this || _global$d).shift).mul((this || _global$d).minv).imaskn((this || _global$d).shift).mul((this || _global$d).m);
      var u = t.isub(c).iushrn((this || _global$d).shift);
      var res = u;

      if (u.cmp((this || _global$d).m) >= 0) {
        res = u.isub((this || _global$d).m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd((this || _global$d).m);
      }

      return res._forceRed(this || _global$d);
    };

    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this || _global$d);
      var t = a.mul(b);
      var c = t.maskn((this || _global$d).shift).mul((this || _global$d).minv).imaskn((this || _global$d).shift).mul((this || _global$d).m);
      var u = t.isub(c).iushrn((this || _global$d).shift);
      var res = u;

      if (u.cmp((this || _global$d).m) >= 0) {
        res = u.isub((this || _global$d).m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd((this || _global$d).m);
      }

      return res._forceRed(this || _global$d);
    };

    Mont.prototype.invm = function invm(a) {
      // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
      var res = this.imod(a._invmp((this || _global$d).m).mul((this || _global$d).r2));
      return res._forceRed(this || _global$d);
    };
  })(module$6, exports$13);

  return module$6.exports;
}

var exports$12$1 = {},
    _dewExec$11$1 = false;
var module$5 = {
  exports: exports$12$1
};

var _global$c = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;

function dew$11$1() {
  if (_dewExec$11$1) return module$5.exports;
  _dewExec$11$1 = true;

  (function (module, exports) {

    function assert(val, msg) {
      if (!val) throw new Error(msg || "Assertion failed");
    } // Could use `inherits` module, but don't want to move from single file
    // architecture yet.


    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    } // BN


    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }

      (this || _global$c).negative = 0;
      (this || _global$c).words = null;
      (this || _global$c).length = 0; // Reduction context

      (this || _global$c).red = null;

      if (number !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }

        this._init(number || 0, base || 10, endian || "be");
      }
    }

    if (typeof module === "object") {
      module.exports = BN;
    } else {
      exports.BN = BN;
    }

    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;

    try {
      if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
        Buffer = window.Buffer;
      } else {
        Buffer = e$1$1$1.Buffer;
      }
    } catch (e) {}

    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }

      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };

    BN.max = function max(left, right) {
      if (left.cmp(right) > 0) return left;
      return right;
    };

    BN.min = function min(left, right) {
      if (left.cmp(right) < 0) return left;
      return right;
    };

    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base, endian);
      }

      if (typeof number === "object") {
        return this._initArray(number, base, endian);
      }

      if (base === "hex") {
        base = 16;
      }

      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;

      if (number[0] === "-") {
        start++;
        (this || _global$c).negative = 1;
      }

      if (start < number.length) {
        if (base === 16) {
          this._parseHex(number, start, endian);
        } else {
          this._parseBase(number, base, start);

          if (endian === "le") {
            this._initArray(this.toArray(), base, endian);
          }
        }
      }
    };

    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        (this || _global$c).negative = 1;
        number = -number;
      }

      if (number < 67108864) {
        (this || _global$c).words = [number & 67108863];
        (this || _global$c).length = 1;
      } else if (number < 4503599627370496) {
        (this || _global$c).words = [number & 67108863, number / 67108864 & 67108863];
        (this || _global$c).length = 2;
      } else {
        assert(number < 9007199254740992); // 2 ^ 53 (unsafe)

        (this || _global$c).words = [number & 67108863, number / 67108864 & 67108863, 1];
        (this || _global$c).length = 3;
      }

      if (endian !== "le") return; // Reverse the bytes

      this._initArray(this.toArray(), base, endian);
    };

    BN.prototype._initArray = function _initArray(number, base, endian) {
      // Perhaps a Uint8Array
      assert(typeof number.length === "number");

      if (number.length <= 0) {
        (this || _global$c).words = [0];
        (this || _global$c).length = 1;
        return this || _global$c;
      }

      (this || _global$c).length = Math.ceil(number.length / 3);
      (this || _global$c).words = new Array((this || _global$c).length);

      for (var i = 0; i < (this || _global$c).length; i++) {
        (this || _global$c).words[i] = 0;
      }

      var j, w;
      var off = 0;

      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          (this || _global$c).words[j] |= w << off & 67108863;
          (this || _global$c).words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          (this || _global$c).words[j] |= w << off & 67108863;
          (this || _global$c).words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;

          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }

      return this.strip();
    };

    function parseHex4Bits(string, index) {
      var c = string.charCodeAt(index); // 'A' - 'F'

      if (c >= 65 && c <= 70) {
        return c - 55; // 'a' - 'f'
      } else if (c >= 97 && c <= 102) {
        return c - 87; // '0' - '9'
      } else {
        return c - 48 & 15;
      }
    }

    function parseHexByte(string, lowerBound, index) {
      var r = parseHex4Bits(string, index);

      if (index - 1 >= lowerBound) {
        r |= parseHex4Bits(string, index - 1) << 4;
      }

      return r;
    }

    BN.prototype._parseHex = function _parseHex(number, start, endian) {
      // Create possibly bigger array to ensure that it fits the number
      (this || _global$c).length = Math.ceil((number.length - start) / 6);
      (this || _global$c).words = new Array((this || _global$c).length);

      for (var i = 0; i < (this || _global$c).length; i++) {
        (this || _global$c).words[i] = 0;
      } // 24-bits chunks


      var off = 0;
      var j = 0;
      var w;

      if (endian === "be") {
        for (i = number.length - 1; i >= start; i -= 2) {
          w = parseHexByte(number, start, i) << off;
          (this || _global$c).words[j] |= w & 67108863;

          if (off >= 18) {
            off -= 18;
            j += 1;
            (this || _global$c).words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      } else {
        var parseLength = number.length - start;

        for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
          w = parseHexByte(number, start, i) << off;
          (this || _global$c).words[j] |= w & 67108863;

          if (off >= 18) {
            off -= 18;
            j += 1;
            (this || _global$c).words[j] |= w >>> 26;
          } else {
            off += 8;
          }
        }
      }

      this.strip();
    };

    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);

      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul; // 'a'

        if (c >= 49) {
          r += c - 49 + 10; // 'A'
        } else if (c >= 17) {
          r += c - 17 + 10; // '0' - '9'
        } else {
          r += c;
        }
      }

      return r;
    }

    BN.prototype._parseBase = function _parseBase(number, base, start) {
      // Initialize as zero
      (this || _global$c).words = [0];
      (this || _global$c).length = 1; // Find length of limb in base

      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }

      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;

      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);

        if ((this || _global$c).words[0] + word < 67108864) {
          (this || _global$c).words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);

        for (i = 0; i < mod; i++) {
          pow *= base;
        }

        this.imuln(pow);

        if ((this || _global$c).words[0] + word < 67108864) {
          (this || _global$c).words[0] += word;
        } else {
          this._iaddn(word);
        }
      }

      this.strip();
    };

    BN.prototype.copy = function copy(dest) {
      dest.words = new Array((this || _global$c).length);

      for (var i = 0; i < (this || _global$c).length; i++) {
        dest.words[i] = (this || _global$c).words[i];
      }

      dest.length = (this || _global$c).length;
      dest.negative = (this || _global$c).negative;
      dest.red = (this || _global$c).red;
    };

    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };

    BN.prototype._expand = function _expand(size) {
      while ((this || _global$c).length < size) {
        (this || _global$c).words[(this || _global$c).length++] = 0;
      }

      return this || _global$c;
    }; // Remove leading `0` from `this`


    BN.prototype.strip = function strip() {
      while ((this || _global$c).length > 1 && (this || _global$c).words[(this || _global$c).length - 1] === 0) {
        (this || _global$c).length--;
      }

      return this._normSign();
    };

    BN.prototype._normSign = function _normSign() {
      // -0 = 0
      if ((this || _global$c).length === 1 && (this || _global$c).words[0] === 0) {
        (this || _global$c).negative = 0;
      }

      return this || _global$c;
    };

    BN.prototype.inspect = function inspect() {
      return ((this || _global$c).red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    /*
     var zeros = [];
    var groupSizes = [];
    var groupBases = [];
     var s = '';
    var i = -1;
    while (++i < BN.wordSize) {
      zeros[i] = s;
      s += '0';
    }
    groupSizes[0] = 0;
    groupSizes[1] = 0;
    groupBases[0] = 0;
    groupBases[1] = 0;
    var base = 2 - 1;
    while (++base < 36 + 1) {
      var groupSize = 0;
      var groupBase = 1;
      while (groupBase < (1 << BN.wordSize) / base) {
        groupBase *= base;
        groupSize += 1;
      }
      groupSizes[base] = groupSize;
      groupBases[base] = groupBase;
    }
     */


    var zeros = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"];
    var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
    var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;

      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;

        for (var i = 0; i < (this || _global$c).length; i++) {
          var w = (this || _global$c).words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;

          if (carry !== 0 || i !== (this || _global$c).length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }

          off += 2;

          if (off >= 26) {
            off -= 26;
            i--;
          }
        }

        if (carry !== 0) {
          out = carry.toString(16) + out;
        }

        while (out.length % padding !== 0) {
          out = "0" + out;
        }

        if ((this || _global$c).negative !== 0) {
          out = "-" + out;
        }

        return out;
      }

      if (base === (base | 0) && base >= 2 && base <= 36) {
        // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
        var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;

        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);

          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }

        if (this.isZero()) {
          out = "0" + out;
        }

        while (out.length % padding !== 0) {
          out = "0" + out;
        }

        if ((this || _global$c).negative !== 0) {
          out = "-" + out;
        }

        return out;
      }

      assert(false, "Base should be between 2 and 36");
    };

    BN.prototype.toNumber = function toNumber() {
      var ret = (this || _global$c).words[0];

      if ((this || _global$c).length === 2) {
        ret += (this || _global$c).words[1] * 67108864;
      } else if ((this || _global$c).length === 3 && (this || _global$c).words[2] === 1) {
        // NOTE: at this stage it is known that the top bit is set
        ret += 4503599627370496 + (this || _global$c).words[1] * 67108864;
      } else if ((this || _global$c).length > 2) {
        assert(false, "Number can only safely store up to 53 bits");
      }

      return (this || _global$c).negative !== 0 ? -ret : ret;
    };

    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };

    BN.prototype.toBuffer = function toBuffer(endian, length) {
      assert(typeof Buffer !== "undefined");
      return this.toArrayLike(Buffer, endian, length);
    };

    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };

    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, "byte array longer than desired length");
      assert(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b, i;
      var q = this.clone();

      if (!littleEndian) {
        // Assume big-endian
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }

        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[i] = b;
        }

        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }

      return res;
    };

    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;

        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }

        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }

        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }

        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }

        return r + t;
      };
    }

    BN.prototype._zeroBits = function _zeroBits(w) {
      // Short-cut
      if (w === 0) return 26;
      var t = w;
      var r = 0;

      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }

      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }

      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }

      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }

      if ((t & 1) === 0) {
        r++;
      }

      return r;
    }; // Return number of used bits in a BN


    BN.prototype.bitLength = function bitLength() {
      var w = (this || _global$c).words[(this || _global$c).length - 1];

      var hi = this._countBits(w);

      return ((this || _global$c).length - 1) * 26 + hi;
    };

    function toBitArray(num) {
      var w = new Array(num.bitLength());

      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }

      return w;
    } // Number of trailing zero bits


    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero()) return 0;
      var r = 0;

      for (var i = 0; i < (this || _global$c).length; i++) {
        var b = this._zeroBits((this || _global$c).words[i]);

        r += b;
        if (b !== 26) break;
      }

      return r;
    };

    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };

    BN.prototype.toTwos = function toTwos(width) {
      if ((this || _global$c).negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }

      return this.clone();
    };

    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }

      return this.clone();
    };

    BN.prototype.isNeg = function isNeg() {
      return (this || _global$c).negative !== 0;
    }; // Return negative clone of `this`


    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };

    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        (this || _global$c).negative ^= 1;
      }

      return this || _global$c;
    }; // Or `num` with `this` in-place


    BN.prototype.iuor = function iuor(num) {
      while ((this || _global$c).length < num.length) {
        (this || _global$c).words[(this || _global$c).length++] = 0;
      }

      for (var i = 0; i < num.length; i++) {
        (this || _global$c).words[i] = (this || _global$c).words[i] | num.words[i];
      }

      return this.strip();
    };

    BN.prototype.ior = function ior(num) {
      assert(((this || _global$c).negative | num.negative) === 0);
      return this.iuor(num);
    }; // Or `num` with `this`


    BN.prototype.or = function or(num) {
      if ((this || _global$c).length > num.length) return this.clone().ior(num);
      return num.clone().ior(this || _global$c);
    };

    BN.prototype.uor = function uor(num) {
      if ((this || _global$c).length > num.length) return this.clone().iuor(num);
      return num.clone().iuor(this || _global$c);
    }; // And `num` with `this` in-place


    BN.prototype.iuand = function iuand(num) {
      // b = min-length(num, this)
      var b;

      if ((this || _global$c).length > num.length) {
        b = num;
      } else {
        b = this || _global$c;
      }

      for (var i = 0; i < b.length; i++) {
        (this || _global$c).words[i] = (this || _global$c).words[i] & num.words[i];
      }

      (this || _global$c).length = b.length;
      return this.strip();
    };

    BN.prototype.iand = function iand(num) {
      assert(((this || _global$c).negative | num.negative) === 0);
      return this.iuand(num);
    }; // And `num` with `this`


    BN.prototype.and = function and(num) {
      if ((this || _global$c).length > num.length) return this.clone().iand(num);
      return num.clone().iand(this || _global$c);
    };

    BN.prototype.uand = function uand(num) {
      if ((this || _global$c).length > num.length) return this.clone().iuand(num);
      return num.clone().iuand(this || _global$c);
    }; // Xor `num` with `this` in-place


    BN.prototype.iuxor = function iuxor(num) {
      // a.length > b.length
      var a;
      var b;

      if ((this || _global$c).length > num.length) {
        a = this || _global$c;
        b = num;
      } else {
        a = num;
        b = this || _global$c;
      }

      for (var i = 0; i < b.length; i++) {
        (this || _global$c).words[i] = a.words[i] ^ b.words[i];
      }

      if ((this || _global$c) !== a) {
        for (; i < a.length; i++) {
          (this || _global$c).words[i] = a.words[i];
        }
      }

      (this || _global$c).length = a.length;
      return this.strip();
    };

    BN.prototype.ixor = function ixor(num) {
      assert(((this || _global$c).negative | num.negative) === 0);
      return this.iuxor(num);
    }; // Xor `num` with `this`


    BN.prototype.xor = function xor(num) {
      if ((this || _global$c).length > num.length) return this.clone().ixor(num);
      return num.clone().ixor(this || _global$c);
    };

    BN.prototype.uxor = function uxor(num) {
      if ((this || _global$c).length > num.length) return this.clone().iuxor(num);
      return num.clone().iuxor(this || _global$c);
    }; // Not ``this`` with ``width`` bitwidth


    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26; // Extend the buffer with leading zeroes

      this._expand(bytesNeeded);

      if (bitsLeft > 0) {
        bytesNeeded--;
      } // Handle complete words


      for (var i = 0; i < bytesNeeded; i++) {
        (this || _global$c).words[i] = ~(this || _global$c).words[i] & 67108863;
      } // Handle the residue


      if (bitsLeft > 0) {
        (this || _global$c).words[i] = ~(this || _global$c).words[i] & 67108863 >> 26 - bitsLeft;
      } // And remove leading zeroes


      return this.strip();
    };

    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    }; // Set `bit` of `this`


    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;

      this._expand(off + 1);

      if (val) {
        (this || _global$c).words[off] = (this || _global$c).words[off] | 1 << wbit;
      } else {
        (this || _global$c).words[off] = (this || _global$c).words[off] & ~(1 << wbit);
      }

      return this.strip();
    }; // Add `num` to `this` in-place


    BN.prototype.iadd = function iadd(num) {
      var r; // negative + positive

      if ((this || _global$c).negative !== 0 && num.negative === 0) {
        (this || _global$c).negative = 0;
        r = this.isub(num);
        (this || _global$c).negative ^= 1;
        return this._normSign(); // positive + negative
      } else if ((this || _global$c).negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      } // a.length > b.length


      var a, b;

      if ((this || _global$c).length > num.length) {
        a = this || _global$c;
        b = num;
      } else {
        a = num;
        b = this || _global$c;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        (this || _global$c).words[i] = r & 67108863;
        carry = r >>> 26;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        (this || _global$c).words[i] = r & 67108863;
        carry = r >>> 26;
      }

      (this || _global$c).length = a.length;

      if (carry !== 0) {
        (this || _global$c).words[(this || _global$c).length] = carry;
        (this || _global$c).length++; // Copy the rest of the words
      } else if (a !== (this || _global$c)) {
        for (; i < a.length; i++) {
          (this || _global$c).words[i] = a.words[i];
        }
      }

      return this || _global$c;
    }; // Add `num` to `this`


    BN.prototype.add = function add(num) {
      var res;

      if (num.negative !== 0 && (this || _global$c).negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && (this || _global$c).negative !== 0) {
        (this || _global$c).negative = 0;
        res = num.sub(this || _global$c);
        (this || _global$c).negative = 1;
        return res;
      }

      if ((this || _global$c).length > num.length) return this.clone().iadd(num);
      return num.clone().iadd(this || _global$c);
    }; // Subtract `num` from `this` in-place


    BN.prototype.isub = function isub(num) {
      // this - (-num) = this + num
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign(); // -this - num = -(this + num)
      } else if ((this || _global$c).negative !== 0) {
        (this || _global$c).negative = 0;
        this.iadd(num);
        (this || _global$c).negative = 1;
        return this._normSign();
      } // At this point both numbers are positive


      var cmp = this.cmp(num); // Optimization - zeroify

      if (cmp === 0) {
        (this || _global$c).negative = 0;
        (this || _global$c).length = 1;
        (this || _global$c).words[0] = 0;
        return this || _global$c;
      } // a > b


      var a, b;

      if (cmp > 0) {
        a = this || _global$c;
        b = num;
      } else {
        a = num;
        b = this || _global$c;
      }

      var carry = 0;

      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        (this || _global$c).words[i] = r & 67108863;
      }

      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        (this || _global$c).words[i] = r & 67108863;
      } // Copy rest of the words


      if (carry === 0 && i < a.length && a !== (this || _global$c)) {
        for (; i < a.length; i++) {
          (this || _global$c).words[i] = a.words[i];
        }
      }

      (this || _global$c).length = Math.max((this || _global$c).length, i);

      if (a !== (this || _global$c)) {
        (this || _global$c).negative = 1;
      }

      return this.strip();
    }; // Subtract `num` from `this`


    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };

    function smallMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      var len = self.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

      var a = self.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;

      for (var k = 1; k < len; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }

        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }

      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }

      return out.strip();
    } // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).


    var comb10MulTo = function comb10MulTo(self, num, out) {
      var a = self.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self.negative ^ num.negative;
      out.length = 19;
      /* k = 0 */

      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      /* k = 1 */

      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      /* k = 2 */

      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      /* k = 3 */

      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      /* k = 4 */

      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      /* k = 5 */

      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      /* k = 6 */

      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      /* k = 7 */

      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      /* k = 8 */

      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      /* k = 9 */

      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      /* k = 10 */

      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      /* k = 11 */

      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      /* k = 12 */

      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      /* k = 13 */

      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      /* k = 14 */

      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      /* k = 15 */

      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      /* k = 16 */

      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      /* k = 17 */

      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      /* k = 18 */

      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;

      if (c !== 0) {
        o[19] = c;
        out.length++;
      }

      return out;
    }; // Polyfill comb


    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }

    function bigMulTo(self, num, out) {
      out.negative = num.negative ^ self.negative;
      out.length = self.length + num.length;
      var carry = 0;
      var hncarry = 0;

      for (var k = 0; k < out.length - 1; k++) {
        // Sum all words with the same `i + j = k` and accumulate `ncarry`,
        // note that ncarry could be >= 0x3ffffff
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);

        for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }

        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }

      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }

      return out.strip();
    }

    function jumboMulTo(self, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self, num, out);
    }

    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = (this || _global$c).length + num.length;

      if ((this || _global$c).length === 10 && num.length === 10) {
        res = comb10MulTo(this || _global$c, num, out);
      } else if (len < 63) {
        res = smallMulTo(this || _global$c, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this || _global$c, num, out);
      } else {
        res = jumboMulTo(this || _global$c, num, out);
      }

      return res;
    }; // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion


    function FFTM(x, y) {
      (this || _global$c).x = x;
      (this || _global$c).y = y;
    }

    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;

      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }

      return t;
    }; // Returns binary-reversed representation of `x`


    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1) return x;
      var rb = 0;

      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }

      return rb;
    }; // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm


    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };

    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);

      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);

        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;

          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            /* jshint maxdepth : false */

            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };

    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;

      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }

      return 1 << i + 1 + odd;
    };

    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1) return;

      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };

    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;

      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;

        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }

      return ws;
    };

    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;

      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      } // Pad with zeroes


      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }

      assert(carry === 0);
      assert((carry & ~8191) === 0);
    };

    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);

      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }

      return ph;
    };

    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);

      var _ = this.stub(N);

      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);

      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }

      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    }; // Multiply `this` by `num`


    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array((this || _global$c).length + num.length);
      return this.mulTo(num, out);
    }; // Multiply employing FFT


    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array((this || _global$c).length + num.length);
      return jumboMulTo(this || _global$c, num, out);
    }; // In-place Multiplication


    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this || _global$c);
    };

    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === "number");
      assert(num < 67108864); // Carry

      var carry = 0;

      for (var i = 0; i < (this || _global$c).length; i++) {
        var w = ((this || _global$c).words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0; // NOTE: lo is 27bit maximum

        carry += lo >>> 26;
        (this || _global$c).words[i] = lo & 67108863;
      }

      if (carry !== 0) {
        (this || _global$c).words[i] = carry;
        (this || _global$c).length++;
      }

      return this || _global$c;
    };

    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    }; // `this` * `this`


    BN.prototype.sqr = function sqr() {
      return this.mul(this || _global$c);
    }; // `this` * `this` in-place


    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    }; // Math.pow(`this`, `num`)


    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0) return new BN(1); // Skip leading zeroes

      var res = this || _global$c;

      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0) break;
      }

      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0) continue;
          res = res.mul(q);
        }
      }

      return res;
    }; // Shift-left in-place


    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;

      if (r !== 0) {
        var carry = 0;

        for (i = 0; i < (this || _global$c).length; i++) {
          var newCarry = (this || _global$c).words[i] & carryMask;
          var c = ((this || _global$c).words[i] | 0) - newCarry << r;
          (this || _global$c).words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }

        if (carry) {
          (this || _global$c).words[i] = carry;
          (this || _global$c).length++;
        }
      }

      if (s !== 0) {
        for (i = (this || _global$c).length - 1; i >= 0; i--) {
          (this || _global$c).words[i + s] = (this || _global$c).words[i];
        }

        for (i = 0; i < s; i++) {
          (this || _global$c).words[i] = 0;
        }

        (this || _global$c).length += s;
      }

      return this.strip();
    };

    BN.prototype.ishln = function ishln(bits) {
      // TODO(indutny): implement me
      assert((this || _global$c).negative === 0);
      return this.iushln(bits);
    }; // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits


    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === "number" && bits >= 0);
      var h;

      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }

      var r = bits % 26;
      var s = Math.min((bits - r) / 26, (this || _global$c).length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h); // Extended mode, copy masked part

      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = (this || _global$c).words[i];
        }

        maskedWords.length = s;
      }

      if (s === 0) ; else if ((this || _global$c).length > s) {
        (this || _global$c).length -= s;

        for (i = 0; i < (this || _global$c).length; i++) {
          (this || _global$c).words[i] = (this || _global$c).words[i + s];
        }
      } else {
        (this || _global$c).words[0] = 0;
        (this || _global$c).length = 1;
      }

      var carry = 0;

      for (i = (this || _global$c).length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = (this || _global$c).words[i] | 0;
        (this || _global$c).words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      } // Push carried bits as a mask


      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }

      if ((this || _global$c).length === 0) {
        (this || _global$c).words[0] = 0;
        (this || _global$c).length = 1;
      }

      return this.strip();
    };

    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      // TODO(indutny): implement me
      assert((this || _global$c).negative === 0);
      return this.iushrn(bits, hint, extended);
    }; // Shift-left


    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };

    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    }; // Shift-right


    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };

    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    }; // Test if n bit is set


    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if ((this || _global$c).length <= s) return false; // Check bit and return

      var w = (this || _global$c).words[s];
      return !!(w & q);
    }; // Return only lowers bits of number (in-place)


    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert((this || _global$c).negative === 0, "imaskn works only with positive numbers");

      if ((this || _global$c).length <= s) {
        return this || _global$c;
      }

      if (r !== 0) {
        s++;
      }

      (this || _global$c).length = Math.min(s, (this || _global$c).length);

      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        (this || _global$c).words[(this || _global$c).length - 1] &= mask;
      }

      return this.strip();
    }; // Return only lowers bits of number


    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    }; // Add plain number `num` to `this`


    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0) return this.isubn(-num); // Possible sign change

      if ((this || _global$c).negative !== 0) {
        if ((this || _global$c).length === 1 && ((this || _global$c).words[0] | 0) < num) {
          (this || _global$c).words[0] = num - ((this || _global$c).words[0] | 0);
          (this || _global$c).negative = 0;
          return this || _global$c;
        }

        (this || _global$c).negative = 0;
        this.isubn(num);
        (this || _global$c).negative = 1;
        return this || _global$c;
      } // Add without checks


      return this._iaddn(num);
    };

    BN.prototype._iaddn = function _iaddn(num) {
      (this || _global$c).words[0] += num; // Carry

      for (var i = 0; i < (this || _global$c).length && (this || _global$c).words[i] >= 67108864; i++) {
        (this || _global$c).words[i] -= 67108864;

        if (i === (this || _global$c).length - 1) {
          (this || _global$c).words[i + 1] = 1;
        } else {
          (this || _global$c).words[i + 1]++;
        }
      }

      (this || _global$c).length = Math.max((this || _global$c).length, i + 1);
      return this || _global$c;
    }; // Subtract plain number `num` from `this`


    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0) return this.iaddn(-num);

      if ((this || _global$c).negative !== 0) {
        (this || _global$c).negative = 0;
        this.iaddn(num);
        (this || _global$c).negative = 1;
        return this || _global$c;
      }

      (this || _global$c).words[0] -= num;

      if ((this || _global$c).length === 1 && (this || _global$c).words[0] < 0) {
        (this || _global$c).words[0] = -(this || _global$c).words[0];
        (this || _global$c).negative = 1;
      } else {
        // Carry
        for (var i = 0; i < (this || _global$c).length && (this || _global$c).words[i] < 0; i++) {
          (this || _global$c).words[i] += 67108864;
          (this || _global$c).words[i + 1] -= 1;
        }
      }

      return this.strip();
    };

    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };

    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };

    BN.prototype.iabs = function iabs() {
      (this || _global$c).negative = 0;
      return this || _global$c;
    };

    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };

    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;

      this._expand(len);

      var w;
      var carry = 0;

      for (i = 0; i < num.length; i++) {
        w = ((this || _global$c).words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        (this || _global$c).words[i + shift] = w & 67108863;
      }

      for (; i < (this || _global$c).length - shift; i++) {
        w = ((this || _global$c).words[i + shift] | 0) + carry;
        carry = w >> 26;
        (this || _global$c).words[i + shift] = w & 67108863;
      }

      if (carry === 0) return this.strip(); // Subtraction overflow

      assert(carry === -1);
      carry = 0;

      for (i = 0; i < (this || _global$c).length; i++) {
        w = -((this || _global$c).words[i] | 0) + carry;
        carry = w >> 26;
        (this || _global$c).words[i] = w & 67108863;
      }

      (this || _global$c).negative = 1;
      return this.strip();
    };

    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = (this || _global$c).length - num.length;
      var a = this.clone();
      var b = num; // Normalize

      var bhi = b.words[b.length - 1] | 0;

      var bhiBits = this._countBits(bhi);

      shift = 26 - bhiBits;

      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      } // Initialize quotient


      var m = a.length - b.length;
      var q;

      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);

        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }

      var diff = a.clone()._ishlnsubmul(b, 1, m);

      if (diff.negative === 0) {
        a = diff;

        if (q) {
          q.words[m] = 1;
        }
      }

      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
        // (0x7ffffff)

        qj = Math.min(qj / bhi | 0, 67108863);

        a._ishlnsubmul(b, qj, j);

        while (a.negative !== 0) {
          qj--;
          a.negative = 0;

          a._ishlnsubmul(b, 1, j);

          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }

        if (q) {
          q.words[j] = qj;
        }
      }

      if (q) {
        q.strip();
      }

      a.strip(); // Denormalize

      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }

      return {
        div: q || null,
        mod: a
      };
    }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested


    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());

      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }

      var div, mod, res;

      if ((this || _global$c).negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);

        if (mode !== "mod") {
          div = res.div.neg();
        }

        if (mode !== "div") {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }

        return {
          div: div,
          mod: mod
        };
      }

      if ((this || _global$c).negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);

        if (mode !== "mod") {
          div = res.div.neg();
        }

        return {
          div: div,
          mod: res.mod
        };
      }

      if (((this || _global$c).negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);

        if (mode !== "div") {
          mod = res.mod.neg();

          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }

        return {
          div: res.div,
          mod: mod
        };
      } // Both numbers are positive at this point
      // Strip both numbers to approximate shift value


      if (num.length > (this || _global$c).length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this || _global$c
        };
      } // Very short reduction


      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }

        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }

        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return this._wordDiv(num, mode);
    }; // Find `this` / `num`


    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    }; // Find `this` % `num`


    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };

    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    }; // Find Round(`this` / `num`)


    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num); // Fast case - exact division

      if (dm.mod.isZero()) return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half); // Round down

      if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };

    BN.prototype.modn = function modn(num) {
      assert(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;

      for (var i = (this || _global$c).length - 1; i >= 0; i--) {
        acc = (p * acc + ((this || _global$c).words[i] | 0)) % num;
      }

      return acc;
    }; // In-place division by number


    BN.prototype.idivn = function idivn(num) {
      assert(num <= 67108863);
      var carry = 0;

      for (var i = (this || _global$c).length - 1; i >= 0; i--) {
        var w = ((this || _global$c).words[i] | 0) + carry * 67108864;
        (this || _global$c).words[i] = w / num | 0;
        carry = w % num;
      }

      return this.strip();
    };

    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };

    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this || _global$c;
      var y = p.clone();

      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      } // A * x + B * y = x


      var A = new BN(1);
      var B = new BN(0); // C * x + D * y = y

      var C = new BN(0);
      var D = new BN(1);
      var g = 0;

      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }

      var yp = y.clone();
      var xp = x.clone();

      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

        if (i > 0) {
          x.iushrn(i);

          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }

            A.iushrn(1);
            B.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

        if (j > 0) {
          y.iushrn(j);

          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }

            C.iushrn(1);
            D.iushrn(1);
          }
        }

        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }

      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    }; // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed


    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this || _global$c;
      var b = p.clone();

      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }

      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();

      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

        if (i > 0) {
          a.iushrn(i);

          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }

            x1.iushrn(1);
          }
        }

        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

        if (j > 0) {
          b.iushrn(j);

          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }

            x2.iushrn(1);
          }
        }

        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }

      var res;

      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }

      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }

      return res;
    };

    BN.prototype.gcd = function gcd(num) {
      if (this.isZero()) return num.abs();
      if (num.isZero()) return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0; // Remove common factor of two

      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }

      do {
        while (a.isEven()) {
          a.iushrn(1);
        }

        while (b.isEven()) {
          b.iushrn(1);
        }

        var r = a.cmp(b);

        if (r < 0) {
          // Swap `a` and `b` to make `a` always bigger than `b`
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }

        a.isub(b);
      } while (true);

      return b.iushln(shift);
    }; // Invert number in the field F(num)


    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };

    BN.prototype.isEven = function isEven() {
      return ((this || _global$c).words[0] & 1) === 0;
    };

    BN.prototype.isOdd = function isOdd() {
      return ((this || _global$c).words[0] & 1) === 1;
    }; // And first word and num


    BN.prototype.andln = function andln(num) {
      return (this || _global$c).words[0] & num;
    }; // Increment at the bit position in-line


    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r; // Fast case: bit is much higher than all existing words

      if ((this || _global$c).length <= s) {
        this._expand(s + 1);

        (this || _global$c).words[s] |= q;
        return this || _global$c;
      } // Add bit and propagate, if needed


      var carry = q;

      for (var i = s; carry !== 0 && i < (this || _global$c).length; i++) {
        var w = (this || _global$c).words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        (this || _global$c).words[i] = w;
      }

      if (carry !== 0) {
        (this || _global$c).words[i] = carry;
        (this || _global$c).length++;
      }

      return this || _global$c;
    };

    BN.prototype.isZero = function isZero() {
      return (this || _global$c).length === 1 && (this || _global$c).words[0] === 0;
    };

    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if ((this || _global$c).negative !== 0 && !negative) return -1;
      if ((this || _global$c).negative === 0 && negative) return 1;
      this.strip();
      var res;

      if ((this || _global$c).length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }

        assert(num <= 67108863, "Number is too big");
        var w = (this || _global$c).words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }

      if ((this || _global$c).negative !== 0) return -res | 0;
      return res;
    }; // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`


    BN.prototype.cmp = function cmp(num) {
      if ((this || _global$c).negative !== 0 && num.negative === 0) return -1;
      if ((this || _global$c).negative === 0 && num.negative !== 0) return 1;
      var res = this.ucmp(num);
      if ((this || _global$c).negative !== 0) return -res | 0;
      return res;
    }; // Unsigned comparison


    BN.prototype.ucmp = function ucmp(num) {
      // At this point both numbers have the same sign
      if ((this || _global$c).length > num.length) return 1;
      if ((this || _global$c).length < num.length) return -1;
      var res = 0;

      for (var i = (this || _global$c).length - 1; i >= 0; i--) {
        var a = (this || _global$c).words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b) continue;

        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }

        break;
      }

      return res;
    };

    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };

    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };

    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };

    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };

    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };

    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };

    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };

    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };

    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };

    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    }; //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //


    BN.red = function red(num) {
      return new Red(num);
    };

    BN.prototype.toRed = function toRed(ctx) {
      assert(!(this || _global$c).red, "Already a number in reduction context");
      assert((this || _global$c).negative === 0, "red works only with positives");
      return ctx.convertTo(this || _global$c)._forceRed(ctx);
    };

    BN.prototype.fromRed = function fromRed() {
      assert((this || _global$c).red, "fromRed works only with numbers in reduction context");
      return (this || _global$c).red.convertFrom(this || _global$c);
    };

    BN.prototype._forceRed = function _forceRed(ctx) {
      (this || _global$c).red = ctx;
      return this || _global$c;
    };

    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!(this || _global$c).red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };

    BN.prototype.redAdd = function redAdd(num) {
      assert((this || _global$c).red, "redAdd works only with red numbers");
      return (this || _global$c).red.add(this || _global$c, num);
    };

    BN.prototype.redIAdd = function redIAdd(num) {
      assert((this || _global$c).red, "redIAdd works only with red numbers");
      return (this || _global$c).red.iadd(this || _global$c, num);
    };

    BN.prototype.redSub = function redSub(num) {
      assert((this || _global$c).red, "redSub works only with red numbers");
      return (this || _global$c).red.sub(this || _global$c, num);
    };

    BN.prototype.redISub = function redISub(num) {
      assert((this || _global$c).red, "redISub works only with red numbers");
      return (this || _global$c).red.isub(this || _global$c, num);
    };

    BN.prototype.redShl = function redShl(num) {
      assert((this || _global$c).red, "redShl works only with red numbers");
      return (this || _global$c).red.shl(this || _global$c, num);
    };

    BN.prototype.redMul = function redMul(num) {
      assert((this || _global$c).red, "redMul works only with red numbers");

      (this || _global$c).red._verify2(this || _global$c, num);

      return (this || _global$c).red.mul(this || _global$c, num);
    };

    BN.prototype.redIMul = function redIMul(num) {
      assert((this || _global$c).red, "redMul works only with red numbers");

      (this || _global$c).red._verify2(this || _global$c, num);

      return (this || _global$c).red.imul(this || _global$c, num);
    };

    BN.prototype.redSqr = function redSqr() {
      assert((this || _global$c).red, "redSqr works only with red numbers");

      (this || _global$c).red._verify1(this || _global$c);

      return (this || _global$c).red.sqr(this || _global$c);
    };

    BN.prototype.redISqr = function redISqr() {
      assert((this || _global$c).red, "redISqr works only with red numbers");

      (this || _global$c).red._verify1(this || _global$c);

      return (this || _global$c).red.isqr(this || _global$c);
    }; // Square root over p


    BN.prototype.redSqrt = function redSqrt() {
      assert((this || _global$c).red, "redSqrt works only with red numbers");

      (this || _global$c).red._verify1(this || _global$c);

      return (this || _global$c).red.sqrt(this || _global$c);
    };

    BN.prototype.redInvm = function redInvm() {
      assert((this || _global$c).red, "redInvm works only with red numbers");

      (this || _global$c).red._verify1(this || _global$c);

      return (this || _global$c).red.invm(this || _global$c);
    }; // Return negative clone of `this` % `red modulo`


    BN.prototype.redNeg = function redNeg() {
      assert((this || _global$c).red, "redNeg works only with red numbers");

      (this || _global$c).red._verify1(this || _global$c);

      return (this || _global$c).red.neg(this || _global$c);
    };

    BN.prototype.redPow = function redPow(num) {
      assert((this || _global$c).red && !num.red, "redPow(normalNum)");

      (this || _global$c).red._verify1(this || _global$c);

      return (this || _global$c).red.pow(this || _global$c, num);
    }; // Prime numbers with efficient reduction


    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    }; // Pseudo-Mersenne prime

    function MPrime(name, p) {
      // P = 2 ^ N - K
      (this || _global$c).name = name;
      (this || _global$c).p = new BN(p, 16);
      (this || _global$c).n = (this || _global$c).p.bitLength();
      (this || _global$c).k = new BN(1).iushln((this || _global$c).n).isub((this || _global$c).p);
      (this || _global$c).tmp = this._tmp();
    }

    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil((this || _global$c).n / 13));
      return tmp;
    };

    MPrime.prototype.ireduce = function ireduce(num) {
      // Assumes that `num` is less than `P^2`
      // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
      var r = num;
      var rlen;

      do {
        this.split(r, (this || _global$c).tmp);
        r = this.imulK(r);
        r = r.iadd((this || _global$c).tmp);
        rlen = r.bitLength();
      } while (rlen > (this || _global$c).n);

      var cmp = rlen < (this || _global$c).n ? -1 : r.ucmp((this || _global$c).p);

      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub((this || _global$c).p);
      } else {
        if (r.strip !== undefined) {
          // r is BN v4 instance
          r.strip();
        } else {
          // r is BN v5 instance
          r._strip();
        }
      }

      return r;
    };

    MPrime.prototype.split = function split(input, out) {
      input.iushrn((this || _global$c).n, 0, out);
    };

    MPrime.prototype.imulK = function imulK(num) {
      return num.imul((this || _global$c).k);
    };

    function K256() {
      MPrime.call(this || _global$c, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }

    inherits(K256, MPrime);

    K256.prototype.split = function split(input, output) {
      // 256 = 9 * 26 + 22
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);

      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }

      output.length = outLen;

      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      } // Shift by 9 limbs


      var prev = input.words[9];
      output.words[output.length++] = prev & mask;

      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }

      prev >>>= 22;
      input.words[i - 10] = prev;

      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };

    K256.prototype.imulK = function imulK(num) {
      // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

      var lo = 0;

      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      } // Fast length reduction


      if (num.words[num.length - 1] === 0) {
        num.length--;

        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }

      return num;
    };

    function P224() {
      MPrime.call(this || _global$c, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }

    inherits(P224, MPrime);

    function P192() {
      MPrime.call(this || _global$c, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }

    inherits(P192, MPrime);

    function P25519() {
      // 2 ^ 255 - 19
      MPrime.call(this || _global$c, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }

    inherits(P25519, MPrime);

    P25519.prototype.imulK = function imulK(num) {
      // K = 0x13
      var carry = 0;

      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }

      if (carry !== 0) {
        num.words[num.length++] = carry;
      }

      return num;
    }; // Exported mostly for testing purposes, use plain name instead


    BN._prime = function prime(name) {
      // Cached version of prime
      if (primes[name]) return primes[name];
      var prime;

      if (name === "k256") {
        prime = new K256();
      } else if (name === "p224") {
        prime = new P224();
      } else if (name === "p192") {
        prime = new P192();
      } else if (name === "p25519") {
        prime = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }

      primes[name] = prime;
      return prime;
    }; //
    // Base reduction engine
    //


    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);

        (this || _global$c).m = prime.p;
        (this || _global$c).prime = prime;
      } else {
        assert(m.gtn(1), "modulus must be greater than 1");
        (this || _global$c).m = m;
        (this || _global$c).prime = null;
      }
    }

    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, "red works only with positives");
      assert(a.red, "red works only with red numbers");
    };

    Red.prototype._verify2 = function _verify2(a, b) {
      assert((a.negative | b.negative) === 0, "red works only with positives");
      assert(a.red && a.red === b.red, "red works only with red numbers");
    };

    Red.prototype.imod = function imod(a) {
      if ((this || _global$c).prime) return (this || _global$c).prime.ireduce(a)._forceRed(this || _global$c);
      return a.umod((this || _global$c).m)._forceRed(this || _global$c);
    };

    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }

      return (this || _global$c).m.sub(a)._forceRed(this || _global$c);
    };

    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);

      var res = a.add(b);

      if (res.cmp((this || _global$c).m) >= 0) {
        res.isub((this || _global$c).m);
      }

      return res._forceRed(this || _global$c);
    };

    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);

      var res = a.iadd(b);

      if (res.cmp((this || _global$c).m) >= 0) {
        res.isub((this || _global$c).m);
      }

      return res;
    };

    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);

      var res = a.sub(b);

      if (res.cmpn(0) < 0) {
        res.iadd((this || _global$c).m);
      }

      return res._forceRed(this || _global$c);
    };

    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);

      var res = a.isub(b);

      if (res.cmpn(0) < 0) {
        res.iadd((this || _global$c).m);
      }

      return res;
    };

    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);

      return this.imod(a.ushln(num));
    };

    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);

      return this.imod(a.imul(b));
    };

    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);

      return this.imod(a.mul(b));
    };

    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };

    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };

    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero()) return a.clone();

      var mod3 = (this || _global$c).m.andln(3);

      assert(mod3 % 2 === 1); // Fast case

      if (mod3 === 3) {
        var pow = (this || _global$c).m.add(new BN(1)).iushrn(2);

        return this.pow(a, pow);
      } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
      //
      // Find Q and S, that Q * 2 ^ S = (P - 1)


      var q = (this || _global$c).m.subn(1);

      var s = 0;

      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }

      assert(!q.isZero());
      var one = new BN(1).toRed(this || _global$c);
      var nOne = one.redNeg(); // Find quadratic non-residue
      // NOTE: Max is such because of generalized Riemann hypothesis.

      var lpow = (this || _global$c).m.subn(1).iushrn(1);

      var z = (this || _global$c).m.bitLength();

      z = new BN(2 * z * z).toRed(this || _global$c);

      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }

      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;

      while (t.cmp(one) !== 0) {
        var tmp = t;

        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }

        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }

      return r;
    };

    Red.prototype.invm = function invm(a) {
      var inv = a._invmp((this || _global$c).m);

      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };

    Red.prototype.pow = function pow(a, num) {
      if (num.isZero()) return new BN(1).toRed(this || _global$c);
      if (num.cmpn(1) === 0) return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this || _global$c);
      wnd[1] = a;

      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }

      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;

      if (start === 0) {
        start = 26;
      }

      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];

        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;

          if (res !== wnd[0]) {
            res = this.sqr(res);
          }

          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }

          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }

        start = 26;
      }

      return res;
    };

    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod((this || _global$c).m);
      return r === num ? r.clone() : r;
    };

    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    }; //
    // Montgomery method engine
    //


    BN.mont = function mont(num) {
      return new Mont(num);
    };

    function Mont(m) {
      Red.call(this || _global$c, m);
      (this || _global$c).shift = (this || _global$c).m.bitLength();

      if ((this || _global$c).shift % 26 !== 0) {
        (this || _global$c).shift += 26 - (this || _global$c).shift % 26;
      }

      (this || _global$c).r = new BN(1).iushln((this || _global$c).shift);
      (this || _global$c).r2 = this.imod((this || _global$c).r.sqr());
      (this || _global$c).rinv = (this || _global$c).r._invmp((this || _global$c).m);
      (this || _global$c).minv = (this || _global$c).rinv.mul((this || _global$c).r).isubn(1).div((this || _global$c).m);
      (this || _global$c).minv = (this || _global$c).minv.umod((this || _global$c).r);
      (this || _global$c).minv = (this || _global$c).r.sub((this || _global$c).minv);
    }

    inherits(Mont, Red);

    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln((this || _global$c).shift));
    };

    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul((this || _global$c).rinv));
      r.red = null;
      return r;
    };

    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }

      var t = a.imul(b);
      var c = t.maskn((this || _global$c).shift).mul((this || _global$c).minv).imaskn((this || _global$c).shift).mul((this || _global$c).m);
      var u = t.isub(c).iushrn((this || _global$c).shift);
      var res = u;

      if (u.cmp((this || _global$c).m) >= 0) {
        res = u.isub((this || _global$c).m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd((this || _global$c).m);
      }

      return res._forceRed(this || _global$c);
    };

    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this || _global$c);
      var t = a.mul(b);
      var c = t.maskn((this || _global$c).shift).mul((this || _global$c).minv).imaskn((this || _global$c).shift).mul((this || _global$c).m);
      var u = t.isub(c).iushrn((this || _global$c).shift);
      var res = u;

      if (u.cmp((this || _global$c).m) >= 0) {
        res = u.isub((this || _global$c).m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd((this || _global$c).m);
      }

      return res._forceRed(this || _global$c);
    };

    Mont.prototype.invm = function invm(a) {
      // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
      var res = this.imod(a._invmp((this || _global$c).m).mul((this || _global$c).r2));
      return res._forceRed(this || _global$c);
    };
  })(module$5, exports$12$1);

  return module$5.exports;
}

var _global$b="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,exports$11$1={},indexOf=function(e,t){if(e.indexOf)return e.indexOf(t);for(var n=0;n<e.length;n++)if(e[n]===t)return n;return -1},Object_keys=function(e){if(Object.keys)return Object.keys(e);var t=[];for(var n in e)t.push(n);return t},forEach=function(e,t){if(e.forEach)return e.forEach(t);for(var n=0;n<e.length;n++)t(e[n],n,e);},defineProp=function(){try{return Object.defineProperty({},"_",{}),function(e,t,n){Object.defineProperty(e,t,{writable:!0,enumerable:!1,configurable:!0,value:n});}}catch(e){return function(e,t,n){e[t]=n;}}}(),globals=["Array","Boolean","Date","Error","EvalError","Function","Infinity","JSON","Math","NaN","Number","Object","RangeError","ReferenceError","RegExp","String","SyntaxError","TypeError","URIError","decodeURI","decodeURIComponent","encodeURI","encodeURIComponent","escape","eval","isFinite","isNaN","parseFloat","parseInt","undefined","unescape"];function Context(){}Context.prototype={};var Script=exports$11$1.Script=function(e){if(!((this||_global$b)instanceof Script))return new Script(e);(this||_global$b).code=e;};Script.prototype.runInContext=function(e){if(!(e instanceof Context))throw new TypeError("needs a 'context' argument.");var t=document.createElement("iframe");t.style||(t.style={}),t.style.display="none",document.body.appendChild(t);var n=t.contentWindow,r=n.eval,o=n.execScript;!r&&o&&(o.call(n,"null"),r=n.eval),forEach(Object_keys(e),(function(t){n[t]=e[t];})),forEach(globals,(function(t){e[t]&&(n[t]=e[t]);}));var c=Object_keys(n),i=r.call(n,(this||_global$b).code);return forEach(Object_keys(n),(function(t){(t in e||-1===indexOf(c,t))&&(e[t]=n[t]);})),forEach(globals,(function(t){t in e||defineProp(e,t,n[t]);})),document.body.removeChild(t),i},Script.prototype.runInThisContext=function(){return eval((this||_global$b).code)},Script.prototype.runInNewContext=function(e){var t=Script.createContext(e),n=this.runInContext(t);return e&&forEach(Object_keys(t),(function(n){e[n]=t[n];})),n},forEach(Object_keys(Script.prototype),(function(e){exports$11$1[e]=Script[e]=function(t){var n=Script(t);return n[e].apply(n,[].slice.call(arguments,1))};})),exports$11$1.isContext=function(e){return e instanceof Context},exports$11$1.createScript=function(e){return exports$11$1.Script(e)},exports$11$1.createContext=Script.createContext=function(e){var t=new Context;return "object"==typeof e&&forEach(Object_keys(e),(function(n){t[n]=e[n];})),t};exports$11$1.Script;exports$11$1.createContext;exports$11$1.createScript;exports$11$1.isContext;exports$11$1.runInContext;exports$11$1.runInNewContext;exports$11$1.runInThisContext;

var o="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,n=T$9;var t=u$q.Buffer,f=o.crypto||o.msCrypto;var a=f&&f.getRandomValues?function(e,r){if(e>4294967295)throw new RangeError("requested too many random bytes");var o=t.allocUnsafe(e);if(e>0)if(e>65536)for(var a=0;a<e;a+=65536)f.getRandomValues(o.slice(a,a+65536));else f.getRandomValues(o);if("function"==typeof r)return n.nextTick((function(){r(null,o);}));return o}:function(){throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11")};var e=u$q.Buffer,o$1=b$i.Transform;function s(t){o$1.call(this),this._block=e.allocUnsafe(t),this._blockSize=t,this._blockOffset=0,this._length=[0,0,0,0],this._finalized=!1;}t$2$2(s,o$1),s.prototype._transform=function(t,i,r){var e=null;try{this.update(t,i);}catch(t){e=t;}r(e);},s.prototype._flush=function(t){var i=null;try{this.push(this.digest());}catch(t){i=t;}t(i);},s.prototype.update=function(t,i){if(!function(t,i){if(!e.isBuffer(t)&&"string"!=typeof t)throw new TypeError(i+" must be a string or a buffer")}(t,"Data"),this._finalized)throw new Error("Digest already called");e.isBuffer(t)||(t=e.from(t,i));for(var r=this._block,o=0;this._blockOffset+t.length-o>=this._blockSize;){for(var s=this._blockOffset;s<this._blockSize;)r[s++]=t[o++];this._update(),this._blockOffset=0;}for(;o<t.length;)r[this._blockOffset++]=t[o++];for(var f=0,n=8*t.length;n>0;++f)this._length[f]+=n,(n=this._length[f]/4294967296|0)>0&&(this._length[f]-=4294967296*n);return this},s.prototype._update=function(){throw new Error("_update is not implemented")},s.prototype.digest=function(t){if(this._finalized)throw new Error("Digest already called");this._finalized=!0;var i=this._digest();void 0!==t&&(i=i.toString(t)),this._block.fill(0),this._blockOffset=0;for(var r=0;r<4;++r)this._length[r]=0;return i},s.prototype._digest=function(){throw new Error("_digest is not implemented")};var f$1=s;var h=t$2$2,r=f$1,_=u$q.Buffer,e$1=new Array(16);function n$1(){r.call(this,64),this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878;}function o$2(t,i){return t<<i|t>>>32-i}function f$2(t,i,s,h,r,_,e){return o$2(t+(i&s|~i&h)+r+_|0,e)+i|0}function c(t,i,s,h,r,_,e){return o$2(t+(i&h|s&~h)+r+_|0,e)+i|0}function a$1(t,i,s,h,r,_,e){return o$2(t+(i^s^h)+r+_|0,e)+i|0}function l(t,i,s,h,r,_,e){return o$2(t+(s^(i|~h))+r+_|0,e)+i|0}h(n$1,r),n$1.prototype._update=function(){for(var t=e$1,i=0;i<16;++i)t[i]=this._block.readInt32LE(4*i);var s=this._a,h=this._b,r=this._c,_=this._d;s=f$2(s,h,r,_,t[0],3614090360,7),_=f$2(_,s,h,r,t[1],3905402710,12),r=f$2(r,_,s,h,t[2],606105819,17),h=f$2(h,r,_,s,t[3],3250441966,22),s=f$2(s,h,r,_,t[4],4118548399,7),_=f$2(_,s,h,r,t[5],1200080426,12),r=f$2(r,_,s,h,t[6],2821735955,17),h=f$2(h,r,_,s,t[7],4249261313,22),s=f$2(s,h,r,_,t[8],1770035416,7),_=f$2(_,s,h,r,t[9],2336552879,12),r=f$2(r,_,s,h,t[10],4294925233,17),h=f$2(h,r,_,s,t[11],2304563134,22),s=f$2(s,h,r,_,t[12],1804603682,7),_=f$2(_,s,h,r,t[13],4254626195,12),r=f$2(r,_,s,h,t[14],2792965006,17),s=c(s,h=f$2(h,r,_,s,t[15],1236535329,22),r,_,t[1],4129170786,5),_=c(_,s,h,r,t[6],3225465664,9),r=c(r,_,s,h,t[11],643717713,14),h=c(h,r,_,s,t[0],3921069994,20),s=c(s,h,r,_,t[5],3593408605,5),_=c(_,s,h,r,t[10],38016083,9),r=c(r,_,s,h,t[15],3634488961,14),h=c(h,r,_,s,t[4],3889429448,20),s=c(s,h,r,_,t[9],568446438,5),_=c(_,s,h,r,t[14],3275163606,9),r=c(r,_,s,h,t[3],4107603335,14),h=c(h,r,_,s,t[8],1163531501,20),s=c(s,h,r,_,t[13],2850285829,5),_=c(_,s,h,r,t[2],4243563512,9),r=c(r,_,s,h,t[7],1735328473,14),s=a$1(s,h=c(h,r,_,s,t[12],2368359562,20),r,_,t[5],4294588738,4),_=a$1(_,s,h,r,t[8],2272392833,11),r=a$1(r,_,s,h,t[11],1839030562,16),h=a$1(h,r,_,s,t[14],4259657740,23),s=a$1(s,h,r,_,t[1],2763975236,4),_=a$1(_,s,h,r,t[4],1272893353,11),r=a$1(r,_,s,h,t[7],4139469664,16),h=a$1(h,r,_,s,t[10],3200236656,23),s=a$1(s,h,r,_,t[13],681279174,4),_=a$1(_,s,h,r,t[0],3936430074,11),r=a$1(r,_,s,h,t[3],3572445317,16),h=a$1(h,r,_,s,t[6],76029189,23),s=a$1(s,h,r,_,t[9],3654602809,4),_=a$1(_,s,h,r,t[12],3873151461,11),r=a$1(r,_,s,h,t[15],530742520,16),s=l(s,h=a$1(h,r,_,s,t[2],3299628645,23),r,_,t[0],4096336452,6),_=l(_,s,h,r,t[7],1126891415,10),r=l(r,_,s,h,t[14],2878612391,15),h=l(h,r,_,s,t[5],4237533241,21),s=l(s,h,r,_,t[12],1700485571,6),_=l(_,s,h,r,t[3],2399980690,10),r=l(r,_,s,h,t[10],4293915773,15),h=l(h,r,_,s,t[1],2240044497,21),s=l(s,h,r,_,t[8],1873313359,6),_=l(_,s,h,r,t[15],4264355552,10),r=l(r,_,s,h,t[6],2734768916,15),h=l(h,r,_,s,t[13],1309151649,21),s=l(s,h,r,_,t[4],4149444226,6),_=l(_,s,h,r,t[11],3174756917,10),r=l(r,_,s,h,t[2],718787259,15),h=l(h,r,_,s,t[9],3951481745,21),this._a=this._a+s|0,this._b=this._b+h|0,this._c=this._c+r|0,this._d=this._d+_|0;},n$1.prototype._digest=function(){this._block[this._blockOffset++]=128,this._blockOffset>56&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56),this._block.writeUInt32LE(this._length[0],56),this._block.writeUInt32LE(this._length[1],60),this._update();var t=_.allocUnsafe(16);return t.writeInt32LE(this._a,0),t.writeInt32LE(this._b,4),t.writeInt32LE(this._c,8),t.writeInt32LE(this._d,12),t};var u=n$1;var h$1=e$1$1$1.Buffer,_$1=t$2$2,r$1=f$1,e$2=new Array(16),n$2=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8,3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12,1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2,4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13],o$3=[5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12,6,11,3,7,0,13,5,10,14,15,8,12,4,9,1,2,15,5,1,3,7,14,6,9,11,8,12,2,10,0,4,13,8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14,12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11],f$3=[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8,7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12,11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5,11,12,14,15,14,15,9,8,9,14,5,6,8,6,5,12,9,15,5,11,6,8,13,12,5,12,13,14,11,8,5,6],c$1=[8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6,9,13,15,7,12,8,9,11,7,7,12,7,6,15,13,11,9,7,15,11,8,6,6,14,12,13,5,14,13,13,7,5,15,5,8,11,14,14,6,14,6,9,12,9,12,5,15,8,8,5,12,9,12,5,14,6,8,13,6,5,15,13,11,11],a$2=[0,1518500249,1859775393,2400959708,2840853838],l$1=[1352829926,1548603684,1836072691,2053994217,0];function u$1(){r$1.call(this,64),this._a=1732584193,this._b=4023233417,this._c=2562383102,this._d=271733878,this._e=3285377520;}function b(t,i){return t<<i|t>>>32-i}function d(t,i,s,h,_,r,e,n){return b(t+(i^s^h)+r+e|0,n)+_|0}function k(t,i,s,h,_,r,e,n){return b(t+(i&s|~i&h)+r+e|0,n)+_|0}function p(t,i,s,h,_,r,e,n){return b(t+((i|~s)^h)+r+e|0,n)+_|0}function w(t,i,s,h,_,r,e,n){return b(t+(i&h|s&~h)+r+e|0,n)+_|0}function E(t,i,s,h,_,r,e,n){return b(t+(i^(s|~h))+r+e|0,n)+_|0}_$1(u$1,r$1),u$1.prototype._update=function(){for(var t=e$2,i=0;i<16;++i)t[i]=this._block.readInt32LE(4*i);for(var s=0|this._a,h=0|this._b,_=0|this._c,r=0|this._d,u=0|this._e,I=0|this._a,L=0|this._b,v=0|this._c,m=0|this._d,O=0|this._e,g=0;g<80;g+=1){var y,U;g<16?(y=d(s,h,_,r,u,t[n$2[g]],a$2[0],f$3[g]),U=E(I,L,v,m,O,t[o$3[g]],l$1[0],c$1[g])):g<32?(y=k(s,h,_,r,u,t[n$2[g]],a$2[1],f$3[g]),U=w(I,L,v,m,O,t[o$3[g]],l$1[1],c$1[g])):g<48?(y=p(s,h,_,r,u,t[n$2[g]],a$2[2],f$3[g]),U=p(I,L,v,m,O,t[o$3[g]],l$1[2],c$1[g])):g<64?(y=w(s,h,_,r,u,t[n$2[g]],a$2[3],f$3[g]),U=k(I,L,v,m,O,t[o$3[g]],l$1[3],c$1[g])):(y=E(s,h,_,r,u,t[n$2[g]],a$2[4],f$3[g]),U=d(I,L,v,m,O,t[o$3[g]],l$1[4],c$1[g])),s=u,u=r,r=b(_,10),_=h,h=y,I=O,O=m,m=b(v,10),v=L,L=U;}var x=this._b+_+m|0;this._b=this._c+r+O|0,this._c=this._d+u+I|0,this._d=this._e+s+L|0,this._e=this._a+h+v|0,this._a=x;},u$1.prototype._digest=function(){this._block[this._blockOffset++]=128,this._blockOffset>56&&(this._block.fill(0,this._blockOffset,64),this._update(),this._blockOffset=0),this._block.fill(0,this._blockOffset,56),this._block.writeUInt32LE(this._length[0],56),this._block.writeUInt32LE(this._length[1],60),this._update();var t=h$1.alloc?h$1.alloc(20):new h$1(20);return t.writeInt32LE(this._a,0),t.writeInt32LE(this._b,4),t.writeInt32LE(this._c,8),t.writeInt32LE(this._d,12),t.writeInt32LE(this._e,16),t};var I=u$1;var s$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,h$2=u$q.Buffer;function e$3(t,i){(this||s$1)._block=h$2.alloc(t),(this||s$1)._finalSize=i,(this||s$1)._blockSize=t,(this||s$1)._len=0;}e$3.prototype.update=function(t,i){"string"==typeof t&&(i=i||"utf8",t=h$2.from(t,i));for(var e=(this||s$1)._block,_=(this||s$1)._blockSize,n=t.length,r=(this||s$1)._len,o=0;o<n;){for(var f=r%_,l=Math.min(n-o,_-f),a=0;a<l;a++)e[f+a]=t[o+a];o+=l,(r+=l)%_==0&&this._update(e);}return (this||s$1)._len+=n,this||s$1},e$3.prototype.digest=function(t){var i=(this||s$1)._len%(this||s$1)._blockSize;(this||s$1)._block[i]=128,(this||s$1)._block.fill(0,i+1),i>=(this||s$1)._finalSize&&(this._update((this||s$1)._block),(this||s$1)._block.fill(0));var h=8*(this||s$1)._len;if(h<=4294967295)(this||s$1)._block.writeUInt32BE(h,(this||s$1)._blockSize-4);else {var e=(4294967295&h)>>>0,_=(h-e)/4294967296;(this||s$1)._block.writeUInt32BE(_,(this||s$1)._blockSize-8),(this||s$1)._block.writeUInt32BE(e,(this||s$1)._blockSize-4);}this._update((this||s$1)._block);var n=this._hash();return t?n.toString(t):n},e$3.prototype._update=function(){throw new Error("_update must be implemented by subclass")};var _$2=e$3,n$3="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,r$2=t$2$2,o$4=_$2,f$4=u$q.Buffer,l$2=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],a$3=new Array(64);function u$2(){this.init(),(this||n$3)._w=a$3,o$4.call(this||n$3,64,56);}function c$2(t,i,s){return s^t&(i^s)}function b$1(t,i,s){return t&i|s&(t|i)}function p$1(t){return (t>>>2|t<<30)^(t>>>13|t<<19)^(t>>>22|t<<10)}function d$1(t){return (t>>>6|t<<26)^(t>>>11|t<<21)^(t>>>25|t<<7)}function k$1(t){return (t>>>7|t<<25)^(t>>>18|t<<14)^t>>>3}r$2(u$2,o$4),u$2.prototype.init=function(){return (this||n$3)._a=1779033703,(this||n$3)._b=3144134277,(this||n$3)._c=1013904242,(this||n$3)._d=2773480762,(this||n$3)._e=1359893119,(this||n$3)._f=2600822924,(this||n$3)._g=528734635,(this||n$3)._h=1541459225,this||n$3},u$2.prototype._update=function(t){for(var i,s=(this||n$3)._w,h=0|(this||n$3)._a,e=0|(this||n$3)._b,_=0|(this||n$3)._c,r=0|(this||n$3)._d,o=0|(this||n$3)._e,f=0|(this||n$3)._f,a=0|(this||n$3)._g,u=0|(this||n$3)._h,w=0;w<16;++w)s[w]=t.readInt32BE(4*w);for(;w<64;++w)s[w]=0|(((i=s[w-2])>>>17|i<<15)^(i>>>19|i<<13)^i>>>10)+s[w-7]+k$1(s[w-15])+s[w-16];for(var g=0;g<64;++g){var B=u+d$1(o)+c$2(o,f,a)+l$2[g]+s[g]|0,v=p$1(h)+b$1(h,e,_)|0;u=a,a=f,f=o,o=r+B|0,r=_,_=e,e=h,h=B+v|0;}(this||n$3)._a=h+(this||n$3)._a|0,(this||n$3)._b=e+(this||n$3)._b|0,(this||n$3)._c=_+(this||n$3)._c|0,(this||n$3)._d=r+(this||n$3)._d|0,(this||n$3)._e=o+(this||n$3)._e|0,(this||n$3)._f=f+(this||n$3)._f|0,(this||n$3)._g=a+(this||n$3)._g|0,(this||n$3)._h=u+(this||n$3)._h|0;},u$2.prototype._hash=function(){var t=f$4.allocUnsafe(32);return t.writeInt32BE((this||n$3)._a,0),t.writeInt32BE((this||n$3)._b,4),t.writeInt32BE((this||n$3)._c,8),t.writeInt32BE((this||n$3)._d,12),t.writeInt32BE((this||n$3)._e,16),t.writeInt32BE((this||n$3)._f,20),t.writeInt32BE((this||n$3)._g,24),t.writeInt32BE((this||n$3)._h,28),t};var w$1=u$2;var _$3="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,e$4=t$2$2,n$4=_$2,r$3=u$q.Buffer,l$3=[1518500249,1859775393,-1894007588,-899497514],o$5=new Array(80);function f$5(){this.init(),(this||_$3)._w=o$5,n$4.call(this||_$3,64,56);}function a$4(t){return t<<30|t>>>2}function u$3(t,i,h,s){return 0===t?i&h|~i&s:2===t?i&h|i&s|h&s:i^h^s}e$4(f$5,n$4),f$5.prototype.init=function(){return (this||_$3)._a=1732584193,(this||_$3)._b=4023233417,(this||_$3)._c=2562383102,(this||_$3)._d=271733878,(this||_$3)._e=3285377520,this||_$3},f$5.prototype._update=function(t){for(var i,h=(this||_$3)._w,s=0|(this||_$3)._a,e=0|(this||_$3)._b,n=0|(this||_$3)._c,r=0|(this||_$3)._d,o=0|(this||_$3)._e,f=0;f<16;++f)h[f]=t.readInt32BE(4*f);for(;f<80;++f)h[f]=h[f-3]^h[f-8]^h[f-14]^h[f-16];for(var c=0;c<80;++c){var d=~~(c/20),p=0|((i=s)<<5|i>>>27)+u$3(d,e,n,r)+o+h[c]+l$3[d];o=r,r=n,n=a$4(e),e=s,s=p;}(this||_$3)._a=s+(this||_$3)._a|0,(this||_$3)._b=e+(this||_$3)._b|0,(this||_$3)._c=n+(this||_$3)._c|0,(this||_$3)._d=r+(this||_$3)._d|0,(this||_$3)._e=o+(this||_$3)._e|0;},f$5.prototype._hash=function(){var t=r$3.allocUnsafe(20);return t.writeInt32BE(0|(this||_$3)._a,0),t.writeInt32BE(0|(this||_$3)._b,4),t.writeInt32BE(0|(this||_$3)._c,8),t.writeInt32BE(0|(this||_$3)._d,12),t.writeInt32BE(0|(this||_$3)._e,16),t};var c$3=f$5,d$2="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,p$2=t$2$2,b$2=_$2,w$2=u$q.Buffer,g=[1518500249,1859775393,-1894007588,-899497514],B=new Array(80);function y(){this.init(),(this||d$2)._w=B,b$2.call(this||d$2,64,56);}function E$1(t){return t<<5|t>>>27}function I$1(t){return t<<30|t>>>2}function v(t,i,h,s){return 0===t?i&h|~i&s:2===t?i&h|i&s|h&s:i^h^s}p$2(y,b$2),y.prototype.init=function(){return (this||d$2)._a=1732584193,(this||d$2)._b=4023233417,(this||d$2)._c=2562383102,(this||d$2)._d=271733878,(this||d$2)._e=3285377520,this||d$2},y.prototype._update=function(t){for(var i,h=(this||d$2)._w,s=0|(this||d$2)._a,_=0|(this||d$2)._b,e=0|(this||d$2)._c,n=0|(this||d$2)._d,r=0|(this||d$2)._e,l=0;l<16;++l)h[l]=t.readInt32BE(4*l);for(;l<80;++l)h[l]=(i=h[l-3]^h[l-8]^h[l-14]^h[l-16])<<1|i>>>31;for(var o=0;o<80;++o){var f=~~(o/20),a=E$1(s)+v(f,_,e,n)+r+h[o]+g[f]|0;r=n,n=e,e=I$1(_),_=s,s=a;}(this||d$2)._a=s+(this||d$2)._a|0,(this||d$2)._b=_+(this||d$2)._b|0,(this||d$2)._c=e+(this||d$2)._c|0,(this||d$2)._d=n+(this||d$2)._d|0,(this||d$2)._e=r+(this||d$2)._e|0;},y.prototype._hash=function(){var t=w$2.allocUnsafe(20);return t.writeInt32BE(0|(this||d$2)._a,0),t.writeInt32BE(0|(this||d$2)._b,4),t.writeInt32BE(0|(this||d$2)._c,8),t.writeInt32BE(0|(this||d$2)._d,12),t.writeInt32BE(0|(this||d$2)._e,16),t};var T=y,m="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,A=t$2$2,U=w$1,x=_$2,j=u$q.Buffer,q=new Array(64);function C(){this.init(),(this||m)._w=q,x.call(this||m,64,56);}A(C,U),C.prototype.init=function(){return (this||m)._a=3238371032,(this||m)._b=914150663,(this||m)._c=812702999,(this||m)._d=4144912697,(this||m)._e=4290775857,(this||m)._f=1750603025,(this||m)._g=1694076839,(this||m)._h=3204075428,this||m},C.prototype._hash=function(){var t=j.allocUnsafe(28);return t.writeInt32BE((this||m)._a,0),t.writeInt32BE((this||m)._b,4),t.writeInt32BE((this||m)._c,8),t.writeInt32BE((this||m)._d,12),t.writeInt32BE((this||m)._e,16),t.writeInt32BE((this||m)._f,20),t.writeInt32BE((this||m)._g,24),t};var L=C,k$2="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,z=t$2$2,D=_$2,F=u$q.Buffer,G=[1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591],H=new Array(160);function J(){this.init(),(this||k$2)._w=H,D.call(this||k$2,128,112);}function K(t,i,h){return h^t&(i^h)}function M(t,i,h){return t&i|h&(t|i)}function N(t,i){return (t>>>28|i<<4)^(i>>>2|t<<30)^(i>>>7|t<<25)}function O(t,i){return (t>>>14|i<<18)^(t>>>18|i<<14)^(i>>>9|t<<23)}function P(t,i){return (t>>>1|i<<31)^(t>>>8|i<<24)^t>>>7}function Q(t,i){return (t>>>1|i<<31)^(t>>>8|i<<24)^(t>>>7|i<<25)}function R(t,i){return (t>>>19|i<<13)^(i>>>29|t<<3)^t>>>6}function S(t,i){return (t>>>19|i<<13)^(i>>>29|t<<3)^(t>>>6|i<<26)}function V(t,i){return t>>>0<i>>>0?1:0}z(J,D),J.prototype.init=function(){return (this||k$2)._ah=1779033703,(this||k$2)._bh=3144134277,(this||k$2)._ch=1013904242,(this||k$2)._dh=2773480762,(this||k$2)._eh=1359893119,(this||k$2)._fh=2600822924,(this||k$2)._gh=528734635,(this||k$2)._hh=1541459225,(this||k$2)._al=4089235720,(this||k$2)._bl=2227873595,(this||k$2)._cl=4271175723,(this||k$2)._dl=1595750129,(this||k$2)._el=2917565137,(this||k$2)._fl=725511199,(this||k$2)._gl=4215389547,(this||k$2)._hl=327033209,this||k$2},J.prototype._update=function(t){for(var i=(this||k$2)._w,h=0|(this||k$2)._ah,s=0|(this||k$2)._bh,_=0|(this||k$2)._ch,e=0|(this||k$2)._dh,n=0|(this||k$2)._eh,r=0|(this||k$2)._fh,l=0|(this||k$2)._gh,o=0|(this||k$2)._hh,f=0|(this||k$2)._al,a=0|(this||k$2)._bl,u=0|(this||k$2)._cl,c=0|(this||k$2)._dl,d=0|(this||k$2)._el,p=0|(this||k$2)._fl,b=0|(this||k$2)._gl,w=0|(this||k$2)._hl,g=0;g<32;g+=2)i[g]=t.readInt32BE(4*g),i[g+1]=t.readInt32BE(4*g+4);for(;g<160;g+=2){var B=i[g-30],y=i[g-30+1],E=P(B,y),I=Q(y,B),v=R(B=i[g-4],y=i[g-4+1]),T=S(y,B),m=i[g-14],A=i[g-14+1],U=i[g-32],x=i[g-32+1],j=I+A|0,q=E+m+V(j,I)|0;q=(q=q+v+V(j=j+T|0,T)|0)+U+V(j=j+x|0,x)|0,i[g]=q,i[g+1]=j;}for(var C=0;C<160;C+=2){q=i[C],j=i[C+1];var L=M(h,s,_),z=M(f,a,u),D=N(h,f),F=N(f,h),H=O(n,d),J=O(d,n),W=G[C],X=G[C+1],Y=K(n,r,l),Z=K(d,p,b),$=w+J|0,tt=o+H+V($,w)|0;tt=(tt=(tt=tt+Y+V($=$+Z|0,Z)|0)+W+V($=$+X|0,X)|0)+q+V($=$+j|0,j)|0;var it=F+z|0,ht=D+L+V(it,F)|0;o=l,w=b,l=r,b=p,r=n,p=d,n=e+tt+V(d=c+$|0,c)|0,e=_,c=u,_=s,u=a,s=h,a=f,h=tt+ht+V(f=$+it|0,$)|0;}(this||k$2)._al=(this||k$2)._al+f|0,(this||k$2)._bl=(this||k$2)._bl+a|0,(this||k$2)._cl=(this||k$2)._cl+u|0,(this||k$2)._dl=(this||k$2)._dl+c|0,(this||k$2)._el=(this||k$2)._el+d|0,(this||k$2)._fl=(this||k$2)._fl+p|0,(this||k$2)._gl=(this||k$2)._gl+b|0,(this||k$2)._hl=(this||k$2)._hl+w|0,(this||k$2)._ah=(this||k$2)._ah+h+V((this||k$2)._al,f)|0,(this||k$2)._bh=(this||k$2)._bh+s+V((this||k$2)._bl,a)|0,(this||k$2)._ch=(this||k$2)._ch+_+V((this||k$2)._cl,u)|0,(this||k$2)._dh=(this||k$2)._dh+e+V((this||k$2)._dl,c)|0,(this||k$2)._eh=(this||k$2)._eh+n+V((this||k$2)._el,d)|0,(this||k$2)._fh=(this||k$2)._fh+r+V((this||k$2)._fl,p)|0,(this||k$2)._gh=(this||k$2)._gh+l+V((this||k$2)._gl,b)|0,(this||k$2)._hh=(this||k$2)._hh+o+V((this||k$2)._hl,w)|0;},J.prototype._hash=function(){var t=F.allocUnsafe(64);function i(i,h,s){t.writeInt32BE(i,s),t.writeInt32BE(h,s+4);}return i((this||k$2)._ah,(this||k$2)._al,0),i((this||k$2)._bh,(this||k$2)._bl,8),i((this||k$2)._ch,(this||k$2)._cl,16),i((this||k$2)._dh,(this||k$2)._dl,24),i((this||k$2)._eh,(this||k$2)._el,32),i((this||k$2)._fh,(this||k$2)._fl,40),i((this||k$2)._gh,(this||k$2)._gl,48),i((this||k$2)._hh,(this||k$2)._hl,56),t};var W=J,X="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,Y=t$2$2,Z=W,$=_$2,tt=u$q.Buffer,it=new Array(160);function ht(){this.init(),(this||X)._w=it,$.call(this||X,128,112);}Y(ht,Z),ht.prototype.init=function(){return (this||X)._ah=3418070365,(this||X)._bh=1654270250,(this||X)._ch=2438529370,(this||X)._dh=355462360,(this||X)._eh=1731405415,(this||X)._fh=2394180231,(this||X)._gh=3675008525,(this||X)._hh=1203062813,(this||X)._al=3238371032,(this||X)._bl=914150663,(this||X)._cl=812702999,(this||X)._dl=4144912697,(this||X)._el=4290775857,(this||X)._fl=1750603025,(this||X)._gl=1694076839,(this||X)._hl=3204075428,this||X},ht.prototype._hash=function(){var t=tt.allocUnsafe(48);function i(i,h,s){t.writeInt32BE(i,s),t.writeInt32BE(h,s+4);}return i((this||X)._ah,(this||X)._al,0),i((this||X)._bh,(this||X)._bl,8),i((this||X)._ch,(this||X)._cl,16),i((this||X)._dh,(this||X)._dl,24),i((this||X)._eh,(this||X)._el,32),i((this||X)._fh,(this||X)._fl,40),t};var st,_t=ht,et={exports:st={}};(st=et.exports=function(t){t=t.toLowerCase();var i=st[t];if(!i)throw new Error(t+" is not supported (we accept pull requests)");return new i}).sha=c$3,st.sha1=T,st.sha224=L,st.sha256=w$1,st.sha384=_t,st.sha512=W;var nt=et.exports;var e$5="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,n$5=u$q.Buffer,s$2=b$i.Transform,h$3=e$1$2.StringDecoder;function a$5(t){s$2.call(this||e$5),(this||e$5).hashMode="string"==typeof t,(this||e$5).hashMode?(this||e$5)[t]=(this||e$5)._finalOrDigest:(this||e$5).final=(this||e$5)._finalOrDigest,(this||e$5)._final&&((this||e$5).__final=(this||e$5)._final,(this||e$5)._final=null),(this||e$5)._decoder=null,(this||e$5)._encoding=null;}t$2$2(a$5,s$2),a$5.prototype.update=function(t,i,r){"string"==typeof t&&(t=n$5.from(t,i));var o=this._update(t);return (this||e$5).hashMode?this||e$5:(r&&(o=this._toString(o,r)),o)},a$5.prototype.setAutoPadding=function(){},a$5.prototype.getAuthTag=function(){throw new Error("trying to get auth tag in unsupported state")},a$5.prototype.setAuthTag=function(){throw new Error("trying to set auth tag in unsupported state")},a$5.prototype.setAAD=function(){throw new Error("trying to set aad in unsupported state")},a$5.prototype._transform=function(t,i,r){var o;try{(this||e$5).hashMode?this._update(t):this.push(this._update(t));}catch(t){o=t;}finally{r(o);}},a$5.prototype._flush=function(t){var i;try{this.push(this.__final());}catch(t){i=t;}t(i);},a$5.prototype._finalOrDigest=function(t){var i=this.__final()||n$5.alloc(0);return t&&(i=this._toString(i,t,!0)),i},a$5.prototype._toString=function(t,i,r){if((this||e$5)._decoder||((this||e$5)._decoder=new h$3(i),(this||e$5)._encoding=i),(this||e$5)._encoding!==i)throw new Error("can't switch encodings");var o=(this||e$5)._decoder.write(t);return r&&(o+=(this||e$5)._decoder.end()),o};var f$6=a$5;var m$1=u,n$6=I,p$3=nt,s$3=f$6;function a$6(t){s$3.call(this,"digest"),this._hash=t;}t$2$2(a$6,s$3),a$6.prototype._update=function(t){this._hash.update(t);},a$6.prototype._final=function(){return this._hash.digest()};var h$4=function(t){return "md5"===(t=t.toLowerCase())?new m$1:"rmd160"===t||"ripemd160"===t?new n$6:new a$6(p$3(t))};var e$6=u,r$4=function(t){return (new e$6).update(t).digest()};var o$6=t$2$2,h$5=u$q.Buffer,n$7=f$6,p$4=h$5.alloc(128);function f$7(t,a){n$7.call(this,"digest"),"string"==typeof a&&(a=h$5.from(a)),this._alg=t,this._key=a,a.length>64?a=t(a):a.length<64&&(a=h$5.concat([a,p$4],64));for(var e=this._ipad=h$5.allocUnsafe(64),i=this._opad=h$5.allocUnsafe(64),r=0;r<64;r++)e[r]=54^a[r],i[r]=92^a[r];this._hash=[e];}o$6(f$7,n$7),f$7.prototype._update=function(t){this._hash.push(t);},f$7.prototype._final=function(){var t=this._alg(h$5.concat(this._hash));return this._alg(h$5.concat([this._opad,t]))};var l$4=t$2$2,d$3=f$7,c$4=f$6,_$4=u$q.Buffer,m$2=r$4,u$4=I,g$1=nt,v$1=_$4.alloc(128);function y$1(t,a){c$4.call(this,"digest"),"string"==typeof a&&(a=_$4.from(a));var e="sha512"===t||"sha384"===t?128:64;(this._alg=t,this._key=a,a.length>e)?a=("rmd160"===t?new u$4:g$1(t)).update(a).digest():a.length<e&&(a=_$4.concat([a,v$1],e));for(var i=this._ipad=_$4.allocUnsafe(e),r=this._opad=_$4.allocUnsafe(e),s=0;s<e;s++)i[s]=54^a[s],r[s]=92^a[s];this._hash="rmd160"===t?new u$4:g$1(t),this._hash.update(i);}l$4(y$1,c$4),y$1.prototype._update=function(t){this._hash.update(t);},y$1.prototype._final=function(){var t=this._hash.digest();return ("rmd160"===this._alg?new u$4:g$1(this._alg)).update(this._opad).update(t).digest()};var w$3=function(t,a){return "rmd160"===(t=t.toLowerCase())||"ripemd160"===t?new y$1("rmd160",a):"md5"===t?new d$3(m$2,a):new y$1(t,a)};var s$4={sha224WithRSAEncryption:{sign:"rsa",hash:"sha224",id:"302d300d06096086480165030402040500041c"},"RSA-SHA224":{sign:"ecdsa/rsa",hash:"sha224",id:"302d300d06096086480165030402040500041c"},sha256WithRSAEncryption:{sign:"rsa",hash:"sha256",id:"3031300d060960864801650304020105000420"},"RSA-SHA256":{sign:"ecdsa/rsa",hash:"sha256",id:"3031300d060960864801650304020105000420"},sha384WithRSAEncryption:{sign:"rsa",hash:"sha384",id:"3041300d060960864801650304020205000430"},"RSA-SHA384":{sign:"ecdsa/rsa",hash:"sha384",id:"3041300d060960864801650304020205000430"},sha512WithRSAEncryption:{sign:"rsa",hash:"sha512",id:"3051300d060960864801650304020305000440"},"RSA-SHA512":{sign:"ecdsa/rsa",hash:"sha512",id:"3051300d060960864801650304020305000440"},"RSA-SHA1":{sign:"rsa",hash:"sha1",id:"3021300906052b0e03021a05000414"},"ecdsa-with-SHA1":{sign:"ecdsa",hash:"sha1",id:""},sha256:{sign:"ecdsa",hash:"sha256",id:""},sha224:{sign:"ecdsa",hash:"sha224",id:""},sha384:{sign:"ecdsa",hash:"sha384",id:""},sha512:{sign:"ecdsa",hash:"sha512",id:""},"DSA-SHA":{sign:"dsa",hash:"sha1",id:""},"DSA-SHA1":{sign:"dsa",hash:"sha1",id:""},DSA:{sign:"dsa",hash:"sha1",id:""},"DSA-WITH-SHA224":{sign:"dsa",hash:"sha224",id:""},"DSA-SHA224":{sign:"dsa",hash:"sha224",id:""},"DSA-WITH-SHA256":{sign:"dsa",hash:"sha256",id:""},"DSA-SHA256":{sign:"dsa",hash:"sha256",id:""},"DSA-WITH-SHA384":{sign:"dsa",hash:"sha384",id:""},"DSA-SHA384":{sign:"dsa",hash:"sha384",id:""},"DSA-WITH-SHA512":{sign:"dsa",hash:"sha512",id:""},"DSA-SHA512":{sign:"dsa",hash:"sha512",id:""},"DSA-RIPEMD160":{sign:"dsa",hash:"rmd160",id:""},ripemd160WithRSA:{sign:"rsa",hash:"rmd160",id:"3021300906052b2403020105000414"},"RSA-RIPEMD160":{sign:"rsa",hash:"rmd160",id:"3021300906052b2403020105000414"},md5WithRSAEncryption:{sign:"rsa",hash:"md5",id:"3020300c06082a864886f70d020505000410"},"RSA-MD5":{sign:"rsa",hash:"md5",id:"3020300c06082a864886f70d020505000410"}};var f$8=e$1$1$1.Buffer,a$7=Math.pow(2,30)-1;function s$5(r,e){if("string"!=typeof r&&!f$8.isBuffer(r))throw new TypeError(e+" must be a buffer or string")}var u$5,h$6=function(r,e,t,n){if(s$5(r,"Password"),s$5(e,"Salt"),"number"!=typeof t)throw new TypeError("Iterations not a number");if(t<0)throw new TypeError("Bad iterations");if("number"!=typeof n)throw new TypeError("Key length not a number");if(n<0||n>a$7||n!=n)throw new TypeError("Bad key length")},c$5=T$9;c$5.browser?u$5="utf-8":u$5=parseInt(c$5.version.split(".")[0].slice(1),10)>=6?"utf-8":"binary";var l$5=u$5,p$5="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,d$4=r$4,m$3=I,y$2=nt,b$3=h$6,v$2=l$5,w$4=u$q.Buffer,g$2=w$4.alloc(128),B$1={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,rmd160:20,ripemd160:20};function T$1(r,e,t){var n=function(r){function e(e){return y$2(r).update(e).digest()}return "rmd160"===r||"ripemd160"===r?function(r){return (new m$3).update(r).digest()}:"md5"===r?d$4:e}(r),o="sha512"===r||"sha384"===r?128:64;e.length>o?e=n(e):e.length<o&&(e=w$4.concat([e,g$2],o));for(var i=w$4.allocUnsafe(o+B$1[r]),f=w$4.allocUnsafe(o+B$1[r]),a=0;a<o;a++)i[a]=54^e[a],f[a]=92^e[a];var s=w$4.allocUnsafe(o+t+4);i.copy(s,0,0,o),(this||p$5).ipad1=s,(this||p$5).ipad2=i,(this||p$5).opad=f,(this||p$5).alg=r,(this||p$5).blocksize=o,(this||p$5).hash=n,(this||p$5).size=B$1[r];}T$1.prototype.run=function(r,e){return r.copy(e,(this||p$5).blocksize),this.hash(e).copy((this||p$5).opad,(this||p$5).blocksize),this.hash((this||p$5).opad)};var k$3,S$1=function(r,e,t,n,o){b$3(r,e,t,n),w$4.isBuffer(r)||(r=w$4.from(r,v$2)),w$4.isBuffer(e)||(e=w$4.from(e,v$2));var i=new T$1(o=o||"sha1",r,e.length),f=w$4.allocUnsafe(n),a=w$4.allocUnsafe(e.length+4);e.copy(a,0,0,e.length);for(var s=0,u=B$1[o],h=Math.ceil(n/u),c=1;c<=h;c++){a.writeUInt32BE(c,e.length);for(var l=i.run(a,i.ipad1),p=l,d=1;d<t;d++){p=i.run(p,i.ipad2);for(var m=0;m<u;m++)l[m]^=p[m];}l.copy(f,s),s+=u;}return f},A$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,H$1=T$9,E$2=h$6,P$1=l$5,U$1=S$1,K$1=u$q.Buffer,x$1=A$1.crypto&&A$1.crypto.subtle,z$1={sha:"SHA-1","sha-1":"SHA-1",sha1:"SHA-1",sha256:"SHA-256","sha-256":"SHA-256",sha384:"SHA-384","sha-384":"SHA-384","sha-512":"SHA-512",sha512:"SHA-512"},I$2=[];function D$1(r,e,t,n,o){return x$1.importKey("raw",r,{name:"PBKDF2"},!1,["deriveBits"]).then((function(r){return x$1.deriveBits({name:"PBKDF2",salt:e,iterations:t,hash:{name:o}},r,n<<3)})).then((function(r){return K$1.from(r)}))}var F$1=function(r,e,t,n,o,i){"function"==typeof o&&(i=o,o=void 0);var f=z$1[(o=o||"sha1").toLowerCase()];if(!f||"function"!=typeof A$1.Promise)return H$1.nextTick((function(){var f;try{f=U$1(r,e,t,n,o);}catch(r){return i(r)}i(null,f);}));if(E$2(r,e,t,n),"function"!=typeof i)throw new Error("No callback provided to pbkdf2");K$1.isBuffer(r)||(r=K$1.from(r,P$1)),K$1.isBuffer(e)||(e=K$1.from(e,P$1)),function(r,e){r.then((function(r){H$1.nextTick((function(){e(null,r);}));}),(function(r){H$1.nextTick((function(){e(r);}));}));}(function(r){if(A$1.process&&!A$1.process.browser)return Promise.resolve(!1);if(!x$1||!x$1.importKey||!x$1.deriveBits)return Promise.resolve(!1);if(void 0!==I$2[r])return I$2[r];var e=D$1(k$3=k$3||K$1.alloc(8),k$3,10,128,r).then((function(){return !0})).catch((function(){return !1}));return I$2[r]=e,e}(f).then((function(i){return i?D$1(r,e,t,n,f):U$1(r,e,t,n,o)})),i);},M$1={};M$1.pbkdf2=F$1,M$1.pbkdf2Sync=S$1;var r$5;function e$7(r,e){if(!r)throw new Error(e||"Assertion failed")}r$5=e$7,e$7.equal=function(r,e,o){if(r!=e)throw new Error(o||"Assertion failed: "+r+" != "+e)};var o$7=r$5;var r$6={readUInt32BE:function(t,e){return (t[0+e]<<24|t[1+e]<<16|t[2+e]<<8|t[3+e])>>>0},writeUInt32BE:function(t,e,r){t[0+r]=e>>>24,t[1+r]=e>>>16&255,t[2+r]=e>>>8&255,t[3+r]=255&e;},ip:function(t,e,r,i){for(var n=0,f=0,o=6;o>=0;o-=2){for(var p=0;p<=24;p+=8)n<<=1,n|=e>>>p+o&1;for(p=0;p<=24;p+=8)n<<=1,n|=t>>>p+o&1;}for(o=6;o>=0;o-=2){for(p=1;p<=25;p+=8)f<<=1,f|=e>>>p+o&1;for(p=1;p<=25;p+=8)f<<=1,f|=t>>>p+o&1;}r[i+0]=n>>>0,r[i+1]=f>>>0;},rip:function(t,e,r,i){for(var n=0,f=0,o=0;o<4;o++)for(var p=24;p>=0;p-=8)n<<=1,n|=e>>>p+o&1,n<<=1,n|=t>>>p+o&1;for(o=4;o<8;o++)for(p=24;p>=0;p-=8)f<<=1,f|=e>>>p+o&1,f<<=1,f|=t>>>p+o&1;r[i+0]=n>>>0,r[i+1]=f>>>0;},pc1:function(t,e,r,i){for(var n=0,f=0,o=7;o>=5;o--){for(var p=0;p<=24;p+=8)n<<=1,n|=e>>p+o&1;for(p=0;p<=24;p+=8)n<<=1,n|=t>>p+o&1;}for(p=0;p<=24;p+=8)n<<=1,n|=e>>p+o&1;for(o=1;o<=3;o++){for(p=0;p<=24;p+=8)f<<=1,f|=e>>p+o&1;for(p=0;p<=24;p+=8)f<<=1,f|=t>>p+o&1;}for(p=0;p<=24;p+=8)f<<=1,f|=t>>p+o&1;r[i+0]=n>>>0,r[i+1]=f>>>0;},r28shl:function(t,e){return t<<e&268435455|t>>>28-e}},i=[14,11,17,4,27,23,25,0,13,22,7,18,5,9,16,24,2,20,12,21,1,8,15,26,15,4,25,19,9,1,26,16,5,11,23,8,12,7,17,0,22,3,10,14,6,20,27,24];r$6.pc2=function(t,e,r,n){for(var f=0,o=0,p=i.length>>>1,u=0;u<p;u++)f<<=1,f|=t>>>i[u]&1;for(u=p;u<i.length;u++)o<<=1,o|=e>>>i[u]&1;r[n+0]=f>>>0,r[n+1]=o>>>0;},r$6.expand=function(t,e,r){var i=0,n=0;i=(1&t)<<5|t>>>27;for(var f=23;f>=15;f-=4)i<<=6,i|=t>>>f&63;for(f=11;f>=3;f-=4)n|=t>>>f&63,n<<=6;n|=(31&t)<<1|t>>>31,e[r+0]=i>>>0,e[r+1]=n>>>0;};var n$8=[14,0,4,15,13,7,1,4,2,14,15,2,11,13,8,1,3,10,10,6,6,12,12,11,5,9,9,5,0,3,7,8,4,15,1,12,14,8,8,2,13,4,6,9,2,1,11,7,15,5,12,11,9,3,7,14,3,10,10,0,5,6,0,13,15,3,1,13,8,4,14,7,6,15,11,2,3,8,4,14,9,12,7,0,2,1,13,10,12,6,0,9,5,11,10,5,0,13,14,8,7,10,11,1,10,3,4,15,13,4,1,2,5,11,8,6,12,7,6,12,9,0,3,5,2,14,15,9,10,13,0,7,9,0,14,9,6,3,3,4,15,6,5,10,1,2,13,8,12,5,7,14,11,12,4,11,2,15,8,1,13,1,6,10,4,13,9,0,8,6,15,9,3,8,0,7,11,4,1,15,2,14,12,3,5,11,10,5,14,2,7,12,7,13,13,8,14,11,3,5,0,6,6,15,9,0,10,3,1,4,2,7,8,2,5,12,11,1,12,10,4,14,15,9,10,3,6,15,9,0,0,6,12,10,11,1,7,13,13,8,15,9,1,4,3,5,14,11,5,12,2,7,8,2,4,14,2,14,12,11,4,2,1,12,7,4,10,7,11,13,6,1,8,5,5,0,3,15,15,10,13,3,0,9,14,8,9,6,4,11,2,8,1,12,11,7,10,1,13,14,7,2,8,13,15,6,9,15,12,0,5,9,6,10,3,4,0,5,14,3,12,10,1,15,10,4,15,2,9,7,2,12,6,9,8,5,0,6,13,1,3,13,4,14,14,0,7,11,5,3,11,8,9,4,14,3,15,2,5,12,2,9,8,5,12,15,3,10,7,11,0,14,4,1,10,7,1,6,13,0,11,8,6,13,4,13,11,0,2,11,14,7,15,4,0,9,8,1,13,10,3,14,12,3,9,5,7,12,5,2,10,15,6,8,1,6,1,6,4,11,11,13,13,8,12,1,3,4,7,10,14,7,10,9,15,5,6,0,8,15,0,14,5,2,9,3,2,12,13,1,2,15,8,13,4,8,6,10,15,3,11,7,1,4,10,12,9,5,3,6,14,11,5,0,0,14,12,9,7,2,7,2,11,1,4,14,1,7,9,4,12,10,14,8,2,13,0,15,6,12,10,9,13,0,15,3,3,5,5,6,8,11];r$6.substitute=function(t,e){for(var r=0,i=0;i<4;i++){r<<=4,r|=n$8[64*i+(t>>>18-6*i&63)];}for(i=0;i<4;i++){r<<=4,r|=n$8[256+64*i+(e>>>18-6*i&63)];}return r>>>0};var f$9=[16,25,12,11,3,20,4,15,31,17,9,6,27,14,1,22,30,24,8,18,0,5,29,23,13,19,2,26,10,21,28,7];r$6.permute=function(t){for(var e=0,r=0;r<f$9.length;r++)e<<=1,e|=t>>>f$9[r]&1;return e>>>0},r$6.padSplit=function(t,e,r){for(var i=t.toString(2);i.length<e;)i="0"+i;for(var n=[],f=0;f<e;f+=r)n.push(i.slice(f,f+r));return n.join(" ")};var o$8,p$6=o$7;function u$6(t){this.options=t,this.type=this.options.type,this.blockSize=8,this._init(),this.buffer=new Array(this.blockSize),this.bufferOff=0;}o$8=u$6,u$6.prototype._init=function(){},u$6.prototype.update=function(t){return 0===t.length?[]:"decrypt"===this.type?this._updateDecrypt(t):this._updateEncrypt(t)},u$6.prototype._buffer=function(t,e){for(var r=Math.min(this.buffer.length-this.bufferOff,t.length-e),i=0;i<r;i++)this.buffer[this.bufferOff+i]=t[e+i];return this.bufferOff+=r,r},u$6.prototype._flushBuffer=function(t,e){return this._update(this.buffer,0,t,e),this.bufferOff=0,this.blockSize},u$6.prototype._updateEncrypt=function(t){var e=0,r=0,i=(this.bufferOff+t.length)/this.blockSize|0,n=new Array(i*this.blockSize);0!==this.bufferOff&&(e+=this._buffer(t,e),this.bufferOff===this.buffer.length&&(r+=this._flushBuffer(n,r)));for(var f=t.length-(t.length-e)%this.blockSize;e<f;e+=this.blockSize)this._update(t,e,n,r),r+=this.blockSize;for(;e<t.length;e++,this.bufferOff++)this.buffer[this.bufferOff]=t[e];return n},u$6.prototype._updateDecrypt=function(t){for(var e=0,r=0,i=Math.ceil((this.bufferOff+t.length)/this.blockSize)-1,n=new Array(i*this.blockSize);i>0;i--)e+=this._buffer(t,e),r+=this._flushBuffer(n,r);return e+=this._buffer(t,e),n},u$6.prototype.final=function(t){var e,r;return t&&(e=this.update(t)),r="encrypt"===this.type?this._finalEncrypt():this._finalDecrypt(),e?e.concat(r):r},u$6.prototype._pad=function(t,e){if(0===e)return !1;for(;e<t.length;)t[e++]=0;return !0},u$6.prototype._finalEncrypt=function(){if(!this._pad(this.buffer,this.bufferOff))return [];var t=new Array(this.blockSize);return this._update(this.buffer,0,t,0),t},u$6.prototype._unpad=function(t){return t},u$6.prototype._finalDecrypt=function(){p$6.equal(this.bufferOff,this.blockSize,"Not enough data to decrypt");var t=new Array(this.blockSize);return this._flushBuffer(t,0),this._unpad(t)};var s$6,a$8=o$8,h$7=o$7,c$6=r$6,l$6=a$8;function y$3(){this.tmp=new Array(2),this.keys=null;}function v$3(t){l$6.call(this,t);var e=new y$3;this._desState=e,this.deriveKeys(e,t.key);}t$2$2(v$3,l$6),s$6=v$3,v$3.create=function(t){return new v$3(t)};var d$5=[1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1];v$3.prototype.deriveKeys=function(t,e){t.keys=new Array(32),h$7.equal(e.length,this.blockSize,"Invalid key length");var r=c$6.readUInt32BE(e,0),i=c$6.readUInt32BE(e,4);c$6.pc1(r,i,t.tmp,0),r=t.tmp[0],i=t.tmp[1];for(var n=0;n<t.keys.length;n+=2){var f=d$5[n>>>1];r=c$6.r28shl(r,f),i=c$6.r28shl(i,f),c$6.pc2(r,i,t.keys,n);}},v$3.prototype._update=function(t,e,r,i){var n=this._desState,f=c$6.readUInt32BE(t,e),o=c$6.readUInt32BE(t,e+4);c$6.ip(f,o,n.tmp,0),f=n.tmp[0],o=n.tmp[1],"encrypt"===this.type?this._encrypt(n,f,o,n.tmp,0):this._decrypt(n,f,o,n.tmp,0),f=n.tmp[0],o=n.tmp[1],c$6.writeUInt32BE(r,f,i),c$6.writeUInt32BE(r,o,i+4);},v$3.prototype._pad=function(t,e){for(var r=t.length-e,i=e;i<t.length;i++)t[i]=r;return !0},v$3.prototype._unpad=function(t){for(var e=t[t.length-1],r=t.length-e;r<t.length;r++)h$7.equal(t[r],e);return t.slice(0,t.length-e)},v$3.prototype._encrypt=function(t,e,r,i,n){for(var f=e,o=r,p=0;p<t.keys.length;p+=2){var u=t.keys[p],s=t.keys[p+1];c$6.expand(o,t.tmp,0),u^=t.tmp[0],s^=t.tmp[1];var a=c$6.substitute(u,s),h=o;o=(f^c$6.permute(a))>>>0,f=h;}c$6.rip(o,f,i,n);},v$3.prototype._decrypt=function(t,e,r,i,n){for(var f=r,o=e,p=t.keys.length-2;p>=0;p-=2){var u=t.keys[p],s=t.keys[p+1];c$6.expand(f,t.tmp,0),u^=t.tmp[0],s^=t.tmp[1];var a=c$6.substitute(u,s),h=f;f=(o^c$6.permute(a))>>>0,o=h;}c$6.rip(f,o,i,n);};var _$5=s$6,b$4={},k$4=o$7,g$3=t$2$2,m$4={};function S$2(t){k$4.equal(t.length,8,"Invalid IV length"),this.iv=new Array(8);for(var e=0;e<this.iv.length;e++)this.iv[e]=t[e];}b$4.instantiate=function(t){function e(e){t.call(this,e),this._cbcInit();}g$3(e,t);for(var r=Object.keys(m$4),i=0;i<r.length;i++){var n=r[i];e.prototype[n]=m$4[n];}return e.create=function(t){return new e(t)},e},m$4._cbcInit=function(){var t=new S$2(this.options.iv);this._cbcState=t;},m$4._update=function(t,e,r,i){var n=this._cbcState,f=this.constructor.super_.prototype,o=n.iv;if("encrypt"===this.type){for(var p=0;p<this.blockSize;p++)o[p]^=t[e+p];f._update.call(this,o,0,r,i);for(p=0;p<this.blockSize;p++)o[p]=r[i+p];}else {f._update.call(this,t,e,r,i);for(p=0;p<this.blockSize;p++)r[i+p]^=o[p];for(p=0;p<this.blockSize;p++)o[p]=t[e+p];}};var z$2,w$5=o$7,E$3=a$8,I$3=_$5;function O$1(t,e){w$5.equal(e.length,24,"Invalid key length");var r=e.slice(0,8),i=e.slice(8,16),n=e.slice(16,24);this.ciphers="encrypt"===t?[I$3.create({type:"encrypt",key:r}),I$3.create({type:"decrypt",key:i}),I$3.create({type:"encrypt",key:n})]:[I$3.create({type:"decrypt",key:n}),I$3.create({type:"encrypt",key:i}),I$3.create({type:"decrypt",key:r})];}function B$2(t){E$3.call(this,t);var e=new O$1(this.type,this.options.key);this._edeState=e;}t$2$2(B$2,E$3),z$2=B$2,B$2.create=function(t){return new B$2(t)},B$2.prototype._update=function(t,e,r,i){var n=this._edeState;n.ciphers[0]._update(t,e,r,i),n.ciphers[1]._update(r,i,r,i),n.ciphers[2]._update(r,i,r,i);},B$2.prototype._pad=I$3.prototype._pad,B$2.prototype._unpad=I$3.prototype._unpad;var A$2=z$2,U$2={};U$2.utils=r$6,U$2.Cipher=a$8,U$2.DES=_$5,U$2.CBC=b$4,U$2.EDE=A$2;var d$6,i$1="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,f$a=f$6,o$9=U$2,a$9=t$2$2,c$7=u$q.Buffer,n$9={"des-ede3-cbc":o$9.CBC.instantiate(o$9.EDE),"des-ede3":o$9.EDE,"des-ede-cbc":o$9.CBC.instantiate(o$9.EDE),"des-ede":o$9.EDE,"des-cbc":o$9.CBC.instantiate(o$9.DES),"des-ecb":o$9.DES};function p$7(e){f$a.call(this||i$1);var t,r=e.mode.toLowerCase(),s=n$9[r];t=e.decrypt?"decrypt":"encrypt";var d=e.key;c$7.isBuffer(d)||(d=c$7.from(d)),"des-ede"!==r&&"des-ede-cbc"!==r||(d=c$7.concat([d,d.slice(0,8)]));var o=e.iv;c$7.isBuffer(o)||(o=c$7.from(o)),(this||i$1)._des=s.create({key:d,iv:o,type:t});}n$9.des=n$9["des-cbc"],n$9.des3=n$9["des-ede3-cbc"],d$6=p$7,a$9(p$7,f$a),p$7.prototype._update=function(e){return c$7.from((this||i$1)._des.update(e))},p$7.prototype._final=function(){return c$7.from((this||i$1)._des.final())};var l$7=d$6;var e$8=e$1$1$1.Buffer,f$b=function(r,f){for(var t=Math.min(r.length,f.length),n=new e$8(t),o=0;o<t;++o)n[o]=r[o]^f[o];return n};var t$1=function(e){for(var c,r=e.length;r--;){if(255!==(c=e.readUInt8(r))){c++,e.writeUInt8(c,r);break}e.writeUInt8(0,r);}},a$a={encrypt:function(e,c){return e._cipher.encryptBlock(c)},decrypt:function(e,c){return e._cipher.decryptBlock(c)}},p$8={},n$a=f$b;p$8.encrypt=function(e,c){var r=n$a(c,e._prev);return e._prev=e._cipher.encryptBlock(r),e._prev},p$8.decrypt=function(e,c){var r=e._prev;e._prev=c;var t=e._cipher.decryptBlock(c);return n$a(t,r)};var i$2={},o$a=u$q.Buffer,h$8=f$b;function v$4(e,c,r){var t=c.length,a=h$8(c,e._cache);return e._cache=e._cache.slice(t),e._prev=o$a.concat([e._prev,r?c:a]),a}i$2.encrypt=function(e,c,r){for(var t,a=o$a.allocUnsafe(0);c.length;){if(0===e._cache.length&&(e._cache=e._cipher.encryptBlock(e._prev),e._prev=o$a.allocUnsafe(0)),!(e._cache.length<=c.length)){a=o$a.concat([a,v$4(e,c,r)]);break}t=e._cache.length,a=o$a.concat([a,v$4(e,c.slice(0,t),r)]),c=c.slice(t);}return a};var y$4={},f$c=u$q.Buffer;function s$7(e,c,r){var t=e._cipher.encryptBlock(e._prev)[0]^c;return e._prev=f$c.concat([e._prev.slice(1),f$c.from([r?c:t])]),t}y$4.encrypt=function(e,c,r){for(var t=c.length,a=f$c.allocUnsafe(t),p=-1;++p<t;)a[p]=s$7(e,c[p],r);return a};var l$8={},m$5=u$q.Buffer;function _$6(e,c,r){for(var t,a,p=-1,n=0;++p<8;)t=c&1<<7-p?128:0,n+=(128&(a=e._cipher.encryptBlock(e._prev)[0]^t))>>p%8,e._prev=k$5(e._prev,r?t:a);return n}function k$5(e,c){var r=e.length,t=-1,a=m$5.allocUnsafe(e.length);for(e=m$5.concat([e,m$5.from([c])]);++t<r;)a[t]=e[t]<<1|e[t+1]>>7;return a}l$8.encrypt=function(e,c,r){for(var t=c.length,a=m$5.allocUnsafe(t),p=-1;++p<t;)a[p]=_$6(e,c[p],r);return a};var B$3={},u$7=e$1$1$1.Buffer,C$1=f$b;function E$4(e){return e._prev=e._cipher.encryptBlock(e._prev),e._prev}B$3.encrypt=function(e,c){for(;e._cache.length<c.length;)e._cache=u$7.concat([e._cache,E$4(e)]);var r=e._cache.slice(0,c.length);return e._cache=e._cache.slice(c.length),C$1(c,r)};var d$7={},b$5=f$b,A$3=u$q.Buffer,S$3=t$1;function g$4(e){var c=e._cipher.encryptBlockRaw(e._prev);return S$3(e._prev),c}d$7.encrypt=function(e,c){var r=Math.ceil(c.length/16),t=e._cache.length;e._cache=A$3.concat([e._cache,A$3.allocUnsafe(16*r)]);for(var a=0;a<r;a++){var p=g$4(e),n=t+16*a;e._cache.writeUInt32BE(p[0],n+0),e._cache.writeUInt32BE(p[1],n+4),e._cache.writeUInt32BE(p[2],n+8),e._cache.writeUInt32BE(p[3],n+12);}var i=e._cache.slice(0,c.length);return e._cache=e._cache.slice(c.length),b$5(c,i)};var F$2={"aes-128-ecb":{cipher:"AES",key:128,iv:0,mode:"ECB",type:"block"},"aes-192-ecb":{cipher:"AES",key:192,iv:0,mode:"ECB",type:"block"},"aes-256-ecb":{cipher:"AES",key:256,iv:0,mode:"ECB",type:"block"},"aes-128-cbc":{cipher:"AES",key:128,iv:16,mode:"CBC",type:"block"},"aes-192-cbc":{cipher:"AES",key:192,iv:16,mode:"CBC",type:"block"},"aes-256-cbc":{cipher:"AES",key:256,iv:16,mode:"CBC",type:"block"},aes128:{cipher:"AES",key:128,iv:16,mode:"CBC",type:"block"},aes192:{cipher:"AES",key:192,iv:16,mode:"CBC",type:"block"},aes256:{cipher:"AES",key:256,iv:16,mode:"CBC",type:"block"},"aes-128-cfb":{cipher:"AES",key:128,iv:16,mode:"CFB",type:"stream"},"aes-192-cfb":{cipher:"AES",key:192,iv:16,mode:"CFB",type:"stream"},"aes-256-cfb":{cipher:"AES",key:256,iv:16,mode:"CFB",type:"stream"},"aes-128-cfb8":{cipher:"AES",key:128,iv:16,mode:"CFB8",type:"stream"},"aes-192-cfb8":{cipher:"AES",key:192,iv:16,mode:"CFB8",type:"stream"},"aes-256-cfb8":{cipher:"AES",key:256,iv:16,mode:"CFB8",type:"stream"},"aes-128-cfb1":{cipher:"AES",key:128,iv:16,mode:"CFB1",type:"stream"},"aes-192-cfb1":{cipher:"AES",key:192,iv:16,mode:"CFB1",type:"stream"},"aes-256-cfb1":{cipher:"AES",key:256,iv:16,mode:"CFB1",type:"stream"},"aes-128-ofb":{cipher:"AES",key:128,iv:16,mode:"OFB",type:"stream"},"aes-192-ofb":{cipher:"AES",key:192,iv:16,mode:"OFB",type:"stream"},"aes-256-ofb":{cipher:"AES",key:256,iv:16,mode:"OFB",type:"stream"},"aes-128-ctr":{cipher:"AES",key:128,iv:16,mode:"CTR",type:"stream"},"aes-192-ctr":{cipher:"AES",key:192,iv:16,mode:"CTR",type:"stream"},"aes-256-ctr":{cipher:"AES",key:256,iv:16,mode:"CTR",type:"stream"},"aes-128-gcm":{cipher:"AES",key:128,iv:12,mode:"GCM",type:"auth"},"aes-192-gcm":{cipher:"AES",key:192,iv:12,mode:"GCM",type:"auth"},"aes-256-gcm":{cipher:"AES",key:256,iv:12,mode:"GCM",type:"auth"}},U$3={ECB:a$a,CBC:p$8,CFB:i$2,CFB8:y$4,CFB1:l$8,OFB:B$3,CTR:d$7,GCM:d$7},w$6=F$2;for(var I$4 in w$6)w$6[I$4].module=U$3[w$6[I$4].mode];var M$2=w$6;var a$b="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,h$9={},o$b=u$q.Buffer;function s$8(t){o$b.isBuffer(t)||(t=o$b.from(t));for(var e=t.length/4|0,i=new Array(e),r=0;r<e;r++)i[r]=t.readUInt32BE(4*r);return i}function c$8(t){for(;0<t.length;t++)t[0]=0;}function l$9(t,e,i,r,n){for(var a,h,o,s,c=i[0],l=i[1],f=i[2],u=i[3],p=t[0]^e[0],_=t[1]^e[1],d=t[2]^e[2],y=t[3]^e[3],B=4,g=1;g<n;g++)a=c[p>>>24]^l[_>>>16&255]^f[d>>>8&255]^u[255&y]^e[B++],h=c[_>>>24]^l[d>>>16&255]^f[y>>>8&255]^u[255&p]^e[B++],o=c[d>>>24]^l[y>>>16&255]^f[p>>>8&255]^u[255&_]^e[B++],s=c[y>>>24]^l[p>>>16&255]^f[_>>>8&255]^u[255&d]^e[B++],p=a,_=h,d=o,y=s;return a=(r[p>>>24]<<24|r[_>>>16&255]<<16|r[d>>>8&255]<<8|r[255&y])^e[B++],h=(r[_>>>24]<<24|r[d>>>16&255]<<16|r[y>>>8&255]<<8|r[255&p])^e[B++],o=(r[d>>>24]<<24|r[y>>>16&255]<<16|r[p>>>8&255]<<8|r[255&_])^e[B++],s=(r[y>>>24]<<24|r[p>>>16&255]<<16|r[_>>>8&255]<<8|r[255&d])^e[B++],[a>>>=0,h>>>=0,o>>>=0,s>>>=0]}var f$d=[0,1,2,4,8,16,32,64,128,27,54],u$8=function(){for(var t=new Array(256),e=0;e<256;e++)t[e]=e<128?e<<1:e<<1^283;for(var i=[],r=[],n=[[],[],[],[]],a=[[],[],[],[]],h=0,o=0,s=0;s<256;++s){var c=o^o<<1^o<<2^o<<3^o<<4;c=c>>>8^255&c^99,i[h]=c,r[c]=h;var l=t[h],f=t[l],u=t[f],p=257*t[c]^16843008*c;n[0][h]=p<<24|p>>>8,n[1][h]=p<<16|p>>>16,n[2][h]=p<<8|p>>>24,n[3][h]=p,p=16843009*u^65537*f^257*l^16843008*h,a[0][c]=p<<24|p>>>8,a[1][c]=p<<16|p>>>16,a[2][c]=p<<8|p>>>24,a[3][c]=p,0===h?h=o=1:(h=l^t[t[t[u^l]]],o^=t[t[o]]);}return {SBOX:i,INV_SBOX:r,SUB_MIX:n,INV_SUB_MIX:a}}();function p$9(t){(this||a$b)._key=s$8(t),this._reset();}p$9.blockSize=16,p$9.keySize=32,p$9.prototype.blockSize=p$9.blockSize,p$9.prototype.keySize=p$9.keySize,p$9.prototype._reset=function(){for(var t=(this||a$b)._key,e=t.length,i=e+6,r=4*(i+1),n=[],h=0;h<e;h++)n[h]=t[h];for(h=e;h<r;h++){var o=n[h-1];h%e==0?(o=o<<8|o>>>24,o=u$8.SBOX[o>>>24]<<24|u$8.SBOX[o>>>16&255]<<16|u$8.SBOX[o>>>8&255]<<8|u$8.SBOX[255&o],o^=f$d[h/e|0]<<24):e>6&&h%e==4&&(o=u$8.SBOX[o>>>24]<<24|u$8.SBOX[o>>>16&255]<<16|u$8.SBOX[o>>>8&255]<<8|u$8.SBOX[255&o]),n[h]=n[h-e]^o;}for(var s=[],c=0;c<r;c++){var l=r-c,p=n[l-(c%4?0:4)];s[c]=c<4||l<=4?p:u$8.INV_SUB_MIX[0][u$8.SBOX[p>>>24]]^u$8.INV_SUB_MIX[1][u$8.SBOX[p>>>16&255]]^u$8.INV_SUB_MIX[2][u$8.SBOX[p>>>8&255]]^u$8.INV_SUB_MIX[3][u$8.SBOX[255&p]];}(this||a$b)._nRounds=i,(this||a$b)._keySchedule=n,(this||a$b)._invKeySchedule=s;},p$9.prototype.encryptBlockRaw=function(t){return l$9(t=s$8(t),(this||a$b)._keySchedule,u$8.SUB_MIX,u$8.SBOX,(this||a$b)._nRounds)},p$9.prototype.encryptBlock=function(t){var e=this.encryptBlockRaw(t),i=o$b.allocUnsafe(16);return i.writeUInt32BE(e[0],0),i.writeUInt32BE(e[1],4),i.writeUInt32BE(e[2],8),i.writeUInt32BE(e[3],12),i},p$9.prototype.decryptBlock=function(t){var e=(t=s$8(t))[1];t[1]=t[3],t[3]=e;var i=l$9(t,(this||a$b)._invKeySchedule,u$8.INV_SUB_MIX,u$8.INV_SBOX,(this||a$b)._nRounds),r=o$b.allocUnsafe(16);return r.writeUInt32BE(i[0],0),r.writeUInt32BE(i[3],4),r.writeUInt32BE(i[2],8),r.writeUInt32BE(i[1],12),r},p$9.prototype.scrub=function(){c$8((this||a$b)._keySchedule),c$8((this||a$b)._invKeySchedule),c$8((this||a$b)._key);},h$9.AES=p$9;var _$7="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,d$8=u$q.Buffer,y$5=d$8.alloc(16,0);function B$4(t){var e=d$8.allocUnsafe(16);return e.writeUInt32BE(t[0]>>>0,0),e.writeUInt32BE(t[1]>>>0,4),e.writeUInt32BE(t[2]>>>0,8),e.writeUInt32BE(t[3]>>>0,12),e}function g$5(t){(this||_$7).h=t,(this||_$7).state=d$8.alloc(16,0),(this||_$7).cache=d$8.allocUnsafe(0);}g$5.prototype.ghash=function(t){for(var e=-1;++e<t.length;)(this||_$7).state[e]^=t[e];this._multiply();},g$5.prototype._multiply=function(){for(var t,e,i,r=[(t=(this||_$7).h).readUInt32BE(0),t.readUInt32BE(4),t.readUInt32BE(8),t.readUInt32BE(12)],n=[0,0,0,0],a=-1;++a<128;){for(0!=((this||_$7).state[~~(a/8)]&1<<7-a%8)&&(n[0]^=r[0],n[1]^=r[1],n[2]^=r[2],n[3]^=r[3]),i=0!=(1&r[3]),e=3;e>0;e--)r[e]=r[e]>>>1|(1&r[e-1])<<31;r[0]=r[0]>>>1,i&&(r[0]=r[0]^225<<24);}(this||_$7).state=B$4(n);},g$5.prototype.update=function(t){var e;for((this||_$7).cache=d$8.concat([(this||_$7).cache,t]);(this||_$7).cache.length>=16;)e=(this||_$7).cache.slice(0,16),(this||_$7).cache=(this||_$7).cache.slice(16),this.ghash(e);},g$5.prototype.final=function(t,e){return (this||_$7).cache.length&&this.ghash(d$8.concat([(this||_$7).cache,y$5],16)),this.ghash(B$4([0,t,0,e])),(this||_$7).state};var S$4=g$5,v$5="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,I$5=h$9,U$4=u$q.Buffer,w$7=f$6,m$6=S$4,E$5=f$b,b$6=t$1;function X$1(t,e,i,r){w$7.call(this||v$5);var n=U$4.alloc(4,0);(this||v$5)._cipher=new I$5.AES(e);var a=(this||v$5)._cipher.encryptBlock(n);(this||v$5)._ghash=new m$6(a),i=function(t,e,i){if(12===e.length)return t._finID=U$4.concat([e,U$4.from([0,0,0,1])]),U$4.concat([e,U$4.from([0,0,0,2])]);var r=new m$6(i),n=e.length,a=n%16;r.update(e),a&&(a=16-a,r.update(U$4.alloc(a,0))),r.update(U$4.alloc(8,0));var h=8*n,o=U$4.alloc(8);o.writeUIntBE(h,0,8),r.update(o),t._finID=r.state;var s=U$4.from(t._finID);return b$6(s),s}(this||v$5,i,a),(this||v$5)._prev=U$4.from(i),(this||v$5)._cache=U$4.allocUnsafe(0),(this||v$5)._secCache=U$4.allocUnsafe(0),(this||v$5)._decrypt=r,(this||v$5)._alen=0,(this||v$5)._len=0,(this||v$5)._mode=t,(this||v$5)._authTag=null,(this||v$5)._called=!1;}t$2$2(X$1,w$7),X$1.prototype._update=function(t){if(!(this||v$5)._called&&(this||v$5)._alen){var e=16-(this||v$5)._alen%16;e<16&&(e=U$4.alloc(e,0),(this||v$5)._ghash.update(e));}(this||v$5)._called=!0;var i=(this||v$5)._mode.encrypt(this||v$5,t);return (this||v$5)._decrypt?(this||v$5)._ghash.update(t):(this||v$5)._ghash.update(i),(this||v$5)._len+=t.length,i},X$1.prototype._final=function(){if((this||v$5)._decrypt&&!(this||v$5)._authTag)throw new Error("Unsupported state or unable to authenticate data");var t=E$5((this||v$5)._ghash.final(8*(this||v$5)._alen,8*(this||v$5)._len),(this||v$5)._cipher.encryptBlock((this||v$5)._finID));if((this||v$5)._decrypt&&function(t,e){var i=0;t.length!==e.length&&i++;for(var r=Math.min(t.length,e.length),n=0;n<r;++n)i+=t[n]^e[n];return i}(t,(this||v$5)._authTag))throw new Error("Unsupported state or unable to authenticate data");(this||v$5)._authTag=t,(this||v$5)._cipher.scrub();},X$1.prototype.getAuthTag=function(){if((this||v$5)._decrypt||!U$4.isBuffer((this||v$5)._authTag))throw new Error("Attempting to get auth tag in unsupported state");return (this||v$5)._authTag},X$1.prototype.setAuthTag=function(t){if(!(this||v$5)._decrypt)throw new Error("Attempting to set auth tag in unsupported state");(this||v$5)._authTag=t;},X$1.prototype.setAAD=function(t){if((this||v$5)._called)throw new Error("Attempting to set AAD in unsupported state");(this||v$5)._ghash.update(t),(this||v$5)._alen+=t.length;};var k$6=X$1,T$2="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,O$2=h$9,A$4=u$q.Buffer,M$3=f$6;function N$1(t,e,i,r){M$3.call(this||T$2),(this||T$2)._cipher=new O$2.AES(e),(this||T$2)._prev=A$4.from(i),(this||T$2)._cache=A$4.allocUnsafe(0),(this||T$2)._secCache=A$4.allocUnsafe(0),(this||T$2)._decrypt=r,(this||T$2)._mode=t;}t$2$2(N$1,M$3),N$1.prototype._update=function(t){return (this||T$2)._mode.encrypt(this||T$2,t,(this||T$2)._decrypt)},N$1.prototype._final=function(){(this||T$2)._cipher.scrub();};var V$1=N$1;var t$2=u$q.Buffer,f$e=u;var a$c=function(r,e,a,l){if(t$2.isBuffer(r)||(r=t$2.from(r,"binary")),e&&(t$2.isBuffer(e)||(e=t$2.from(e,"binary")),8!==e.length))throw new RangeError("salt should be Buffer with 8 byte length");for(var n=a/8,o=t$2.alloc(n),i=t$2.alloc(l||0),h=t$2.alloc(0);n>0||l>0;){var u=new f$e;u.update(h),u.update(r),e&&u.update(e),h=u.digest();var g=0;if(n>0){var m=o.length-n;g=Math.min(n,h.length),h.copy(o,m,0,g),n-=g;}if(g<h.length&&l>0){var p=i.length-l,v=Math.min(l,h.length-g);h.copy(i,p,g,g+v),l-=v;}}return h.fill(0),{key:o,iv:i}};var c$9="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,s$9={},f$f=k$6,p$a=u$q.Buffer,u$9=M$2,l$a=V$1,d$9=f$6,y$6=h$9,m$7=a$c;function g$6(t,e,r){d$9.call(this||c$9),(this||c$9)._cache=new v$6,(this||c$9)._last=void 0,(this||c$9)._cipher=new y$6.AES(e),(this||c$9)._prev=p$a.from(r),(this||c$9)._mode=t,(this||c$9)._autopadding=!0;}function v$6(){(this||c$9).cache=p$a.allocUnsafe(0);}function w$8(t,e,r){var i=u$9[t.toLowerCase()];if(!i)throw new TypeError("invalid suite type");if("string"==typeof r&&(r=p$a.from(r)),"GCM"!==i.mode&&r.length!==i.iv)throw new TypeError("invalid iv length "+r.length);if("string"==typeof e&&(e=p$a.from(e)),e.length!==i.key/8)throw new TypeError("invalid key length "+e.length);return "stream"===i.type?new l$a(i.module,e,r,!0):"auth"===i.type?new f$f(i.module,e,r,!0):new g$6(i.module,e,r)}t$2$2(g$6,d$9),g$6.prototype._update=function(t){var e,r;(this||c$9)._cache.add(t);for(var i=[];e=(this||c$9)._cache.get((this||c$9)._autopadding);)r=(this||c$9)._mode.decrypt(this||c$9,e),i.push(r);return p$a.concat(i)},g$6.prototype._final=function(){var t=(this||c$9)._cache.flush();if((this||c$9)._autopadding)return function(t){var e=t[15];if(e<1||e>16)throw new Error("unable to decrypt data");var r=-1;for(;++r<e;)if(t[r+(16-e)]!==e)throw new Error("unable to decrypt data");if(16===e)return;return t.slice(0,16-e)}((this||c$9)._mode.decrypt(this||c$9,t));if(t)throw new Error("data not multiple of block length")},g$6.prototype.setAutoPadding=function(t){return (this||c$9)._autopadding=!!t,this||c$9},v$6.prototype.add=function(t){(this||c$9).cache=p$a.concat([(this||c$9).cache,t]);},v$6.prototype.get=function(t){var e;if(t){if((this||c$9).cache.length>16)return e=(this||c$9).cache.slice(0,16),(this||c$9).cache=(this||c$9).cache.slice(16),e}else if((this||c$9).cache.length>=16)return e=(this||c$9).cache.slice(0,16),(this||c$9).cache=(this||c$9).cache.slice(16),e;return null},v$6.prototype.flush=function(){if((this||c$9).cache.length)return (this||c$9).cache},s$9.createDecipher=function(t,e){var r=u$9[t.toLowerCase()];if(!r)throw new TypeError("invalid suite type");var i=m$7(e,!1,r.key,r.iv);return w$8(t,i.key,i.iv)},s$9.createDecipheriv=w$8;var c$a="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,s$a={},f$g=M$2,p$b=k$6,l$b=u$q.Buffer,u$a=V$1,d$a=f$6,m$8=h$9,y$7=a$c;function v$7(t,e,r){d$a.call(this||c$a),(this||c$a)._cache=new g$7,(this||c$a)._cipher=new m$8.AES(e),(this||c$a)._prev=l$b.from(r),(this||c$a)._mode=t,(this||c$a)._autopadding=!0;}t$2$2(v$7,d$a),v$7.prototype._update=function(t){var e,r;(this||c$a)._cache.add(t);for(var i=[];e=(this||c$a)._cache.get();)r=(this||c$a)._mode.encrypt(this||c$a,e),i.push(r);return l$b.concat(i)};var _$8=l$b.alloc(16,16);function g$7(){(this||c$a).cache=l$b.allocUnsafe(0);}function w$9(t,e,r){var i=f$g[t.toLowerCase()];if(!i)throw new TypeError("invalid suite type");if("string"==typeof e&&(e=l$b.from(e)),e.length!==i.key/8)throw new TypeError("invalid key length "+e.length);if("string"==typeof r&&(r=l$b.from(r)),"GCM"!==i.mode&&r.length!==i.iv)throw new TypeError("invalid iv length "+r.length);return "stream"===i.type?new u$a(i.module,e,r):"auth"===i.type?new p$b(i.module,e,r):new v$7(i.module,e,r)}v$7.prototype._final=function(){var t=(this||c$a)._cache.flush();if((this||c$a)._autopadding)return t=(this||c$a)._mode.encrypt(this||c$a,t),(this||c$a)._cipher.scrub(),t;if(!t.equals(_$8))throw (this||c$a)._cipher.scrub(),new Error("data not multiple of block length")},v$7.prototype.setAutoPadding=function(t){return (this||c$a)._autopadding=!!t,this||c$a},g$7.prototype.add=function(t){(this||c$a).cache=l$b.concat([(this||c$a).cache,t]);},g$7.prototype.get=function(){if((this||c$a).cache.length>15){var t=(this||c$a).cache.slice(0,16);return (this||c$a).cache=(this||c$a).cache.slice(16),t}return null},g$7.prototype.flush=function(){for(var t=16-(this||c$a).cache.length,e=l$b.allocUnsafe(t),r=-1;++r<t;)e.writeUInt8(t,r);return l$b.concat([(this||c$a).cache,e])},s$a.createCipheriv=w$9,s$a.createCipher=function(t,e){var r=f$g[t.toLowerCase()];if(!r)throw new TypeError("invalid suite type");var i=y$7(e,!1,r.key,r.iv);return w$9(t,i.key,i.iv)};var t$3={},p$c=s$a,c$b=s$9,o$c=F$2;t$3.createCipher=t$3.Cipher=p$c.createCipher,t$3.createCipheriv=t$3.Cipheriv=p$c.createCipheriv,t$3.createDecipher=t$3.Decipher=c$b.createDecipher,t$3.createDecipheriv=t$3.Decipheriv=c$b.createDecipheriv,t$3.listCiphers=t$3.getCiphers=function(){return Object.keys(o$c)};var e$9={"des-ecb":{key:8,iv:0}};e$9["des-cbc"]=e$9.des={key:8,iv:8},e$9["des-ede3-cbc"]=e$9.des3={key:24,iv:8},e$9["des-ede3"]={key:24,iv:0},e$9["des-ede-cbc"]={key:16,iv:8},e$9["des-ede"]={key:16,iv:0};var p$d={},n$b=l$7,s$b=t$3,v$8=M$2,y$8=e$9,a$d=a$c;function f$h(e,r,i){if(e=e.toLowerCase(),v$8[e])return s$b.createCipheriv(e,r,i);if(y$8[e])return new n$b({key:r,iv:i,mode:e});throw new TypeError("invalid suite type")}function c$c(e,r,i){if(e=e.toLowerCase(),v$8[e])return s$b.createDecipheriv(e,r,i);if(y$8[e])return new n$b({key:r,iv:i,mode:e,decrypt:!0});throw new TypeError("invalid suite type")}p$d.createCipher=p$d.Cipher=function(e,r){var i,t;if(e=e.toLowerCase(),v$8[e])i=v$8[e].key,t=v$8[e].iv;else {if(!y$8[e])throw new TypeError("invalid suite type");i=8*y$8[e].key,t=y$8[e].iv;}var o=a$d(r,!1,i,t);return f$h(e,o.key,o.iv)},p$d.createCipheriv=p$d.Cipheriv=f$h,p$d.createDecipher=p$d.Decipher=function(e,r){var i,t;if(e=e.toLowerCase(),v$8[e])i=v$8[e].key,t=v$8[e].iv;else {if(!y$8[e])throw new TypeError("invalid suite type");i=8*y$8[e].key,t=y$8[e].iv;}var o=a$d(r,!1,i,t);return c$c(e,o.key,o.iv)},p$d.createDecipheriv=p$d.Decipheriv=c$c,p$d.listCiphers=p$d.getCiphers=function(){return Object.keys(y$8).concat(s$b.getCiphers())};var t$4=Object.freeze({}),i$3="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,r$7={},h$a={exports:r$7};!function(r,h){function n(t,i){if(!t)throw new Error(i||"Assertion failed")}function e(t,i){t.super_=i;var r=function(){};r.prototype=i.prototype,t.prototype=new r,t.prototype.constructor=t;}function o(t,r,h){if(o.isBN(t))return t;(this||i$3).negative=0,(this||i$3).words=null,(this||i$3).length=0,(this||i$3).red=null,null!==t&&("le"!==r&&"be"!==r||(h=r,r=10),this._init(t||0,r||10,h||"be"));}var s;"object"==typeof r?r.exports=o:h.BN=o,o.BN=o,o.wordSize=26;try{s=t$4.Buffer;}catch(t){}function u(t,i,r){for(var h=0,n=Math.min(t.length,r),e=i;e<n;e++){var o=t.charCodeAt(e)-48;h<<=4,h|=o>=49&&o<=54?o-49+10:o>=17&&o<=22?o-17+10:15&o;}return h}function a(t,i,r,h){for(var n=0,e=Math.min(t.length,r),o=i;o<e;o++){var s=t.charCodeAt(o)-48;n*=h,n+=s>=49?s-49+10:s>=17?s-17+10:s;}return n}o.isBN=function(t){return t instanceof o||null!==t&&"object"==typeof t&&t.constructor.wordSize===o.wordSize&&Array.isArray(t.words)},o.max=function(t,i){return t.cmp(i)>0?t:i},o.min=function(t,i){return t.cmp(i)<0?t:i},o.prototype._init=function(t,r,h){if("number"==typeof t)return this._initNumber(t,r,h);if("object"==typeof t)return this._initArray(t,r,h);"hex"===r&&(r=16),n(r===(0|r)&&r>=2&&r<=36);var e=0;"-"===(t=t.toString().replace(/\s+/g,""))[0]&&e++,16===r?this._parseHex(t,e):this._parseBase(t,r,e),"-"===t[0]&&((this||i$3).negative=1),this.strip(),"le"===h&&this._initArray(this.toArray(),r,h);},o.prototype._initNumber=function(t,r,h){t<0&&((this||i$3).negative=1,t=-t),t<67108864?((this||i$3).words=[67108863&t],(this||i$3).length=1):t<4503599627370496?((this||i$3).words=[67108863&t,t/67108864&67108863],(this||i$3).length=2):(n(t<9007199254740992),(this||i$3).words=[67108863&t,t/67108864&67108863,1],(this||i$3).length=3),"le"===h&&this._initArray(this.toArray(),r,h);},o.prototype._initArray=function(t,r,h){if(n("number"==typeof t.length),t.length<=0)return (this||i$3).words=[0],(this||i$3).length=1,this||i$3;(this||i$3).length=Math.ceil(t.length/3),(this||i$3).words=new Array((this||i$3).length);for(var e=0;e<(this||i$3).length;e++)(this||i$3).words[e]=0;var o,s,u=0;if("be"===h)for(e=t.length-1,o=0;e>=0;e-=3)s=t[e]|t[e-1]<<8|t[e-2]<<16,(this||i$3).words[o]|=s<<u&67108863,(this||i$3).words[o+1]=s>>>26-u&67108863,(u+=24)>=26&&(u-=26,o++);else if("le"===h)for(e=0,o=0;e<t.length;e+=3)s=t[e]|t[e+1]<<8|t[e+2]<<16,(this||i$3).words[o]|=s<<u&67108863,(this||i$3).words[o+1]=s>>>26-u&67108863,(u+=24)>=26&&(u-=26,o++);return this.strip()},o.prototype._parseHex=function(t,r){(this||i$3).length=Math.ceil((t.length-r)/6),(this||i$3).words=new Array((this||i$3).length);for(var h=0;h<(this||i$3).length;h++)(this||i$3).words[h]=0;var n,e,o=0;for(h=t.length-6,n=0;h>=r;h-=6)e=u(t,h,h+6),(this||i$3).words[n]|=e<<o&67108863,(this||i$3).words[n+1]|=e>>>26-o&4194303,(o+=24)>=26&&(o-=26,n++);h+6!==r&&(e=u(t,r,h+6),(this||i$3).words[n]|=e<<o&67108863,(this||i$3).words[n+1]|=e>>>26-o&4194303),this.strip();},o.prototype._parseBase=function(t,r,h){(this||i$3).words=[0],(this||i$3).length=1;for(var n=0,e=1;e<=67108863;e*=r)n++;n--,e=e/r|0;for(var o=t.length-h,s=o%n,u=Math.min(o,o-s)+h,l=0,m=h;m<u;m+=n)l=a(t,m,m+n,r),this.imuln(e),(this||i$3).words[0]+l<67108864?(this||i$3).words[0]+=l:this._iaddn(l);if(0!==s){var f=1;for(l=a(t,m,t.length,r),m=0;m<s;m++)f*=r;this.imuln(f),(this||i$3).words[0]+l<67108864?(this||i$3).words[0]+=l:this._iaddn(l);}},o.prototype.copy=function(t){t.words=new Array((this||i$3).length);for(var r=0;r<(this||i$3).length;r++)t.words[r]=(this||i$3).words[r];t.length=(this||i$3).length,t.negative=(this||i$3).negative,t.red=(this||i$3).red;},o.prototype.clone=function(){var t=new o(null);return this.copy(t),t},o.prototype._expand=function(t){for(;(this||i$3).length<t;)(this||i$3).words[(this||i$3).length++]=0;return this||i$3},o.prototype.strip=function(){for(;(this||i$3).length>1&&0===(this||i$3).words[(this||i$3).length-1];)(this||i$3).length--;return this._normSign()},o.prototype._normSign=function(){return 1===(this||i$3).length&&0===(this||i$3).words[0]&&((this||i$3).negative=0),this||i$3},o.prototype.inspect=function(){return ((this||i$3).red?"<BN-R: ":"<BN: ")+this.toString(16)+">"};var l=["","0","00","000","0000","00000","000000","0000000","00000000","000000000","0000000000","00000000000","000000000000","0000000000000","00000000000000","000000000000000","0000000000000000","00000000000000000","000000000000000000","0000000000000000000","00000000000000000000","000000000000000000000","0000000000000000000000","00000000000000000000000","000000000000000000000000","0000000000000000000000000"],m=[0,0,25,16,12,11,10,9,8,8,7,7,7,7,6,6,6,6,6,6,6,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5],f=[0,0,33554432,43046721,16777216,48828125,60466176,40353607,16777216,43046721,1e7,19487171,35831808,62748517,7529536,11390625,16777216,24137569,34012224,47045881,64e6,4084101,5153632,6436343,7962624,9765625,11881376,14348907,17210368,20511149,243e5,28629151,33554432,39135393,45435424,52521875,60466176];function d(t,i,r){r.negative=i.negative^t.negative;var h=t.length+i.length|0;r.length=h,h=h-1|0;var n=0|t.words[0],e=0|i.words[0],o=n*e,s=67108863&o,u=o/67108864|0;r.words[0]=s;for(var a=1;a<h;a++){for(var l=u>>>26,m=67108863&u,f=Math.min(a,i.length-1),d=Math.max(0,a-t.length+1);d<=f;d++){var p=a-d|0;l+=(o=(n=0|t.words[p])*(e=0|i.words[d])+m)/67108864|0,m=67108863&o;}r.words[a]=0|m,u=0|l;}return 0!==u?r.words[a]=0|u:r.length--,r.strip()}o.prototype.toString=function(t,r){var h;if(r=0|r||1,16===(t=t||10)||"hex"===t){h="";for(var e=0,o=0,s=0;s<(this||i$3).length;s++){var u=(this||i$3).words[s],a=(16777215&(u<<e|o)).toString(16);h=0!==(o=u>>>24-e&16777215)||s!==(this||i$3).length-1?l[6-a.length]+a+h:a+h,(e+=2)>=26&&(e-=26,s--);}for(0!==o&&(h=o.toString(16)+h);h.length%r!=0;)h="0"+h;return 0!==(this||i$3).negative&&(h="-"+h),h}if(t===(0|t)&&t>=2&&t<=36){var d=m[t],p=f[t];h="";var M=this.clone();for(M.negative=0;!M.isZero();){var v=M.modn(p).toString(t);h=(M=M.idivn(p)).isZero()?v+h:l[d-v.length]+v+h;}for(this.isZero()&&(h="0"+h);h.length%r!=0;)h="0"+h;return 0!==(this||i$3).negative&&(h="-"+h),h}n(!1,"Base should be between 2 and 36");},o.prototype.toNumber=function(){var t=(this||i$3).words[0];return 2===(this||i$3).length?t+=67108864*(this||i$3).words[1]:3===(this||i$3).length&&1===(this||i$3).words[2]?t+=4503599627370496+67108864*(this||i$3).words[1]:(this||i$3).length>2&&n(!1,"Number can only safely store up to 53 bits"),0!==(this||i$3).negative?-t:t},o.prototype.toJSON=function(){return this.toString(16)},o.prototype.toBuffer=function(t,i){return n(void 0!==s),this.toArrayLike(s,t,i)},o.prototype.toArray=function(t,i){return this.toArrayLike(Array,t,i)},o.prototype.toArrayLike=function(t,i,r){var h=this.byteLength(),e=r||Math.max(1,h);n(h<=e,"byte array longer than desired length"),n(e>0,"Requested array length <= 0"),this.strip();var o,s,u="le"===i,a=new t(e),l=this.clone();if(u){for(s=0;!l.isZero();s++)o=l.andln(255),l.iushrn(8),a[s]=o;for(;s<e;s++)a[s]=0;}else {for(s=0;s<e-h;s++)a[s]=0;for(s=0;!l.isZero();s++)o=l.andln(255),l.iushrn(8),a[e-s-1]=o;}return a},Math.clz32?o.prototype._countBits=function(t){return 32-Math.clz32(t)}:o.prototype._countBits=function(t){var i=t,r=0;return i>=4096&&(r+=13,i>>>=13),i>=64&&(r+=7,i>>>=7),i>=8&&(r+=4,i>>>=4),i>=2&&(r+=2,i>>>=2),r+i},o.prototype._zeroBits=function(t){if(0===t)return 26;var i=t,r=0;return 0==(8191&i)&&(r+=13,i>>>=13),0==(127&i)&&(r+=7,i>>>=7),0==(15&i)&&(r+=4,i>>>=4),0==(3&i)&&(r+=2,i>>>=2),0==(1&i)&&r++,r},o.prototype.bitLength=function(){var t=(this||i$3).words[(this||i$3).length-1],r=this._countBits(t);return 26*((this||i$3).length-1)+r},o.prototype.zeroBits=function(){if(this.isZero())return 0;for(var t=0,r=0;r<(this||i$3).length;r++){var h=this._zeroBits((this||i$3).words[r]);if(t+=h,26!==h)break}return t},o.prototype.byteLength=function(){return Math.ceil(this.bitLength()/8)},o.prototype.toTwos=function(t){return 0!==(this||i$3).negative?this.abs().inotn(t).iaddn(1):this.clone()},o.prototype.fromTwos=function(t){return this.testn(t-1)?this.notn(t).iaddn(1).ineg():this.clone()},o.prototype.isNeg=function(){return 0!==(this||i$3).negative},o.prototype.neg=function(){return this.clone().ineg()},o.prototype.ineg=function(){return this.isZero()||((this||i$3).negative^=1),this||i$3},o.prototype.iuor=function(t){for(;(this||i$3).length<t.length;)(this||i$3).words[(this||i$3).length++]=0;for(var r=0;r<t.length;r++)(this||i$3).words[r]=(this||i$3).words[r]|t.words[r];return this.strip()},o.prototype.ior=function(t){return n(0==((this||i$3).negative|t.negative)),this.iuor(t)},o.prototype.or=function(t){return (this||i$3).length>t.length?this.clone().ior(t):t.clone().ior(this||i$3)},o.prototype.uor=function(t){return (this||i$3).length>t.length?this.clone().iuor(t):t.clone().iuor(this||i$3)},o.prototype.iuand=function(t){var r;r=(this||i$3).length>t.length?t:this||i$3;for(var h=0;h<r.length;h++)(this||i$3).words[h]=(this||i$3).words[h]&t.words[h];return (this||i$3).length=r.length,this.strip()},o.prototype.iand=function(t){return n(0==((this||i$3).negative|t.negative)),this.iuand(t)},o.prototype.and=function(t){return (this||i$3).length>t.length?this.clone().iand(t):t.clone().iand(this||i$3)},o.prototype.uand=function(t){return (this||i$3).length>t.length?this.clone().iuand(t):t.clone().iuand(this||i$3)},o.prototype.iuxor=function(t){var r,h;(this||i$3).length>t.length?(r=this||i$3,h=t):(r=t,h=this||i$3);for(var n=0;n<h.length;n++)(this||i$3).words[n]=r.words[n]^h.words[n];if((this||i$3)!==r)for(;n<r.length;n++)(this||i$3).words[n]=r.words[n];return (this||i$3).length=r.length,this.strip()},o.prototype.ixor=function(t){return n(0==((this||i$3).negative|t.negative)),this.iuxor(t)},o.prototype.xor=function(t){return (this||i$3).length>t.length?this.clone().ixor(t):t.clone().ixor(this||i$3)},o.prototype.uxor=function(t){return (this||i$3).length>t.length?this.clone().iuxor(t):t.clone().iuxor(this||i$3)},o.prototype.inotn=function(t){n("number"==typeof t&&t>=0);var r=0|Math.ceil(t/26),h=t%26;this._expand(r),h>0&&r--;for(var e=0;e<r;e++)(this||i$3).words[e]=67108863&~(this||i$3).words[e];return h>0&&((this||i$3).words[e]=~(this||i$3).words[e]&67108863>>26-h),this.strip()},o.prototype.notn=function(t){return this.clone().inotn(t)},o.prototype.setn=function(t,r){n("number"==typeof t&&t>=0);var h=t/26|0,e=t%26;return this._expand(h+1),(this||i$3).words[h]=r?(this||i$3).words[h]|1<<e:(this||i$3).words[h]&~(1<<e),this.strip()},o.prototype.iadd=function(t){var r,h,n;if(0!==(this||i$3).negative&&0===t.negative)return (this||i$3).negative=0,r=this.isub(t),(this||i$3).negative^=1,this._normSign();if(0===(this||i$3).negative&&0!==t.negative)return t.negative=0,r=this.isub(t),t.negative=1,r._normSign();(this||i$3).length>t.length?(h=this||i$3,n=t):(h=t,n=this||i$3);for(var e=0,o=0;o<n.length;o++)r=(0|h.words[o])+(0|n.words[o])+e,(this||i$3).words[o]=67108863&r,e=r>>>26;for(;0!==e&&o<h.length;o++)r=(0|h.words[o])+e,(this||i$3).words[o]=67108863&r,e=r>>>26;if((this||i$3).length=h.length,0!==e)(this||i$3).words[(this||i$3).length]=e,(this||i$3).length++;else if(h!==(this||i$3))for(;o<h.length;o++)(this||i$3).words[o]=h.words[o];return this||i$3},o.prototype.add=function(t){var r;return 0!==t.negative&&0===(this||i$3).negative?(t.negative=0,r=this.sub(t),t.negative^=1,r):0===t.negative&&0!==(this||i$3).negative?((this||i$3).negative=0,r=t.sub(this||i$3),(this||i$3).negative=1,r):(this||i$3).length>t.length?this.clone().iadd(t):t.clone().iadd(this||i$3)},o.prototype.isub=function(t){if(0!==t.negative){t.negative=0;var r=this.iadd(t);return t.negative=1,r._normSign()}if(0!==(this||i$3).negative)return (this||i$3).negative=0,this.iadd(t),(this||i$3).negative=1,this._normSign();var h,n,e=this.cmp(t);if(0===e)return (this||i$3).negative=0,(this||i$3).length=1,(this||i$3).words[0]=0,this||i$3;e>0?(h=this||i$3,n=t):(h=t,n=this||i$3);for(var o=0,s=0;s<n.length;s++)o=(r=(0|h.words[s])-(0|n.words[s])+o)>>26,(this||i$3).words[s]=67108863&r;for(;0!==o&&s<h.length;s++)o=(r=(0|h.words[s])+o)>>26,(this||i$3).words[s]=67108863&r;if(0===o&&s<h.length&&h!==(this||i$3))for(;s<h.length;s++)(this||i$3).words[s]=h.words[s];return (this||i$3).length=Math.max((this||i$3).length,s),h!==(this||i$3)&&((this||i$3).negative=1),this.strip()},o.prototype.sub=function(t){return this.clone().isub(t)};var p=function(t,i,r){var h,n,e,o=t.words,s=i.words,u=r.words,a=0,l=0|o[0],m=8191&l,f=l>>>13,d=0|o[1],p=8191&d,M=d>>>13,v=0|o[2],g=8191&v,c=v>>>13,w=0|o[3],y=8191&w,b=w>>>13,_=0|o[4],k=8191&_,A=_>>>13,x=0|o[5],S=8191&x,Z=x>>>13,R=0|o[6],q=8191&R,B=R>>>13,N=0|o[7],L=8191&N,I=N>>>13,T=0|o[8],z=8191&T,E=T>>>13,O=0|o[9],j=8191&O,K=O>>>13,P=0|s[0],F=8191&P,C=P>>>13,D=0|s[1],H=8191&D,J=D>>>13,U=0|s[2],G=8191&U,Q=U>>>13,V=0|s[3],W=8191&V,X=V>>>13,Y=0|s[4],$=8191&Y,tt=Y>>>13,it=0|s[5],rt=8191&it,ht=it>>>13,nt=0|s[6],et=8191&nt,ot=nt>>>13,st=0|s[7],ut=8191&st,at=st>>>13,lt=0|s[8],mt=8191&lt,ft=lt>>>13,dt=0|s[9],pt=8191&dt,Mt=dt>>>13;r.negative=t.negative^i.negative,r.length=19;var vt=(a+(h=Math.imul(m,F))|0)+((8191&(n=(n=Math.imul(m,C))+Math.imul(f,F)|0))<<13)|0;a=((e=Math.imul(f,C))+(n>>>13)|0)+(vt>>>26)|0,vt&=67108863,h=Math.imul(p,F),n=(n=Math.imul(p,C))+Math.imul(M,F)|0,e=Math.imul(M,C);var gt=(a+(h=h+Math.imul(m,H)|0)|0)+((8191&(n=(n=n+Math.imul(m,J)|0)+Math.imul(f,H)|0))<<13)|0;a=((e=e+Math.imul(f,J)|0)+(n>>>13)|0)+(gt>>>26)|0,gt&=67108863,h=Math.imul(g,F),n=(n=Math.imul(g,C))+Math.imul(c,F)|0,e=Math.imul(c,C),h=h+Math.imul(p,H)|0,n=(n=n+Math.imul(p,J)|0)+Math.imul(M,H)|0,e=e+Math.imul(M,J)|0;var ct=(a+(h=h+Math.imul(m,G)|0)|0)+((8191&(n=(n=n+Math.imul(m,Q)|0)+Math.imul(f,G)|0))<<13)|0;a=((e=e+Math.imul(f,Q)|0)+(n>>>13)|0)+(ct>>>26)|0,ct&=67108863,h=Math.imul(y,F),n=(n=Math.imul(y,C))+Math.imul(b,F)|0,e=Math.imul(b,C),h=h+Math.imul(g,H)|0,n=(n=n+Math.imul(g,J)|0)+Math.imul(c,H)|0,e=e+Math.imul(c,J)|0,h=h+Math.imul(p,G)|0,n=(n=n+Math.imul(p,Q)|0)+Math.imul(M,G)|0,e=e+Math.imul(M,Q)|0;var wt=(a+(h=h+Math.imul(m,W)|0)|0)+((8191&(n=(n=n+Math.imul(m,X)|0)+Math.imul(f,W)|0))<<13)|0;a=((e=e+Math.imul(f,X)|0)+(n>>>13)|0)+(wt>>>26)|0,wt&=67108863,h=Math.imul(k,F),n=(n=Math.imul(k,C))+Math.imul(A,F)|0,e=Math.imul(A,C),h=h+Math.imul(y,H)|0,n=(n=n+Math.imul(y,J)|0)+Math.imul(b,H)|0,e=e+Math.imul(b,J)|0,h=h+Math.imul(g,G)|0,n=(n=n+Math.imul(g,Q)|0)+Math.imul(c,G)|0,e=e+Math.imul(c,Q)|0,h=h+Math.imul(p,W)|0,n=(n=n+Math.imul(p,X)|0)+Math.imul(M,W)|0,e=e+Math.imul(M,X)|0;var yt=(a+(h=h+Math.imul(m,$)|0)|0)+((8191&(n=(n=n+Math.imul(m,tt)|0)+Math.imul(f,$)|0))<<13)|0;a=((e=e+Math.imul(f,tt)|0)+(n>>>13)|0)+(yt>>>26)|0,yt&=67108863,h=Math.imul(S,F),n=(n=Math.imul(S,C))+Math.imul(Z,F)|0,e=Math.imul(Z,C),h=h+Math.imul(k,H)|0,n=(n=n+Math.imul(k,J)|0)+Math.imul(A,H)|0,e=e+Math.imul(A,J)|0,h=h+Math.imul(y,G)|0,n=(n=n+Math.imul(y,Q)|0)+Math.imul(b,G)|0,e=e+Math.imul(b,Q)|0,h=h+Math.imul(g,W)|0,n=(n=n+Math.imul(g,X)|0)+Math.imul(c,W)|0,e=e+Math.imul(c,X)|0,h=h+Math.imul(p,$)|0,n=(n=n+Math.imul(p,tt)|0)+Math.imul(M,$)|0,e=e+Math.imul(M,tt)|0;var bt=(a+(h=h+Math.imul(m,rt)|0)|0)+((8191&(n=(n=n+Math.imul(m,ht)|0)+Math.imul(f,rt)|0))<<13)|0;a=((e=e+Math.imul(f,ht)|0)+(n>>>13)|0)+(bt>>>26)|0,bt&=67108863,h=Math.imul(q,F),n=(n=Math.imul(q,C))+Math.imul(B,F)|0,e=Math.imul(B,C),h=h+Math.imul(S,H)|0,n=(n=n+Math.imul(S,J)|0)+Math.imul(Z,H)|0,e=e+Math.imul(Z,J)|0,h=h+Math.imul(k,G)|0,n=(n=n+Math.imul(k,Q)|0)+Math.imul(A,G)|0,e=e+Math.imul(A,Q)|0,h=h+Math.imul(y,W)|0,n=(n=n+Math.imul(y,X)|0)+Math.imul(b,W)|0,e=e+Math.imul(b,X)|0,h=h+Math.imul(g,$)|0,n=(n=n+Math.imul(g,tt)|0)+Math.imul(c,$)|0,e=e+Math.imul(c,tt)|0,h=h+Math.imul(p,rt)|0,n=(n=n+Math.imul(p,ht)|0)+Math.imul(M,rt)|0,e=e+Math.imul(M,ht)|0;var _t=(a+(h=h+Math.imul(m,et)|0)|0)+((8191&(n=(n=n+Math.imul(m,ot)|0)+Math.imul(f,et)|0))<<13)|0;a=((e=e+Math.imul(f,ot)|0)+(n>>>13)|0)+(_t>>>26)|0,_t&=67108863,h=Math.imul(L,F),n=(n=Math.imul(L,C))+Math.imul(I,F)|0,e=Math.imul(I,C),h=h+Math.imul(q,H)|0,n=(n=n+Math.imul(q,J)|0)+Math.imul(B,H)|0,e=e+Math.imul(B,J)|0,h=h+Math.imul(S,G)|0,n=(n=n+Math.imul(S,Q)|0)+Math.imul(Z,G)|0,e=e+Math.imul(Z,Q)|0,h=h+Math.imul(k,W)|0,n=(n=n+Math.imul(k,X)|0)+Math.imul(A,W)|0,e=e+Math.imul(A,X)|0,h=h+Math.imul(y,$)|0,n=(n=n+Math.imul(y,tt)|0)+Math.imul(b,$)|0,e=e+Math.imul(b,tt)|0,h=h+Math.imul(g,rt)|0,n=(n=n+Math.imul(g,ht)|0)+Math.imul(c,rt)|0,e=e+Math.imul(c,ht)|0,h=h+Math.imul(p,et)|0,n=(n=n+Math.imul(p,ot)|0)+Math.imul(M,et)|0,e=e+Math.imul(M,ot)|0;var kt=(a+(h=h+Math.imul(m,ut)|0)|0)+((8191&(n=(n=n+Math.imul(m,at)|0)+Math.imul(f,ut)|0))<<13)|0;a=((e=e+Math.imul(f,at)|0)+(n>>>13)|0)+(kt>>>26)|0,kt&=67108863,h=Math.imul(z,F),n=(n=Math.imul(z,C))+Math.imul(E,F)|0,e=Math.imul(E,C),h=h+Math.imul(L,H)|0,n=(n=n+Math.imul(L,J)|0)+Math.imul(I,H)|0,e=e+Math.imul(I,J)|0,h=h+Math.imul(q,G)|0,n=(n=n+Math.imul(q,Q)|0)+Math.imul(B,G)|0,e=e+Math.imul(B,Q)|0,h=h+Math.imul(S,W)|0,n=(n=n+Math.imul(S,X)|0)+Math.imul(Z,W)|0,e=e+Math.imul(Z,X)|0,h=h+Math.imul(k,$)|0,n=(n=n+Math.imul(k,tt)|0)+Math.imul(A,$)|0,e=e+Math.imul(A,tt)|0,h=h+Math.imul(y,rt)|0,n=(n=n+Math.imul(y,ht)|0)+Math.imul(b,rt)|0,e=e+Math.imul(b,ht)|0,h=h+Math.imul(g,et)|0,n=(n=n+Math.imul(g,ot)|0)+Math.imul(c,et)|0,e=e+Math.imul(c,ot)|0,h=h+Math.imul(p,ut)|0,n=(n=n+Math.imul(p,at)|0)+Math.imul(M,ut)|0,e=e+Math.imul(M,at)|0;var At=(a+(h=h+Math.imul(m,mt)|0)|0)+((8191&(n=(n=n+Math.imul(m,ft)|0)+Math.imul(f,mt)|0))<<13)|0;a=((e=e+Math.imul(f,ft)|0)+(n>>>13)|0)+(At>>>26)|0,At&=67108863,h=Math.imul(j,F),n=(n=Math.imul(j,C))+Math.imul(K,F)|0,e=Math.imul(K,C),h=h+Math.imul(z,H)|0,n=(n=n+Math.imul(z,J)|0)+Math.imul(E,H)|0,e=e+Math.imul(E,J)|0,h=h+Math.imul(L,G)|0,n=(n=n+Math.imul(L,Q)|0)+Math.imul(I,G)|0,e=e+Math.imul(I,Q)|0,h=h+Math.imul(q,W)|0,n=(n=n+Math.imul(q,X)|0)+Math.imul(B,W)|0,e=e+Math.imul(B,X)|0,h=h+Math.imul(S,$)|0,n=(n=n+Math.imul(S,tt)|0)+Math.imul(Z,$)|0,e=e+Math.imul(Z,tt)|0,h=h+Math.imul(k,rt)|0,n=(n=n+Math.imul(k,ht)|0)+Math.imul(A,rt)|0,e=e+Math.imul(A,ht)|0,h=h+Math.imul(y,et)|0,n=(n=n+Math.imul(y,ot)|0)+Math.imul(b,et)|0,e=e+Math.imul(b,ot)|0,h=h+Math.imul(g,ut)|0,n=(n=n+Math.imul(g,at)|0)+Math.imul(c,ut)|0,e=e+Math.imul(c,at)|0,h=h+Math.imul(p,mt)|0,n=(n=n+Math.imul(p,ft)|0)+Math.imul(M,mt)|0,e=e+Math.imul(M,ft)|0;var xt=(a+(h=h+Math.imul(m,pt)|0)|0)+((8191&(n=(n=n+Math.imul(m,Mt)|0)+Math.imul(f,pt)|0))<<13)|0;a=((e=e+Math.imul(f,Mt)|0)+(n>>>13)|0)+(xt>>>26)|0,xt&=67108863,h=Math.imul(j,H),n=(n=Math.imul(j,J))+Math.imul(K,H)|0,e=Math.imul(K,J),h=h+Math.imul(z,G)|0,n=(n=n+Math.imul(z,Q)|0)+Math.imul(E,G)|0,e=e+Math.imul(E,Q)|0,h=h+Math.imul(L,W)|0,n=(n=n+Math.imul(L,X)|0)+Math.imul(I,W)|0,e=e+Math.imul(I,X)|0,h=h+Math.imul(q,$)|0,n=(n=n+Math.imul(q,tt)|0)+Math.imul(B,$)|0,e=e+Math.imul(B,tt)|0,h=h+Math.imul(S,rt)|0,n=(n=n+Math.imul(S,ht)|0)+Math.imul(Z,rt)|0,e=e+Math.imul(Z,ht)|0,h=h+Math.imul(k,et)|0,n=(n=n+Math.imul(k,ot)|0)+Math.imul(A,et)|0,e=e+Math.imul(A,ot)|0,h=h+Math.imul(y,ut)|0,n=(n=n+Math.imul(y,at)|0)+Math.imul(b,ut)|0,e=e+Math.imul(b,at)|0,h=h+Math.imul(g,mt)|0,n=(n=n+Math.imul(g,ft)|0)+Math.imul(c,mt)|0,e=e+Math.imul(c,ft)|0;var St=(a+(h=h+Math.imul(p,pt)|0)|0)+((8191&(n=(n=n+Math.imul(p,Mt)|0)+Math.imul(M,pt)|0))<<13)|0;a=((e=e+Math.imul(M,Mt)|0)+(n>>>13)|0)+(St>>>26)|0,St&=67108863,h=Math.imul(j,G),n=(n=Math.imul(j,Q))+Math.imul(K,G)|0,e=Math.imul(K,Q),h=h+Math.imul(z,W)|0,n=(n=n+Math.imul(z,X)|0)+Math.imul(E,W)|0,e=e+Math.imul(E,X)|0,h=h+Math.imul(L,$)|0,n=(n=n+Math.imul(L,tt)|0)+Math.imul(I,$)|0,e=e+Math.imul(I,tt)|0,h=h+Math.imul(q,rt)|0,n=(n=n+Math.imul(q,ht)|0)+Math.imul(B,rt)|0,e=e+Math.imul(B,ht)|0,h=h+Math.imul(S,et)|0,n=(n=n+Math.imul(S,ot)|0)+Math.imul(Z,et)|0,e=e+Math.imul(Z,ot)|0,h=h+Math.imul(k,ut)|0,n=(n=n+Math.imul(k,at)|0)+Math.imul(A,ut)|0,e=e+Math.imul(A,at)|0,h=h+Math.imul(y,mt)|0,n=(n=n+Math.imul(y,ft)|0)+Math.imul(b,mt)|0,e=e+Math.imul(b,ft)|0;var Zt=(a+(h=h+Math.imul(g,pt)|0)|0)+((8191&(n=(n=n+Math.imul(g,Mt)|0)+Math.imul(c,pt)|0))<<13)|0;a=((e=e+Math.imul(c,Mt)|0)+(n>>>13)|0)+(Zt>>>26)|0,Zt&=67108863,h=Math.imul(j,W),n=(n=Math.imul(j,X))+Math.imul(K,W)|0,e=Math.imul(K,X),h=h+Math.imul(z,$)|0,n=(n=n+Math.imul(z,tt)|0)+Math.imul(E,$)|0,e=e+Math.imul(E,tt)|0,h=h+Math.imul(L,rt)|0,n=(n=n+Math.imul(L,ht)|0)+Math.imul(I,rt)|0,e=e+Math.imul(I,ht)|0,h=h+Math.imul(q,et)|0,n=(n=n+Math.imul(q,ot)|0)+Math.imul(B,et)|0,e=e+Math.imul(B,ot)|0,h=h+Math.imul(S,ut)|0,n=(n=n+Math.imul(S,at)|0)+Math.imul(Z,ut)|0,e=e+Math.imul(Z,at)|0,h=h+Math.imul(k,mt)|0,n=(n=n+Math.imul(k,ft)|0)+Math.imul(A,mt)|0,e=e+Math.imul(A,ft)|0;var Rt=(a+(h=h+Math.imul(y,pt)|0)|0)+((8191&(n=(n=n+Math.imul(y,Mt)|0)+Math.imul(b,pt)|0))<<13)|0;a=((e=e+Math.imul(b,Mt)|0)+(n>>>13)|0)+(Rt>>>26)|0,Rt&=67108863,h=Math.imul(j,$),n=(n=Math.imul(j,tt))+Math.imul(K,$)|0,e=Math.imul(K,tt),h=h+Math.imul(z,rt)|0,n=(n=n+Math.imul(z,ht)|0)+Math.imul(E,rt)|0,e=e+Math.imul(E,ht)|0,h=h+Math.imul(L,et)|0,n=(n=n+Math.imul(L,ot)|0)+Math.imul(I,et)|0,e=e+Math.imul(I,ot)|0,h=h+Math.imul(q,ut)|0,n=(n=n+Math.imul(q,at)|0)+Math.imul(B,ut)|0,e=e+Math.imul(B,at)|0,h=h+Math.imul(S,mt)|0,n=(n=n+Math.imul(S,ft)|0)+Math.imul(Z,mt)|0,e=e+Math.imul(Z,ft)|0;var qt=(a+(h=h+Math.imul(k,pt)|0)|0)+((8191&(n=(n=n+Math.imul(k,Mt)|0)+Math.imul(A,pt)|0))<<13)|0;a=((e=e+Math.imul(A,Mt)|0)+(n>>>13)|0)+(qt>>>26)|0,qt&=67108863,h=Math.imul(j,rt),n=(n=Math.imul(j,ht))+Math.imul(K,rt)|0,e=Math.imul(K,ht),h=h+Math.imul(z,et)|0,n=(n=n+Math.imul(z,ot)|0)+Math.imul(E,et)|0,e=e+Math.imul(E,ot)|0,h=h+Math.imul(L,ut)|0,n=(n=n+Math.imul(L,at)|0)+Math.imul(I,ut)|0,e=e+Math.imul(I,at)|0,h=h+Math.imul(q,mt)|0,n=(n=n+Math.imul(q,ft)|0)+Math.imul(B,mt)|0,e=e+Math.imul(B,ft)|0;var Bt=(a+(h=h+Math.imul(S,pt)|0)|0)+((8191&(n=(n=n+Math.imul(S,Mt)|0)+Math.imul(Z,pt)|0))<<13)|0;a=((e=e+Math.imul(Z,Mt)|0)+(n>>>13)|0)+(Bt>>>26)|0,Bt&=67108863,h=Math.imul(j,et),n=(n=Math.imul(j,ot))+Math.imul(K,et)|0,e=Math.imul(K,ot),h=h+Math.imul(z,ut)|0,n=(n=n+Math.imul(z,at)|0)+Math.imul(E,ut)|0,e=e+Math.imul(E,at)|0,h=h+Math.imul(L,mt)|0,n=(n=n+Math.imul(L,ft)|0)+Math.imul(I,mt)|0,e=e+Math.imul(I,ft)|0;var Nt=(a+(h=h+Math.imul(q,pt)|0)|0)+((8191&(n=(n=n+Math.imul(q,Mt)|0)+Math.imul(B,pt)|0))<<13)|0;a=((e=e+Math.imul(B,Mt)|0)+(n>>>13)|0)+(Nt>>>26)|0,Nt&=67108863,h=Math.imul(j,ut),n=(n=Math.imul(j,at))+Math.imul(K,ut)|0,e=Math.imul(K,at),h=h+Math.imul(z,mt)|0,n=(n=n+Math.imul(z,ft)|0)+Math.imul(E,mt)|0,e=e+Math.imul(E,ft)|0;var Lt=(a+(h=h+Math.imul(L,pt)|0)|0)+((8191&(n=(n=n+Math.imul(L,Mt)|0)+Math.imul(I,pt)|0))<<13)|0;a=((e=e+Math.imul(I,Mt)|0)+(n>>>13)|0)+(Lt>>>26)|0,Lt&=67108863,h=Math.imul(j,mt),n=(n=Math.imul(j,ft))+Math.imul(K,mt)|0,e=Math.imul(K,ft);var It=(a+(h=h+Math.imul(z,pt)|0)|0)+((8191&(n=(n=n+Math.imul(z,Mt)|0)+Math.imul(E,pt)|0))<<13)|0;a=((e=e+Math.imul(E,Mt)|0)+(n>>>13)|0)+(It>>>26)|0,It&=67108863;var Tt=(a+(h=Math.imul(j,pt))|0)+((8191&(n=(n=Math.imul(j,Mt))+Math.imul(K,pt)|0))<<13)|0;return a=((e=Math.imul(K,Mt))+(n>>>13)|0)+(Tt>>>26)|0,Tt&=67108863,u[0]=vt,u[1]=gt,u[2]=ct,u[3]=wt,u[4]=yt,u[5]=bt,u[6]=_t,u[7]=kt,u[8]=At,u[9]=xt,u[10]=St,u[11]=Zt,u[12]=Rt,u[13]=qt,u[14]=Bt,u[15]=Nt,u[16]=Lt,u[17]=It,u[18]=Tt,0!==a&&(u[19]=a,r.length++),r};function M(t,i,r){return (new v).mulp(t,i,r)}function v(t,r){(this||i$3).x=t,(this||i$3).y=r;}Math.imul||(p=d),o.prototype.mulTo=function(t,r){var h=(this||i$3).length+t.length;return 10===(this||i$3).length&&10===t.length?p(this||i$3,t,r):h<63?d(this||i$3,t,r):h<1024?function(t,i,r){r.negative=i.negative^t.negative,r.length=t.length+i.length;for(var h=0,n=0,e=0;e<r.length-1;e++){var o=n;n=0;for(var s=67108863&h,u=Math.min(e,i.length-1),a=Math.max(0,e-t.length+1);a<=u;a++){var l=e-a,m=(0|t.words[l])*(0|i.words[a]),f=67108863&m;s=67108863&(f=f+s|0),n+=(o=(o=o+(m/67108864|0)|0)+(f>>>26)|0)>>>26,o&=67108863;}r.words[e]=s,h=o,o=n;}return 0!==h?r.words[e]=h:r.length--,r.strip()}(this||i$3,t,r):M(this||i$3,t,r)},v.prototype.makeRBT=function(t){for(var i=new Array(t),r=o.prototype._countBits(t)-1,h=0;h<t;h++)i[h]=this.revBin(h,r,t);return i},v.prototype.revBin=function(t,i,r){if(0===t||t===r-1)return t;for(var h=0,n=0;n<i;n++)h|=(1&t)<<i-n-1,t>>=1;return h},v.prototype.permute=function(t,i,r,h,n,e){for(var o=0;o<e;o++)h[o]=i[t[o]],n[o]=r[t[o]];},v.prototype.transform=function(t,i,r,h,n,e){this.permute(e,t,i,r,h,n);for(var o=1;o<n;o<<=1)for(var s=o<<1,u=Math.cos(2*Math.PI/s),a=Math.sin(2*Math.PI/s),l=0;l<n;l+=s)for(var m=u,f=a,d=0;d<o;d++){var p=r[l+d],M=h[l+d],v=r[l+d+o],g=h[l+d+o],c=m*v-f*g;g=m*g+f*v,v=c,r[l+d]=p+v,h[l+d]=M+g,r[l+d+o]=p-v,h[l+d+o]=M-g,d!==s&&(c=u*m-a*f,f=u*f+a*m,m=c);}},v.prototype.guessLen13b=function(t,i){var r=1|Math.max(i,t),h=1&r,n=0;for(r=r/2|0;r;r>>>=1)n++;return 1<<n+1+h},v.prototype.conjugate=function(t,i,r){if(!(r<=1))for(var h=0;h<r/2;h++){var n=t[h];t[h]=t[r-h-1],t[r-h-1]=n,n=i[h],i[h]=-i[r-h-1],i[r-h-1]=-n;}},v.prototype.normalize13b=function(t,i){for(var r=0,h=0;h<i/2;h++){var n=8192*Math.round(t[2*h+1]/i)+Math.round(t[2*h]/i)+r;t[h]=67108863&n,r=n<67108864?0:n/67108864|0;}return t},v.prototype.convert13b=function(t,i,r,h){for(var e=0,o=0;o<i;o++)e+=0|t[o],r[2*o]=8191&e,e>>>=13,r[2*o+1]=8191&e,e>>>=13;for(o=2*i;o<h;++o)r[o]=0;n(0===e),n(0==(-8192&e));},v.prototype.stub=function(t){for(var i=new Array(t),r=0;r<t;r++)i[r]=0;return i},v.prototype.mulp=function(t,i,r){var h=2*this.guessLen13b(t.length,i.length),n=this.makeRBT(h),e=this.stub(h),o=new Array(h),s=new Array(h),u=new Array(h),a=new Array(h),l=new Array(h),m=new Array(h),f=r.words;f.length=h,this.convert13b(t.words,t.length,o,h),this.convert13b(i.words,i.length,a,h),this.transform(o,e,s,u,h,n),this.transform(a,e,l,m,h,n);for(var d=0;d<h;d++){var p=s[d]*l[d]-u[d]*m[d];u[d]=s[d]*m[d]+u[d]*l[d],s[d]=p;}return this.conjugate(s,u,h),this.transform(s,u,f,e,h,n),this.conjugate(f,e,h),this.normalize13b(f,h),r.negative=t.negative^i.negative,r.length=t.length+i.length,r.strip()},o.prototype.mul=function(t){var r=new o(null);return r.words=new Array((this||i$3).length+t.length),this.mulTo(t,r)},o.prototype.mulf=function(t){var r=new o(null);return r.words=new Array((this||i$3).length+t.length),M(this||i$3,t,r)},o.prototype.imul=function(t){return this.clone().mulTo(t,this||i$3)},o.prototype.imuln=function(t){n("number"==typeof t),n(t<67108864);for(var r=0,h=0;h<(this||i$3).length;h++){var e=(0|(this||i$3).words[h])*t,o=(67108863&e)+(67108863&r);r>>=26,r+=e/67108864|0,r+=o>>>26,(this||i$3).words[h]=67108863&o;}return 0!==r&&((this||i$3).words[h]=r,(this||i$3).length++),this||i$3},o.prototype.muln=function(t){return this.clone().imuln(t)},o.prototype.sqr=function(){return this.mul(this||i$3)},o.prototype.isqr=function(){return this.imul(this.clone())},o.prototype.pow=function(t){var r=function(t){for(var i=new Array(t.bitLength()),r=0;r<i.length;r++){var h=r/26|0,n=r%26;i[r]=(t.words[h]&1<<n)>>>n;}return i}(t);if(0===r.length)return new o(1);for(var h=this||i$3,n=0;n<r.length&&0===r[n];n++,h=h.sqr());if(++n<r.length)for(var e=h.sqr();n<r.length;n++,e=e.sqr())0!==r[n]&&(h=h.mul(e));return h},o.prototype.iushln=function(t){n("number"==typeof t&&t>=0);var r,h=t%26,e=(t-h)/26,o=67108863>>>26-h<<26-h;if(0!==h){var s=0;for(r=0;r<(this||i$3).length;r++){var u=(this||i$3).words[r]&o,a=(0|(this||i$3).words[r])-u<<h;(this||i$3).words[r]=a|s,s=u>>>26-h;}s&&((this||i$3).words[r]=s,(this||i$3).length++);}if(0!==e){for(r=(this||i$3).length-1;r>=0;r--)(this||i$3).words[r+e]=(this||i$3).words[r];for(r=0;r<e;r++)(this||i$3).words[r]=0;(this||i$3).length+=e;}return this.strip()},o.prototype.ishln=function(t){return n(0===(this||i$3).negative),this.iushln(t)},o.prototype.iushrn=function(t,r,h){var e;n("number"==typeof t&&t>=0),e=r?(r-r%26)/26:0;var o=t%26,s=Math.min((t-o)/26,(this||i$3).length),u=67108863^67108863>>>o<<o,a=h;if(e-=s,e=Math.max(0,e),a){for(var l=0;l<s;l++)a.words[l]=(this||i$3).words[l];a.length=s;}if(0===s);else if((this||i$3).length>s)for((this||i$3).length-=s,l=0;l<(this||i$3).length;l++)(this||i$3).words[l]=(this||i$3).words[l+s];else (this||i$3).words[0]=0,(this||i$3).length=1;var m=0;for(l=(this||i$3).length-1;l>=0&&(0!==m||l>=e);l--){var f=0|(this||i$3).words[l];(this||i$3).words[l]=m<<26-o|f>>>o,m=f&u;}return a&&0!==m&&(a.words[a.length++]=m),0===(this||i$3).length&&((this||i$3).words[0]=0,(this||i$3).length=1),this.strip()},o.prototype.ishrn=function(t,r,h){return n(0===(this||i$3).negative),this.iushrn(t,r,h)},o.prototype.shln=function(t){return this.clone().ishln(t)},o.prototype.ushln=function(t){return this.clone().iushln(t)},o.prototype.shrn=function(t){return this.clone().ishrn(t)},o.prototype.ushrn=function(t){return this.clone().iushrn(t)},o.prototype.testn=function(t){n("number"==typeof t&&t>=0);var r=t%26,h=(t-r)/26,e=1<<r;return !((this||i$3).length<=h)&&!!((this||i$3).words[h]&e)},o.prototype.imaskn=function(t){n("number"==typeof t&&t>=0);var r=t%26,h=(t-r)/26;if(n(0===(this||i$3).negative,"imaskn works only with positive numbers"),(this||i$3).length<=h)return this||i$3;if(0!==r&&h++,(this||i$3).length=Math.min(h,(this||i$3).length),0!==r){var e=67108863^67108863>>>r<<r;(this||i$3).words[(this||i$3).length-1]&=e;}return this.strip()},o.prototype.maskn=function(t){return this.clone().imaskn(t)},o.prototype.iaddn=function(t){return n("number"==typeof t),n(t<67108864),t<0?this.isubn(-t):0!==(this||i$3).negative?1===(this||i$3).length&&(0|(this||i$3).words[0])<t?((this||i$3).words[0]=t-(0|(this||i$3).words[0]),(this||i$3).negative=0,this||i$3):((this||i$3).negative=0,this.isubn(t),(this||i$3).negative=1,this||i$3):this._iaddn(t)},o.prototype._iaddn=function(t){(this||i$3).words[0]+=t;for(var r=0;r<(this||i$3).length&&(this||i$3).words[r]>=67108864;r++)(this||i$3).words[r]-=67108864,r===(this||i$3).length-1?(this||i$3).words[r+1]=1:(this||i$3).words[r+1]++;return (this||i$3).length=Math.max((this||i$3).length,r+1),this||i$3},o.prototype.isubn=function(t){if(n("number"==typeof t),n(t<67108864),t<0)return this.iaddn(-t);if(0!==(this||i$3).negative)return (this||i$3).negative=0,this.iaddn(t),(this||i$3).negative=1,this||i$3;if((this||i$3).words[0]-=t,1===(this||i$3).length&&(this||i$3).words[0]<0)(this||i$3).words[0]=-(this||i$3).words[0],(this||i$3).negative=1;else for(var r=0;r<(this||i$3).length&&(this||i$3).words[r]<0;r++)(this||i$3).words[r]+=67108864,(this||i$3).words[r+1]-=1;return this.strip()},o.prototype.addn=function(t){return this.clone().iaddn(t)},o.prototype.subn=function(t){return this.clone().isubn(t)},o.prototype.iabs=function(){return (this||i$3).negative=0,this||i$3},o.prototype.abs=function(){return this.clone().iabs()},o.prototype._ishlnsubmul=function(t,r,h){var e,o,s=t.length+h;this._expand(s);var u=0;for(e=0;e<t.length;e++){o=(0|(this||i$3).words[e+h])+u;var a=(0|t.words[e])*r;u=((o-=67108863&a)>>26)-(a/67108864|0),(this||i$3).words[e+h]=67108863&o;}for(;e<(this||i$3).length-h;e++)u=(o=(0|(this||i$3).words[e+h])+u)>>26,(this||i$3).words[e+h]=67108863&o;if(0===u)return this.strip();for(n(-1===u),u=0,e=0;e<(this||i$3).length;e++)u=(o=-(0|(this||i$3).words[e])+u)>>26,(this||i$3).words[e]=67108863&o;return (this||i$3).negative=1,this.strip()},o.prototype._wordDiv=function(t,r){var h=((this||i$3).length,t.length),n=this.clone(),e=t,s=0|e.words[e.length-1];0!==(h=26-this._countBits(s))&&(e=e.ushln(h),n.iushln(h),s=0|e.words[e.length-1]);var u,a=n.length-e.length;if("mod"!==r){(u=new o(null)).length=a+1,u.words=new Array(u.length);for(var l=0;l<u.length;l++)u.words[l]=0;}var m=n.clone()._ishlnsubmul(e,1,a);0===m.negative&&(n=m,u&&(u.words[a]=1));for(var f=a-1;f>=0;f--){var d=67108864*(0|n.words[e.length+f])+(0|n.words[e.length+f-1]);for(d=Math.min(d/s|0,67108863),n._ishlnsubmul(e,d,f);0!==n.negative;)d--,n.negative=0,n._ishlnsubmul(e,1,f),n.isZero()||(n.negative^=1);u&&(u.words[f]=d);}return u&&u.strip(),n.strip(),"div"!==r&&0!==h&&n.iushrn(h),{div:u||null,mod:n}},o.prototype.divmod=function(t,r,h){return n(!t.isZero()),this.isZero()?{div:new o(0),mod:new o(0)}:0!==(this||i$3).negative&&0===t.negative?(u=this.neg().divmod(t,r),"mod"!==r&&(e=u.div.neg()),"div"!==r&&(s=u.mod.neg(),h&&0!==s.negative&&s.iadd(t)),{div:e,mod:s}):0===(this||i$3).negative&&0!==t.negative?(u=this.divmod(t.neg(),r),"mod"!==r&&(e=u.div.neg()),{div:e,mod:u.mod}):0!=((this||i$3).negative&t.negative)?(u=this.neg().divmod(t.neg(),r),"div"!==r&&(s=u.mod.neg(),h&&0!==s.negative&&s.isub(t)),{div:u.div,mod:s}):t.length>(this||i$3).length||this.cmp(t)<0?{div:new o(0),mod:this||i$3}:1===t.length?"div"===r?{div:this.divn(t.words[0]),mod:null}:"mod"===r?{div:null,mod:new o(this.modn(t.words[0]))}:{div:this.divn(t.words[0]),mod:new o(this.modn(t.words[0]))}:this._wordDiv(t,r);var e,s,u;},o.prototype.div=function(t){return this.divmod(t,"div",!1).div},o.prototype.mod=function(t){return this.divmod(t,"mod",!1).mod},o.prototype.umod=function(t){return this.divmod(t,"mod",!0).mod},o.prototype.divRound=function(t){var i=this.divmod(t);if(i.mod.isZero())return i.div;var r=0!==i.div.negative?i.mod.isub(t):i.mod,h=t.ushrn(1),n=t.andln(1),e=r.cmp(h);return e<0||1===n&&0===e?i.div:0!==i.div.negative?i.div.isubn(1):i.div.iaddn(1)},o.prototype.modn=function(t){n(t<=67108863);for(var r=(1<<26)%t,h=0,e=(this||i$3).length-1;e>=0;e--)h=(r*h+(0|(this||i$3).words[e]))%t;return h},o.prototype.idivn=function(t){n(t<=67108863);for(var r=0,h=(this||i$3).length-1;h>=0;h--){var e=(0|(this||i$3).words[h])+67108864*r;(this||i$3).words[h]=e/t|0,r=e%t;}return this.strip()},o.prototype.divn=function(t){return this.clone().idivn(t)},o.prototype.egcd=function(t){n(0===t.negative),n(!t.isZero());var r=this||i$3,h=t.clone();r=0!==r.negative?r.umod(t):r.clone();for(var e=new o(1),s=new o(0),u=new o(0),a=new o(1),l=0;r.isEven()&&h.isEven();)r.iushrn(1),h.iushrn(1),++l;for(var m=h.clone(),f=r.clone();!r.isZero();){for(var d=0,p=1;0==(r.words[0]&p)&&d<26;++d,p<<=1);if(d>0)for(r.iushrn(d);d-- >0;)(e.isOdd()||s.isOdd())&&(e.iadd(m),s.isub(f)),e.iushrn(1),s.iushrn(1);for(var M=0,v=1;0==(h.words[0]&v)&&M<26;++M,v<<=1);if(M>0)for(h.iushrn(M);M-- >0;)(u.isOdd()||a.isOdd())&&(u.iadd(m),a.isub(f)),u.iushrn(1),a.iushrn(1);r.cmp(h)>=0?(r.isub(h),e.isub(u),s.isub(a)):(h.isub(r),u.isub(e),a.isub(s));}return {a:u,b:a,gcd:h.iushln(l)}},o.prototype._invmp=function(t){n(0===t.negative),n(!t.isZero());var r=this||i$3,h=t.clone();r=0!==r.negative?r.umod(t):r.clone();for(var e,s=new o(1),u=new o(0),a=h.clone();r.cmpn(1)>0&&h.cmpn(1)>0;){for(var l=0,m=1;0==(r.words[0]&m)&&l<26;++l,m<<=1);if(l>0)for(r.iushrn(l);l-- >0;)s.isOdd()&&s.iadd(a),s.iushrn(1);for(var f=0,d=1;0==(h.words[0]&d)&&f<26;++f,d<<=1);if(f>0)for(h.iushrn(f);f-- >0;)u.isOdd()&&u.iadd(a),u.iushrn(1);r.cmp(h)>=0?(r.isub(h),s.isub(u)):(h.isub(r),u.isub(s));}return (e=0===r.cmpn(1)?s:u).cmpn(0)<0&&e.iadd(t),e},o.prototype.gcd=function(t){if(this.isZero())return t.abs();if(t.isZero())return this.abs();var i=this.clone(),r=t.clone();i.negative=0,r.negative=0;for(var h=0;i.isEven()&&r.isEven();h++)i.iushrn(1),r.iushrn(1);for(;;){for(;i.isEven();)i.iushrn(1);for(;r.isEven();)r.iushrn(1);var n=i.cmp(r);if(n<0){var e=i;i=r,r=e;}else if(0===n||0===r.cmpn(1))break;i.isub(r);}return r.iushln(h)},o.prototype.invm=function(t){return this.egcd(t).a.umod(t)},o.prototype.isEven=function(){return 0==(1&(this||i$3).words[0])},o.prototype.isOdd=function(){return 1==(1&(this||i$3).words[0])},o.prototype.andln=function(t){return (this||i$3).words[0]&t},o.prototype.bincn=function(t){n("number"==typeof t);var r=t%26,h=(t-r)/26,e=1<<r;if((this||i$3).length<=h)return this._expand(h+1),(this||i$3).words[h]|=e,this||i$3;for(var o=e,s=h;0!==o&&s<(this||i$3).length;s++){var u=0|(this||i$3).words[s];o=(u+=o)>>>26,u&=67108863,(this||i$3).words[s]=u;}return 0!==o&&((this||i$3).words[s]=o,(this||i$3).length++),this||i$3},o.prototype.isZero=function(){return 1===(this||i$3).length&&0===(this||i$3).words[0]},o.prototype.cmpn=function(t){var r,h=t<0;if(0!==(this||i$3).negative&&!h)return -1;if(0===(this||i$3).negative&&h)return 1;if(this.strip(),(this||i$3).length>1)r=1;else {h&&(t=-t),n(t<=67108863,"Number is too big");var e=0|(this||i$3).words[0];r=e===t?0:e<t?-1:1;}return 0!==(this||i$3).negative?0|-r:r},o.prototype.cmp=function(t){if(0!==(this||i$3).negative&&0===t.negative)return -1;if(0===(this||i$3).negative&&0!==t.negative)return 1;var r=this.ucmp(t);return 0!==(this||i$3).negative?0|-r:r},o.prototype.ucmp=function(t){if((this||i$3).length>t.length)return 1;if((this||i$3).length<t.length)return -1;for(var r=0,h=(this||i$3).length-1;h>=0;h--){var n=0|(this||i$3).words[h],e=0|t.words[h];if(n!==e){n<e?r=-1:n>e&&(r=1);break}}return r},o.prototype.gtn=function(t){return 1===this.cmpn(t)},o.prototype.gt=function(t){return 1===this.cmp(t)},o.prototype.gten=function(t){return this.cmpn(t)>=0},o.prototype.gte=function(t){return this.cmp(t)>=0},o.prototype.ltn=function(t){return -1===this.cmpn(t)},o.prototype.lt=function(t){return -1===this.cmp(t)},o.prototype.lten=function(t){return this.cmpn(t)<=0},o.prototype.lte=function(t){return this.cmp(t)<=0},o.prototype.eqn=function(t){return 0===this.cmpn(t)},o.prototype.eq=function(t){return 0===this.cmp(t)},o.red=function(t){return new k(t)},o.prototype.toRed=function(t){return n(!(this||i$3).red,"Already a number in reduction context"),n(0===(this||i$3).negative,"red works only with positives"),t.convertTo(this||i$3)._forceRed(t)},o.prototype.fromRed=function(){return n((this||i$3).red,"fromRed works only with numbers in reduction context"),(this||i$3).red.convertFrom(this||i$3)},o.prototype._forceRed=function(t){return (this||i$3).red=t,this||i$3},o.prototype.forceRed=function(t){return n(!(this||i$3).red,"Already a number in reduction context"),this._forceRed(t)},o.prototype.redAdd=function(t){return n((this||i$3).red,"redAdd works only with red numbers"),(this||i$3).red.add(this||i$3,t)},o.prototype.redIAdd=function(t){return n((this||i$3).red,"redIAdd works only with red numbers"),(this||i$3).red.iadd(this||i$3,t)},o.prototype.redSub=function(t){return n((this||i$3).red,"redSub works only with red numbers"),(this||i$3).red.sub(this||i$3,t)},o.prototype.redISub=function(t){return n((this||i$3).red,"redISub works only with red numbers"),(this||i$3).red.isub(this||i$3,t)},o.prototype.redShl=function(t){return n((this||i$3).red,"redShl works only with red numbers"),(this||i$3).red.shl(this||i$3,t)},o.prototype.redMul=function(t){return n((this||i$3).red,"redMul works only with red numbers"),(this||i$3).red._verify2(this||i$3,t),(this||i$3).red.mul(this||i$3,t)},o.prototype.redIMul=function(t){return n((this||i$3).red,"redMul works only with red numbers"),(this||i$3).red._verify2(this||i$3,t),(this||i$3).red.imul(this||i$3,t)},o.prototype.redSqr=function(){return n((this||i$3).red,"redSqr works only with red numbers"),(this||i$3).red._verify1(this||i$3),(this||i$3).red.sqr(this||i$3)},o.prototype.redISqr=function(){return n((this||i$3).red,"redISqr works only with red numbers"),(this||i$3).red._verify1(this||i$3),(this||i$3).red.isqr(this||i$3)},o.prototype.redSqrt=function(){return n((this||i$3).red,"redSqrt works only with red numbers"),(this||i$3).red._verify1(this||i$3),(this||i$3).red.sqrt(this||i$3)},o.prototype.redInvm=function(){return n((this||i$3).red,"redInvm works only with red numbers"),(this||i$3).red._verify1(this||i$3),(this||i$3).red.invm(this||i$3)},o.prototype.redNeg=function(){return n((this||i$3).red,"redNeg works only with red numbers"),(this||i$3).red._verify1(this||i$3),(this||i$3).red.neg(this||i$3)},o.prototype.redPow=function(t){return n((this||i$3).red&&!t.red,"redPow(normalNum)"),(this||i$3).red._verify1(this||i$3),(this||i$3).red.pow(this||i$3,t)};var g={k256:null,p224:null,p192:null,p25519:null};function c(t,r){(this||i$3).name=t,(this||i$3).p=new o(r,16),(this||i$3).n=(this||i$3).p.bitLength(),(this||i$3).k=new o(1).iushln((this||i$3).n).isub((this||i$3).p),(this||i$3).tmp=this._tmp();}function w(){c.call(this||i$3,"k256","ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");}function y(){c.call(this||i$3,"p224","ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");}function b(){c.call(this||i$3,"p192","ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");}function _(){c.call(this||i$3,"25519","7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");}function k(t){if("string"==typeof t){var r=o._prime(t);(this||i$3).m=r.p,(this||i$3).prime=r;}else n(t.gtn(1),"modulus must be greater than 1"),(this||i$3).m=t,(this||i$3).prime=null;}function A(t){k.call(this||i$3,t),(this||i$3).shift=(this||i$3).m.bitLength(),(this||i$3).shift%26!=0&&((this||i$3).shift+=26-(this||i$3).shift%26),(this||i$3).r=new o(1).iushln((this||i$3).shift),(this||i$3).r2=this.imod((this||i$3).r.sqr()),(this||i$3).rinv=(this||i$3).r._invmp((this||i$3).m),(this||i$3).minv=(this||i$3).rinv.mul((this||i$3).r).isubn(1).div((this||i$3).m),(this||i$3).minv=(this||i$3).minv.umod((this||i$3).r),(this||i$3).minv=(this||i$3).r.sub((this||i$3).minv);}c.prototype._tmp=function(){var t=new o(null);return t.words=new Array(Math.ceil((this||i$3).n/13)),t},c.prototype.ireduce=function(t){var r,h=t;do{this.split(h,(this||i$3).tmp),r=(h=(h=this.imulK(h)).iadd((this||i$3).tmp)).bitLength();}while(r>(this||i$3).n);var n=r<(this||i$3).n?-1:h.ucmp((this||i$3).p);return 0===n?(h.words[0]=0,h.length=1):n>0?h.isub((this||i$3).p):h.strip(),h},c.prototype.split=function(t,r){t.iushrn((this||i$3).n,0,r);},c.prototype.imulK=function(t){return t.imul((this||i$3).k)},e(w,c),w.prototype.split=function(t,i){for(var r=Math.min(t.length,9),h=0;h<r;h++)i.words[h]=t.words[h];if(i.length=r,t.length<=9)return t.words[0]=0,t.length=1,void 0;var n=t.words[9];for(i.words[i.length++]=4194303&n,h=10;h<t.length;h++){var e=0|t.words[h];t.words[h-10]=(4194303&e)<<4|n>>>22,n=e;}n>>>=22,t.words[h-10]=n,0===n&&t.length>10?t.length-=10:t.length-=9;},w.prototype.imulK=function(t){t.words[t.length]=0,t.words[t.length+1]=0,t.length+=2;for(var i=0,r=0;r<t.length;r++){var h=0|t.words[r];i+=977*h,t.words[r]=67108863&i,i=64*h+(i/67108864|0);}return 0===t.words[t.length-1]&&(t.length--,0===t.words[t.length-1]&&t.length--),t},e(y,c),e(b,c),e(_,c),_.prototype.imulK=function(t){for(var i=0,r=0;r<t.length;r++){var h=19*(0|t.words[r])+i,n=67108863&h;h>>>=26,t.words[r]=n,i=h;}return 0!==i&&(t.words[t.length++]=i),t},o._prime=function(t){if(g[t])return g[t];var i;if("k256"===t)i=new w;else if("p224"===t)i=new y;else if("p192"===t)i=new b;else {if("p25519"!==t)throw new Error("Unknown prime "+t);i=new _;}return g[t]=i,i},k.prototype._verify1=function(t){n(0===t.negative,"red works only with positives"),n(t.red,"red works only with red numbers");},k.prototype._verify2=function(t,i){n(0==(t.negative|i.negative),"red works only with positives"),n(t.red&&t.red===i.red,"red works only with red numbers");},k.prototype.imod=function(t){return (this||i$3).prime?(this||i$3).prime.ireduce(t)._forceRed(this||i$3):t.umod((this||i$3).m)._forceRed(this||i$3)},k.prototype.neg=function(t){return t.isZero()?t.clone():(this||i$3).m.sub(t)._forceRed(this||i$3)},k.prototype.add=function(t,r){this._verify2(t,r);var h=t.add(r);return h.cmp((this||i$3).m)>=0&&h.isub((this||i$3).m),h._forceRed(this||i$3)},k.prototype.iadd=function(t,r){this._verify2(t,r);var h=t.iadd(r);return h.cmp((this||i$3).m)>=0&&h.isub((this||i$3).m),h},k.prototype.sub=function(t,r){this._verify2(t,r);var h=t.sub(r);return h.cmpn(0)<0&&h.iadd((this||i$3).m),h._forceRed(this||i$3)},k.prototype.isub=function(t,r){this._verify2(t,r);var h=t.isub(r);return h.cmpn(0)<0&&h.iadd((this||i$3).m),h},k.prototype.shl=function(t,i){return this._verify1(t),this.imod(t.ushln(i))},k.prototype.imul=function(t,i){return this._verify2(t,i),this.imod(t.imul(i))},k.prototype.mul=function(t,i){return this._verify2(t,i),this.imod(t.mul(i))},k.prototype.isqr=function(t){return this.imul(t,t.clone())},k.prototype.sqr=function(t){return this.mul(t,t)},k.prototype.sqrt=function(t){if(t.isZero())return t.clone();var r=(this||i$3).m.andln(3);if(n(r%2==1),3===r){var h=(this||i$3).m.add(new o(1)).iushrn(2);return this.pow(t,h)}for(var e=(this||i$3).m.subn(1),s=0;!e.isZero()&&0===e.andln(1);)s++,e.iushrn(1);n(!e.isZero());var u=new o(1).toRed(this||i$3),a=u.redNeg(),l=(this||i$3).m.subn(1).iushrn(1),m=(this||i$3).m.bitLength();for(m=new o(2*m*m).toRed(this||i$3);0!==this.pow(m,l).cmp(a);)m.redIAdd(a);for(var f=this.pow(m,e),d=this.pow(t,e.addn(1).iushrn(1)),p=this.pow(t,e),M=s;0!==p.cmp(u);){for(var v=p,g=0;0!==v.cmp(u);g++)v=v.redSqr();n(g<M);var c=this.pow(f,new o(1).iushln(M-g-1));d=d.redMul(c),f=c.redSqr(),p=p.redMul(f),M=g;}return d},k.prototype.invm=function(t){var r=t._invmp((this||i$3).m);return 0!==r.negative?(r.negative=0,this.imod(r).redNeg()):this.imod(r)},k.prototype.pow=function(t,r){if(r.isZero())return new o(1).toRed(this||i$3);if(0===r.cmpn(1))return t.clone();var h=new Array(16);h[0]=new o(1).toRed(this||i$3),h[1]=t;for(var n=2;n<h.length;n++)h[n]=this.mul(h[n-1],t);var e=h[0],s=0,u=0,a=r.bitLength()%26;for(0===a&&(a=26),n=r.length-1;n>=0;n--){for(var l=r.words[n],m=a-1;m>=0;m--){var f=l>>m&1;e!==h[0]&&(e=this.sqr(e)),0!==f||0!==s?(s<<=1,s|=f,(4===++u||0===n&&0===m)&&(e=this.mul(e,h[s]),u=0,s=0)):u=0;}a=26;}return e},k.prototype.convertTo=function(t){var r=t.umod((this||i$3).m);return r===t?r.clone():r},k.prototype.convertFrom=function(t){var i=t.clone();return i.red=null,i},o.mont=function(t){return new A(t)},e(A,k),A.prototype.convertTo=function(t){return this.imod(t.ushln((this||i$3).shift))},A.prototype.convertFrom=function(t){var r=this.imod(t.mul((this||i$3).rinv));return r.red=null,r},A.prototype.imul=function(t,r){if(t.isZero()||r.isZero())return t.words[0]=0,t.length=1,t;var h=t.imul(r),n=h.maskn((this||i$3).shift).mul((this||i$3).minv).imaskn((this||i$3).shift).mul((this||i$3).m),e=h.isub(n).iushrn((this||i$3).shift),o=e;return e.cmp((this||i$3).m)>=0?o=e.isub((this||i$3).m):e.cmpn(0)<0&&(o=e.iadd((this||i$3).m)),o._forceRed(this||i$3)},A.prototype.mul=function(t,r){if(t.isZero()||r.isZero())return new o(0)._forceRed(this||i$3);var h=t.mul(r),n=h.maskn((this||i$3).shift).mul((this||i$3).minv).imaskn((this||i$3).shift).mul((this||i$3).m),e=h.isub(n).iushrn((this||i$3).shift),s=e;return e.cmp((this||i$3).m)>=0?s=e.isub((this||i$3).m):e.cmpn(0)<0&&(s=e.iadd((this||i$3).m)),s._forceRed(this||i$3)},A.prototype.invm=function(t){return this.imod(t._invmp((this||i$3).m).mul((this||i$3).r2))._forceRed(this||i$3)};}(h$a,r$7);var n$c=h$a.exports;var t$5,e$a,r$8=Object.freeze({}),n$d="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global;function o$d(t){(this||n$d).rand=t;}if((t$5=function(t){return e$a||(e$a=new o$d(null)),e$a.generate(t)}).Rand=o$d,o$d.prototype.generate=function(t){return this._rand(t)},o$d.prototype._rand=function(t){if((this||n$d).rand.getBytes)return (this||n$d).rand.getBytes(t);for(var e=new Uint8Array(t),r=0;r<e.length;r++)e[r]=(this||n$d).rand.getByte();return e},"object"==typeof self)self.crypto&&self.crypto.getRandomValues?o$d.prototype._rand=function(t){var e=new Uint8Array(t);return self.crypto.getRandomValues(e),e}:self.msCrypto&&self.msCrypto.getRandomValues?o$d.prototype._rand=function(t){var e=new Uint8Array(t);return self.msCrypto.getRandomValues(e),e}:"object"==typeof window&&(o$d.prototype._rand=function(){throw new Error("Not implemented yet")});else try{var a$e=r$8;if("function"!=typeof a$e.randomBytes)throw new Error("Not supported");o$d.prototype._rand=function(t){return a$e.randomBytes(t)};}catch(t){}var f$i=t$5;var n$e,t$6="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,o$e=n$c,a$f=f$i;function d$b(r){(this||t$6).rand=r||new a$f.Rand;}n$e=d$b,d$b.create=function(r){return new d$b(r)},d$b.prototype._randbelow=function(r){var e=r.bitLength(),n=Math.ceil(e/8);do{var a=new o$e((this||t$6).rand.generate(n));}while(a.cmp(r)>=0);return a},d$b.prototype._randrange=function(r,e){var n=e.sub(r);return r.add(this._randbelow(n))},d$b.prototype.test=function(r,e,n){var t=r.bitLength(),a=o$e.mont(r),d=new o$e(1).toRed(a);e||(e=Math.max(1,t/48|0));for(var i=r.subn(1),f=0;!i.testn(f);f++);for(var u=r.shrn(f),p=i.toRed(a);e>0;e--){var c=this._randrange(new o$e(2),i);n&&n(c);var s=c.toRed(a).redPow(u);if(0!==s.cmp(d)&&0!==s.cmp(p)){for(var m=1;m<f;m++){if(0===(s=s.redSqr()).cmp(d))return !1;if(0===s.cmp(p))break}if(m===f)return !1}}return !0},d$b.prototype.getDivisor=function(r,e){var n=r.bitLength(),t=o$e.mont(r),a=new o$e(1).toRed(t);e||(e=Math.max(1,n/48|0));for(var d=r.subn(1),i=0;!d.testn(i);i++);for(var f=r.shrn(i),u=d.toRed(t);e>0;e--){var p=this._randrange(new o$e(2),d),c=r.gcd(p);if(0!==c.cmpn(1))return c;var s=p.toRed(t).redPow(f);if(0!==s.cmp(a)&&0!==s.cmp(u)){for(var m=1;m<i;m++){if(0===(s=s.redSqr()).cmp(a))return s.fromRed().subn(1).gcd(r);if(0===s.cmp(u))break}if(m===i)return (s=s.redSqr()).fromRed().subn(1).gcd(r)}}return !1};var i$4=n$e;var b$7,d$c=a;b$7=v$9,v$9.simpleSieve=_$9,v$9.fermatTest=g$8;var r$9=n$c,t$7=new r$9(24),n$f=new i$4,i$5=new r$9(1),o$f=new r$9(2),p$e=new r$9(5),s$c=(new r$9(16),new r$9(8),new r$9(10)),m$9=new r$9(3),u$b=(new r$9(7),new r$9(11)),h$b=new r$9(4),w$a=(new r$9(12),null);function l$c(){if(null!==w$a)return w$a;var f=[];f[0]=2;for(var e=1,c=3;c<1048576;c+=2){for(var a=Math.ceil(Math.sqrt(c)),b=0;b<e&&f[b]<=a&&c%f[b]!=0;b++);e!==b&&f[b]<=a||(f[e++]=c);}return w$a=f,f}function _$9(f){for(var e=l$c(),c=0;c<e.length;c++)if(0===f.modn(e[c]))return 0===f.cmpn(e[c]);return !0}function g$8(f){var e=r$9.mont(f);return 0===o$f.toRed(e).redPow(f.subn(1)).fromRed().cmpn(1)}function v$9(f,e){if(f<16)return new r$9(2===e||5===e?[140,123]:[140,39]);var c,a;for(e=new r$9(e);;){for(c=new r$9(d$c(Math.ceil(f/8)));c.bitLength()>f;)c.ishrn(1);if(c.isEven()&&c.iadd(i$5),c.testn(1)||c.iadd(o$f),e.cmp(o$f)){if(!e.cmp(p$e))for(;c.mod(s$c).cmp(m$9);)c.iadd(h$b);}else for(;c.mod(t$7).cmp(u$b);)c.iadd(h$b);if(_$9(a=c.shrn(1))&&_$9(c)&&g$8(a)&&g$8(c)&&n$f.test(a)&&n$f.test(c))return c}}var y$9,P$2=b$7,B$5="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:global,K$2=e$1$1$1.Buffer,R$1=n$c,S$5=new i$4,x$2=new R$1(24),C$2=new R$1(11),D$2=new R$1(10),G$1=new R$1(3),H$2=new R$1(7),T$3=P$2,j$1=a;function E$6(f,e){return e=e||"utf8",K$2.isBuffer(f)||(f=new K$2(f,e)),(this||B$5)._pub=new R$1(f),this||B$5}function L$1(f,e){return e=e||"utf8",K$2.isBuffer(f)||(f=new K$2(f,e)),(this||B$5)._priv=new R$1(f),this||B$5}y$9=k$7;var M$4={};function k$7(f,e,c){this.setGenerator(e),(this||B$5).__prime=new R$1(f),(this||B$5)._prime=R$1.mont((this||B$5).__prime),(this||B$5)._primeLen=f.length,(this||B$5)._pub=void 0,(this||B$5)._priv=void 0,(this||B$5)._primeCode=void 0,c?((this||B$5).setPublicKey=E$6,(this||B$5).setPrivateKey=L$1):(this||B$5)._primeCode=8;}function A$5(f,e){var c=new K$2(f.toArray());return e?c.toString(e):c}Object.defineProperty(k$7.prototype,"verifyError",{enumerable:!0,get:function(){return "number"!=typeof(this||B$5)._primeCode&&((this||B$5)._primeCode=function(f,e){var c=e.toString("hex"),a=[c,f.toString(16)].join("_");if(a in M$4)return M$4[a];var b,d=0;if(f.isEven()||!T$3.simpleSieve||!T$3.fermatTest(f)||!S$5.test(f))return d+=1,d+="02"===c||"05"===c?8:4,M$4[a]=d,d;switch(S$5.test(f.shrn(1))||(d+=2),c){case"02":f.mod(x$2).cmp(C$2)&&(d+=8);break;case"05":(b=f.mod(D$2)).cmp(G$1)&&b.cmp(H$2)&&(d+=8);break;default:d+=4;}return M$4[a]=d,d}((this||B$5).__prime,(this||B$5).__gen)),(this||B$5)._primeCode}}),k$7.prototype.generateKeys=function(){return (this||B$5)._priv||((this||B$5)._priv=new R$1(j$1((this||B$5)._primeLen))),(this||B$5)._pub=(this||B$5)._gen.toRed((this||B$5)._prime).redPow((this||B$5)._priv).fromRed(),this.getPublicKey()},k$7.prototype.computeSecret=function(f){var e=(f=(f=new R$1(f)).toRed((this||B$5)._prime)).redPow((this||B$5)._priv).fromRed(),c=new K$2(e.toArray()),a=this.getPrime();if(c.length<a.length){var b=new K$2(a.length-c.length);b.fill(0),c=K$2.concat([b,c]);}return c},k$7.prototype.getPublicKey=function(f){return A$5((this||B$5)._pub,f)},k$7.prototype.getPrivateKey=function(f){return A$5((this||B$5)._priv,f)},k$7.prototype.getPrime=function(f){return A$5((this||B$5).__prime,f)},k$7.prototype.getGenerator=function(f){return A$5((this||B$5)._gen,f)},k$7.prototype.setGenerator=function(f,e){return e=e||"utf8",K$2.isBuffer(f)||(f=new K$2(f,e)),(this||B$5).__gen=f,(this||B$5)._gen=new R$1(f),this||B$5};var q$1=y$9,O$3={},z$3=e$1$1$1.Buffer,F$3=P$2,I$6={modp1:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"},modp2:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"},modp5:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"},modp14:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"},modp15:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"},modp16:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"},modp17:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"},modp18:{gen:"02",prime:"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"}},J$1=q$1;var N$2={binary:!0,hex:!0,base64:!0};O$3.DiffieHellmanGroup=O$3.createDiffieHellmanGroup=O$3.getDiffieHellman=function(f){var e=new z$3(I$6[f].prime,"hex"),c=new z$3(I$6[f].gen,"hex");return new J$1(e,c)},O$3.createDiffieHellman=O$3.DiffieHellman=function f(e,c,a,b){return z$3.isBuffer(c)||void 0===N$2[c]?f(e,"binary",c,a):(c=c||"binary",b=b||"binary",a=a||new z$3([2]),z$3.isBuffer(a)||(a=new z$3(a,b)),"number"==typeof e?new J$1(F$3(e,a),a,!0):(z$3.isBuffer(e)||(e=new z$3(e,c)),new J$1(e,a,!0)))};var m$a,u$c=e$1$1$1.Buffer,n$g=n$c,d$d=a;function t$8(e,o){var r=function(e){var o=i$6(e);return {blinder:o.toRed(n$g.mont(e.modulus)).redPow(new n$g(e.publicExponent)).fromRed(),unblinder:o.invm(e.modulus)}}(o),m=o.modulus.byteLength(),d=(n$g.mont(o.modulus),new n$g(e).mul(r.blinder).umod(o.modulus)),t=d.toRed(n$g.mont(o.prime1)),l=d.toRed(n$g.mont(o.prime2)),f=o.coefficient,p=o.prime1,b=o.prime2,s=t.redPow(o.exponent1),a=l.redPow(o.exponent2);s=s.fromRed(),a=a.fromRed();var w=s.isub(a).imul(f).umod(p);return w.imul(b),a.iadd(w),new u$c(a.imul(r.unblinder).umod(o.modulus).toArray(!1,m))}function i$6(e){for(var o=e.modulus.byteLength(),r=new n$g(d$d(o));r.cmp(e.modulus)>=0||!r.umod(e.prime1)||!r.umod(e.prime2);)r=new n$g(d$d(o));return r}m$a=t$8,t$8.getr=i$6;var l$d=m$a;var r$a={},e$b=r$a;function t$9(r){return 1===r.length?"0"+r:r}function n$h(r){for(var e="",n=0;n<r.length;n++)e+=t$9(r[n].toString(16));return e}e$b.toArray=function(r,e){if(Array.isArray(r))return r.slice();if(!r)return [];var t=[];if("string"!=typeof r){for(var n=0;n<r.length;n++)t[n]=0|r[n];return t}if("hex"===e){(r=r.replace(/[^a-z0-9]+/gi,"")).length%2!=0&&(r="0"+r);for(n=0;n<r.length;n+=2)t.push(parseInt(r[n]+r[n+1],16));}else for(n=0;n<r.length;n++){var o=r.charCodeAt(n),u=o>>8,f=255&o;u?t.push(u,f):t.push(f);}return t},e$b.zero2=t$9,e$b.toHex=n$h,e$b.encode=function(r,e){return "hex"===e?n$h(r):r};var n$i={},a$g=n$i,i$7=n$c,o$g=o$7,c$d=r$a;a$g.assert=o$g,a$g.toArray=c$d.toArray,a$g.zero2=c$d.zero2,a$g.toHex=c$d.toHex,a$g.encode=c$d.encode,a$g.getNAF=function(r,t,e){var n=new Array(Math.max(r.bitLength(),e)+1);n.fill(0);for(var a=1<<t+1,i=r.clone(),o=0;o<n.length;o++){var c,s=i.andln(a-1);i.isOdd()?(c=s>(a>>1)-1?(a>>1)-s:s,i.isubn(c)):c=0,n[o]=c,i.iushrn(1);}return n},a$g.getJSF=function(r,t){var e=[[],[]];r=r.clone(),t=t.clone();for(var n=0,a=0;r.cmpn(-n)>0||t.cmpn(-a)>0;){var i,o,c,s=r.andln(3)+n&3,l=t.andln(3)+a&3;if(3===s&&(s=-1),3===l&&(l=-1),0==(1&s))i=0;else i=3!==(c=r.andln(7)+n&7)&&5!==c||2!==l?s:-s;if(e[0].push(i),0==(1&l))o=0;else o=3!==(c=t.andln(7)+a&7)&&5!==c||2!==s?l:-l;e[1].push(o),2*n===i+1&&(n=1-n),2*a===o+1&&(a=1-a),r.iushrn(1),t.iushrn(1);}return e},a$g.cachedProperty=function(r,t,e){var n="_"+t;r.prototype[t]=function(){return void 0!==this[n]?this[n]:this[n]=e.call(this)};},a$g.parseBytes=function(r){return "string"==typeof r?a$g.toArray(r,"hex"):r},a$g.intFromLE=function(r){return new i$7(r,"hex","le")};var s$d,l$e=n$c,u$d=n$i,h$c=u$d.assert;function p$f(r,t){if(r instanceof p$f)return r;this._importDER(r,t)||(h$c(r.r&&r.s,"Signature without r or s"),this.r=new l$e(r.r,16),this.s=new l$e(r.s,16),void 0===r.recoveryParam?this.recoveryParam=null:this.recoveryParam=r.recoveryParam);}function f$j(){this.place=0;}function v$a(r,t){var e=r[t.place++];if(!(128&e))return e;for(var n=15&e,a=0,i=0,o=t.place;i<n;i++,o++)a<<=8,a|=r[o];return t.place=o,a}function m$b(r){for(var t=0,e=r.length-1;!r[t]&&!(128&r[t+1])&&t<e;)t++;return 0===t?r:r.slice(t)}function y$a(r,t){if(t<128)return r.push(t),void 0;var e=1+(Math.log(t)/Math.LN2>>>3);for(r.push(128|e);--e;)r.push(t>>>(e<<3)&255);r.push(t);}s$d=p$f,p$f.prototype._importDER=function(r,t){r=u$d.toArray(r,t);var e=new f$j;if(48!==r[e.place++])return !1;if(v$a(r,e)+e.place!==r.length)return !1;if(2!==r[e.place++])return !1;var n=v$a(r,e),a=r.slice(e.place,n+e.place);if(e.place+=n,2!==r[e.place++])return !1;var i=v$a(r,e);if(r.length!==i+e.place)return !1;var o=r.slice(e.place,i+e.place);return 0===a[0]&&128&a[1]&&(a=a.slice(1)),0===o[0]&&128&o[1]&&(o=o.slice(1)),this.r=new l$e(a),this.s=new l$e(o),this.recoveryParam=null,!0},p$f.prototype.toDER=function(r){var t=this.r.toArray(),e=this.s.toArray();for(128&t[0]&&(t=[0].concat(t)),128&e[0]&&(e=[0].concat(e)),t=m$b(t),e=m$b(e);!(e[0]||128&e[1]);)e=e.slice(1);var n=[2];y$a(n,t.length),(n=n.concat(t)).push(2),y$a(n,e.length);var a=n.concat(e),i=[48];return y$a(i,a.length),i=i.concat(a),u$d.encode(i,r)};var d$e=s$d;var r$b={},i$8=o$7,e$c=t$2$2;function h$d(t,n){return 55296==(64512&t.charCodeAt(n))&&(!(n<0||n+1>=t.length)&&56320==(64512&t.charCodeAt(n+1)))}function o$h(t){return (t>>>24|t>>>8&65280|t<<8&16711680|(255&t)<<24)>>>0}function u$e(t){return 1===t.length?"0"+t:t}function s$e(t){return 7===t.length?"0"+t:6===t.length?"00"+t:5===t.length?"000"+t:4===t.length?"0000"+t:3===t.length?"00000"+t:2===t.length?"000000"+t:1===t.length?"0000000"+t:t}r$b.inherits=e$c,r$b.toArray=function(t,n){if(Array.isArray(t))return t.slice();if(!t)return [];var r=[];if("string"==typeof t)if(n){if("